<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【地理投稿】高分学长手把手教你做案例库</title>
      <link href="2023/02/14/geography/"/>
      <url>2023/02/14/geography/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h1><p>本文是作者为公众号”羊羊的地理教室”所撰写的原创稿件，首发于公众号”羊羊的地理教室“。原文请点击<a href="https://mp.weixin.qq.com/s/IcOJL9R90YW0x5K6M5q4pQ">这里</a>查看。</p><hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>新高考中，地理命题趋势逐渐转为“小切口，深分析”的类型，在知识细节的对比、辨析上，对考生能力提出了更高要求。</p><p>这导致不少同学看到题很熟，但又毫无思路，这在考场上是很令人头疼的。</p><p>若想避免这种情况，就需要平时在做题后，及时进行整理和反思。</p><p>今天，我们来看一位学长的投稿，看看他是如何利用“案例库”进行知识积累，一步步攀登，拿下高考97的好成绩。</p><hr><h1 id="什么是案例库？"><a href="#什么是案例库？" class="headerlink" title="什么是案例库？"></a>什么是案例库？</h1><p>案例库可以理解为题集，内容包括<strong>好题目和零散知识点</strong>。</p><p><strong>好题目</strong>包括三类：</p><p>第一类是指在认知死角或思维惯性上设陷阱的题目。</p><p>比如东数西算可以视为算力资源的调配，如果做题时候陷入了资源调配只是调配实物的认知死角而失分，整理时的体会就可以是资源调配不局限于实际调配，也可以是一些抽象资源调配。</p><p>第二类指能代表性突出的题目。</p><p>比如分析自然原因，无非是“地气水土生灾”六个角度。那么在第一次碰到的时候就可以整理到案例库，之后遇到自然原因的题目都以其为母版进行分析。</p><p>第三类指逻辑性很强的题目。</p><p>这类题目思维难度往往很大，需要从材料中寻找切入点，之后一步一步推理出最后的答案。整理的重点在于答案，需要把分析的切入点，以及每一步推理的依据标记清楚，以便于考试时根据题目去寻找相似的逻辑线套用。</p><p><img src= "/img/loading.gif" data-lazy-src="https://ldbbs.ldmnq.com/bbs/topic/attachment/2023-2/acf48a24-00e2-4d32-ad6b-c46fe4a9f452.png" alt="图源网络"></p><p><strong>零散知识点</strong>不单是指做题时遇到且恰好掌握不熟练的知识点，还包括一些传统知识点的延伸。</p><p>比如工业4.0，它属于工业的延伸，但本质还是在考察工业区位。不过它和传统工业在细节上具有很大区别。故需要积累其和传统工业的不同之处，以便于考场上快速做出正确的分析和判断。</p><p>在羊羊的公众号里就有着很多知识点的拓展。比如上周的虚拟水、泻风等，还有之前的风光消纳、土地流转、相对湿度和绝对湿度等，都做了详细、清晰的讲解，很适合整理加入案例库。</p><p>整理时，好题目应该整理这道题的题干、答案和你做题时的收获。零散知识点需要整理这个知识点的概念、特点、影响等相关信息。（比如果园套袋可以分析这么做的优缺点，工业4.0可以分析其背景，特点和影响）</p><p><img src= "/img/loading.gif" data-lazy-src="https://ldbbs.ldmnq.com/bbs/topic/attachment/2023-2/4b1703b7-b7ed-4f73-a623-6bc54a26b997.png" alt="学长对工业4.0的分析和记录"></p><hr><h1 id="为什么要做案例库？"><a href="#为什么要做案例库？" class="headerlink" title="为什么要做案例库？"></a>为什么要做案例库？</h1><p>如果把高中地理比作一个房子，那么知识点和做题方法就是房子里的物件。而考试，就是要求你找出一些特定的物件并用它们解决问题。</p><p>每次做题时，你可能会有新的做题方法或心得体会。这些方法和体会就好像你购买了一个新的物件，需要第一时间收纳和整理到不同的地方，以便你需要的时候能及时找到，否则家里会越来越乱。</p><p>如果无法快速对考题中涉及的知识点进行<strong>对比，补充，辨析，确认</strong>，就会让我们在时间有限的考场上晕头转向，找不到准确的作答方向。</p><p><img src= "/img/loading.gif" data-lazy-src="https://ldbbs.ldmnq.com/bbs/topic/attachment/2023-2/79d50a32-cf7c-4d67-b1c8-0f1fbf11dd47.png" alt="图源网络"></p><p>而案例库就好像一个个收纳盒，及时地对知识点进行归纳整理。当达到一定的积累量后，你将拥有在考场上迅速提取所需知识点的能力，为冲击高分提供充分的保障。</p><hr><h1 id="怎样整理案例库？"><a href="#怎样整理案例库？" class="headerlink" title="怎样整理案例库？"></a>怎样整理案例库？</h1><p>首先，你需要有一本用来整理的笔记本。<strong>必须是活页本！！！必须是活页本！！！必须是活页本！！！</strong>（重要的事情说三遍）。最好是B5或者A4尺寸的钢圈活页本（塑料圈后期会被撑坏）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://ldbbs.ldmnq.com/bbs/topic/attachment/2023-2/8eb3092d-eaac-4935-8660-ea04dfeb1bc3.png" alt="比如这种"></p><p>其次，你需要有一个包括含高中地理所有知识点的目录，放在活页本的第一页。这份目录学长已经给你们准备好啦，放在下面，拿走不谢。</p><p><img src= "/img/loading.gif" data-lazy-src="https://ldbbs.ldmnq.com/bbs/topic/attachment/2023-2/74ef2b0a-7e66-40a7-8bb5-8dcb7ebdb133.png" alt="这是案例库的目录"></p><p><img src= "/img/loading.gif" data-lazy-src="https://ldbbs.ldmnq.com/bbs/topic/attachment/2023-2/dad37b5b-7bee-4b89-8328-7df694bda56a.png" alt="这份是学长自己的"></p><p>在你遇见一道有启发性的好题之后，可以将它按照考点放到案例库的对应专题里。用<strong>三种不同颜色的笔分别写下这道好题的题干、答案和你的收获、体会</strong>。（学长的习惯是分别使用黑色、红色、蓝色）</p><p>其中，题干不必全抄，只<strong>记录做题需要的部分</strong>即可。</p><p>而答案不能只抄参考答案，需要回到题目找到答案依据，并把答案整理成“<strong>知识/信息+采分点+题目回扣</strong>”的形式。最后，写下你从参考答案中学到的<strong>做题思路或心得体会</strong>就可以啦。</p><p>举个例子：</p><p><img src= "/img/loading.gif" data-lazy-src="https://ldbbs.ldmnq.com/bbs/topic/attachment/2023-2/84ab00f1-355f-4b08-9c0a-8c1e697aeeb1.png" alt=""></p><p>对于上面这道题，学长整理案例库时会先看题目的考点，很明显，这道题适合分类在自然地理的海洋水模块中。</p><p>之后学长会<strong>分析参考答案的角度</strong>。不难发现，第一个答案点在分析海水的温度，而第二个和第三个答案则在分析海水的盐度，最后一个答案点则是分析海水的运动。</p><p>总结一下，也就是将来做有关水体结冰问题时可以从水体温度、水体盐度、水体运动三个角度进行分析，这才是我们做这道题目的收获。</p><p>最后，我们将其整理到案例库中。就像下图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://ldbbs.ldmnq.com/bbs/topic/attachment/2023-2/e139ce52-6d9d-4d8f-a928-16eb12d81e09.png" alt=""></p><p>随着案例库中案例增多，我们也会见到更多的答题角度，总结出更多的答题方法。当案例积累到一定程度之后就可以对这类题目的做题思路和常见的答案点进行总结。就像下图这样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://ldbbs.ldmnq.com/bbs/topic/attachment/2023-2/3de9ac3a-0911-4b4f-8cbe-78899808d8ab.png" alt=""></p><p>这些总结的答案点可以来源于之前整理过的题目，也可以是自己对做过题目的思考和补充。这么做的目的在于将零散的知识点进行整合，以便于平时早读和考试前进行速记，避免二次出错。</p><hr><h1 id="如何利用案例库高效复习？"><a href="#如何利用案例库高效复习？" class="headerlink" title="如何利用案例库高效复习？"></a>如何利用案例库高效复习？</h1><p>复习案例库的重要时段有两个，一个是早读，一个是考试前。</p><p><strong>早读的重点在于背诵（理解的前提下记忆，切不可死记硬背）自己总结的常见答案点和思路，以扎实基础为主要目标</strong>。学长高中时会在题号旁边画“正”字来记录自己的复习的次数。</p><p>当看到题目能够脱口而出，行云流水般地说出所有答案点的大意之后，就会在题号前画下一个三角形，表示该处知识已经完全掌握，之后早读时就不会专门复习了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://ldbbs.ldmnq.com/bbs/topic/attachment/2023-2/97cd1c08-da5e-4cd2-8f2b-6d8e1fe91bee.png" alt="就像这样"></p><p><strong>考前的重点在于重看自己整理过的好题，以寻找题感为主要目标。</strong></p><p>大考之前，学长会从头到尾过一遍案例库，过的时候挡住案例下方的思路和答案，只留上方题目，在脑海中进行重做。这样可以在上考场之前迅速找到题感，从而达到考场有底，心中不慌的效果。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>案例库可以对知识点和做题思路进行分类，从而便于复习，并且可以加深对于题目的思考和理解。合理使用将有事半功倍的效果。</p><p>任何事情都是坚持之后才会看到希望，整理案例也不例外，唯有持之以恒的整理才是王道。希望读到最后的你能够坚持下来，一步一个脚印，攀登地理高山。案例库定会是你攀登路上最好的登山杖，为你的登顶之行保驾护航。</p><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 文化课专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文化课专栏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【项目开发】FJNU-ics online指北</title>
      <link href="2023/01/24/fjnu-ics2/"/>
      <url>2023/01/24/fjnu-ics2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p><a href="https://github.com/payphone-x/FJNU-ics">FJNU-ics</a> 为福建师范大学课表自动生成工具，可一键生成福建师范大学学生课表，支持一键导入日历，且对于各种日历均有良好的兼容性。</p><p>初版 FJNU-ics 需要于本地配置 Python 环境，且需要通过命令运行代码，对使用者有一定技术要求。故作者对原版本进行更新，升级为 FJNU-ics online。可在线生成福建师范大学学生课表。</p><p>相较于原版，FJNU-ics online 实现了于网页端生成课表并下载，降低了对使用者的技术要求，具有更好的便利性。</p><p><img src= "/img/loading.gif" data-lazy-src="\images\FJNU-ics-online.png" alt=""></p><hr><h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><p>该项目地址为<code>https://fjnu-ics.top</code>，或<a href="https://fjnu-ics.top/">点此</a>直接进入。</p><p>进入之后，需要在页面内完善四项信息。分别是学号，密码，学年与学期，该学期首个周一的日期。</p><ul><li>学号为你的完整学号，一般为<strong>12位阿拉伯数字</strong>，如：136152022005</li><li>密码为你的<strong>教务系统密码</strong></li><li>学年以前一数字进行记录，如2022-2023学年请选择2022；第一学期为秋冬季学期，第二学期为春夏季学期，第三学期为小学期。</li><li>该学期首个周一日期格式为 <code>年/月/日</code>，中间必须用英文斜杠<code>/</code>隔开，如<code>2023/2/13</code>。</li></ul><p>之后点击提交，程序将运行生成课表，并于浏览器中弹出提示。生成的 <code>calender.ics</code> 文件即为课表文件。</p><p><img src= "/img/loading.gif" data-lazy-src="\images\calendar.png" alt=""></p><hr><h1 id="导入日历"><a href="#导入日历" class="headerlink" title="导入日历"></a>导入日历</h1><p>请参考 <a href="https://album921.cc/2022/09/27/fjnu-ics/#%E5%AF%BC%E5%85%A5%E6%97%A5%E5%8E%86">FJNU-ics 使用指北</a> 的「导入日历」部分。</p><hr><h1 id="隐私政策与保护"><a href="#隐私政策与保护" class="headerlink" title="隐私政策与保护"></a>隐私政策与保护</h1><ul><li><p>由于 FJNU 不允许跨域请求，故所有请求均由服务器调用实现。这意味着你的密码会被传输至服务器，之后传输到 FJNU 服务器进行课表爬取。</p></li><li><p>我们保证，您的所有信息只会用于 ics 文件的生成，且不会在除您的设备外的任何地方以任何形式存储。</p></li><li><p>但请注意，您的数据在发送时并未经过任何加密，故请<strong>务必确保您的网络环境安全</strong>。</p></li><li><p>您在使用过程中所产生的一切后果，包括课表错误、网络劫持导致的数据泄漏等，均由您自身承担。</p></li></ul><p>使用此功能即代表您理解并同意上述条款。</p><p>另外，本项目使用过程中会强制注销您在教务系统的登录会话，<strong>再次进入教务系统时需要重新登陆</strong>，请知悉。</p><hr><h1 id="使用的第三方库"><a href="#使用的第三方库" class="headerlink" title="使用的第三方库"></a>使用的第三方库</h1><ul><li><a href="https://www.mdui.org/">MDUI</a></li><li><a href="https://fontawesome.dashgame.com/">FontAwesome</a></li><li><a href="https://www.baidu.com/s?tn=51076811_1_dg&amp;wd=jQuery">jQuery</a></li></ul><p>感谢上述开源第三方库对本项目的支持。</p><hr><h1 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h1><ul><li><p>于<a href="https://github.com/MoveToEx/FJNU-ics-Enhanced">本项目Github仓库</a>中提交 issue</p></li><li><p>telegram：<a href="https://t.me/MoveToEx">@MoveToEx</a>，<a href="https://t.me/album921">@Album.</a></p></li></ul><p>或在本站的 <a href="https://album921.cc/about/">About Me</a>页面中寻找更多的作者联系方式。</p><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【碎碎念】写于大挑放榜之日</title>
      <link href="2022/11/02/some-talk/"/>
      <url>2022/11/02/some-talk/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一觉醒来，大挑的结果出来了。</p><p>虽然早就做好了进不了复赛的准备，但当看到复赛作品里没有自己的论文，心里还是有些不好受。</p><p>或许，这也算是“意料之外，情理之中”吧。</p><p>最近福州总是下雨，让人提不起干劲。再加上疫情封闭，总感觉心里闷闷的，好像有什么东西压在上面。</p><p>明明自己上个月的时候还是干劲满满，早上6点的广播操训练，班里的一堆事情，机协的训练任务，大挑的论文准备都压不倒自己。但从封闭开始就什么都不想干，只想摸鱼。</p><p>忘了之前从哪里看到说”人是不能闲下来的”。但从现在一看，这也有一定道理。人是有惰性的，就好像牛顿第一定律一样，若没有外力的干预，谁也不会主动改变自己的生活状态。只会愈发颓废下去。</p><p>但回过头看，总感觉自己被外界的事情束缚的太紧，渐渐走偏了方向。中学时代选择 $\text{OI}$ 是单纯因为喜欢计算机，最后却沦为了追名逐利的工具。好不容易与自己和解，但却又被一个大挑打回原形。</p><p>我们都走的太远，以至于忘了为什么出发；我们都看名利太重，以至于看不见简单的快乐。</p><p>而往往，简单的快乐才是最珍贵的。</p><p>完成论文之后，用鼠标一遍遍的翻阅。看着每一个自己打出的字符，自己推出的式子，心里的满满的成就感。这快乐虽然简单，但却是千金不换。</p><p>天气预报上说后天福州将会放晴。看来，就算是阴雨绵绵的雨季，也不是一直下雨的。</p><p>今天下雨，明天下雨，或许后天就是晴天了呐。</p><p>日出东方，明日再战。等到红日初升之时，我们仍是打不倒的超级赛亚人。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img14.360buyimg.com/ddimg/jfs/t1/47596/9/17241/258191/63628cd7E9c2aa0bb/ef8d2cf2c0e92204.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【项目开发】FJNU-ics 使用指北</title>
      <link href="2022/09/27/fjnu-ics/"/>
      <url>2022/09/27/fjnu-ics/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>FJNU-ics 为福建师范大学课表自动生成工具，可一键生成福建师范大学学生课表，支持一键导入日历，且对于各种日历均有良好的兼容性。</p><p><img src= "/img/loading.gif" data-lazy-src="/images/preview.png" alt=""></p><hr><h1 id="项目功能"><a href="#项目功能" class="headerlink" title="项目功能"></a>项目功能</h1><ul><li><p>为你的课表生成跨平台可通用的<code>.ics</code>日历文件。可一键导入手机，平板电脑，笔记本电脑等移动设备，便于随时随地进行查看。</p></li><li><p>仅需提供个人学号和密码即可生成，方便快捷。</p></li></ul><hr><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><blockquote><p>由于本项目基于 <strong>Python 3</strong> 运行，故需要于 PC 端先配置 Python 3。建议使用 Python 3.7 以上版本。</p></blockquote><p>若你已经下载 Python 3 并添加至环境变量，请跳过该部分。</p><h3 id="Python-下载"><a href="#Python-下载" class="headerlink" title="Python 下载"></a>Python 下载</h3><p>打开 <a href="https://www.python.org/downloads/">Python 官网</a>，点击「Download Python X.XX.X」（即下图中用红色框起的部分），下载 Python</p><p><img src= "/img/loading.gif" data-lazy-src="/images/P1.png" alt=""></p><p>下载完成后，找到下载的文件，点击该文件，之后会出现如下界面</p><p><img src= "/img/loading.gif" data-lazy-src="/images/P1.1.png" alt=""></p><p><strong>勾选</strong> <code>Python X.XX to PATH</code>，（若不勾选需要手动添加环境变量）</p><p>勾选后，若你没有安装经验请选择<code>Install Now</code>进行一键安装，若想要自定义安装请选择<code>Customize installation</code>进行自定义安装（可自定义安装路径与安装项目）。</p><hr><h3 id="手动配置环境变量"><a href="#手动配置环境变量" class="headerlink" title="手动配置环境变量"></a>手动配置环境变量</h3><p>假若你在安装 Python 时没有勾选<code>Python X.XX to PATH</code>，请按照以下步骤配置环境变量。</p><p>同时按下键盘上的 windows 徽标键 与 r 键，出现运行窗口。输入 <code>control</code> 之后回车。</p><p>此时屏幕上会出现「控制面板」界面。在右上方的搜索框中输入<code>环境变量</code>之后，单击「编辑系统环境变量」（如下图）</p><p><img src= "/img/loading.gif" data-lazy-src="/images/P1.2.png" alt="image.png"></p><p>之后点击「环境变量」，进入以下界面：</p><p><img src= "/img/loading.gif" data-lazy-src="/images/P2.png" alt="image.png"></p><p>查看用户变量内是否有<code>Path</code>变量，若没有，则新建一个名为<code>Path</code>的变量并点开。若有，则直接点开。</p><p>点开后显示如下界面，请复制<code>Python</code>的安装位置，之后点击新建，将<code>python</code>与<code>python\Scripts</code>的文件路径复制到变量中</p><p><img src= "/img/loading.gif" data-lazy-src="/images/P3.png" alt="image.png"></p><p>完成后，在任意目录下使用终端输入<code>python</code>，若显示如下图所示，证明环境变量已经配置成功。</p><p><img src= "/img/loading.gif" data-lazy-src="/images/P4.png" alt=""></p><hr><h2 id="课表生成"><a href="#课表生成" class="headerlink" title="课表生成"></a>课表生成</h2><p>本项目发布于 Github，请在<a href="https://github.com/payphone-x/FJNU-ics">项目主页</a>处依次点击 「Code」 与 「Download Zip」下载所需要的文件。</p><p><img src= "/img/loading.gif" data-lazy-src="/images/P5.png" alt="image.png"></p><p>你的文件应包括以下部分：</p><p><img src= "/img/loading.gif" data-lazy-src="/images/P6.png" alt="image.png"></p><p>在项目目录中单击鼠标右键，选择「在终端中打开」，输入<code>pip install -r requirements.txt</code>，并等待下载完成。</p><p><img src= "/img/loading.gif" data-lazy-src="/images/P7.png" alt=""></p><p>之后回到项目目录，单击「main.py」，依次输入<code>uid</code>，<code>password</code>，<code>year</code>，<code>semester</code>四个信息。每输入一条需按一次回车</p><ul><li><code>uid</code> 为你的个人完整学号，<strong>应为 12 位数字</strong>（如：136152022005）</li><li><code>password</code> 为你的教务系统密码</li><li><code>year</code> 为要查询的学年（如2022-2023学年则输入2022）</li><li><code>semester</code> 为要查询的学期（可输入1/2/3）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="/images/P9.png" alt="image.png"></p><p>当所有信息输入后，程序将自动运行，于目录中生成一个<code>output.ics</code>文件。该文件即为你的课表文件。</p><hr><h1 id="导入日历"><a href="#导入日历" class="headerlink" title="导入日历"></a>导入日历</h1><p>请根据自己设备的不同选择适合自己的导入方式。</p><h2 id="Windows-设备"><a href="#Windows-设备" class="headerlink" title="Windows 设备"></a>Windows 设备</h2><p>单击生成的<code>output.ics</code>，点击左上角「导入到日历」即可 </p><p><img src= "/img/loading.gif" data-lazy-src="/images/P10.png" alt=""></p><hr><h2 id="Android-或-Harmony-OS-设备"><a href="#Android-或-Harmony-OS-设备" class="headerlink" title="Android 或 Harmony OS 设备"></a>Android 或 Harmony OS 设备</h2><p>使用微信，QQ，Telegram等常用聊天软件将<code>output.ics</code>传至设备中，之后在「打开方式」中选择「日历」，按照系统提示导入即可。</p><hr><h2 id="iOS-设备"><a href="#iOS-设备" class="headerlink" title="iOS 设备"></a>iOS 设备</h2><p>iOS设备的导入方式较为繁琐，本人曾使用两种方式成功导入，供参考。</p><p>以下方法的本质均为使用Safari浏览器打开ics文件。</p><p>请注意，不管使用那种方式都<strong>一定要进行最后一步操作，不要直接点击「完成」</strong>，否则万一出错删除会十分麻烦</p><h3 id="方法1：使用NodeJS"><a href="#方法1：使用NodeJS" class="headerlink" title="方法1：使用NodeJS"></a>方法1：使用NodeJS</h3><p>该方法<strong>建议有一定开发基础的同学使用</strong>，若你从未接触过开发，请尝试方法2或方法3。</p><ol><li><p>安装 <a href="https://nodejs.org">NodeJS</a></p></li><li><p>在任一目录下运行<code>npm install http-server --global</code></p></li><li><p>在<code>output.ics</code>文件所在目录运行<code>http-server</code></p></li><li><p>使用Safari浏览器打开终端中显示的网址，通常形式为<code>http://*.*.*.*:*</code>，其中<code>*</code>为通配符</p></li><li><p>在页面中找到<code>.ics</code>文件，点击打开，单击右上角「添加全部」。</p></li><li><p><strong>这点十分重要！！！</strong> 请点击右下角「添加日历」，输入日历名称并选中，之后点击「完成」。</p></li></ol><hr><h3 id="方法2：使用Everything"><a href="#方法2：使用Everything" class="headerlink" title="方法2：使用Everything"></a>方法2：使用Everything</h3><p>本方法借助 Everything 自带的 HTTP 文件服务器实现</p><ol><li><p>安装 <a href="https://www.voidtools.com/zh-cn/">Everything</a></p></li><li><p>右键任务栏「Everything」图标，点击选项。</p></li><li><p>左侧点击 「HTTP」 服务器，之后点击「启用HTTP服务器」。</p></li><li><p>使用iOS设备访问当前设备IP (形式为<code>http://*.*.*.*</code>，其中<code>*</code>为通配符)，找到生成的<code>.ics</code>文件并点击打开，单击右上角「添加全部」</p></li><li><p><strong>这点十分重要！！！</strong> 请点击右下角「添加日历」，输入日历名称并选中，之后点击「完成」。</p></li></ol><hr><h3 id="方法3：使用在线传输网址"><a href="#方法3：使用在线传输网址" class="headerlink" title="方法3：使用在线传输网址"></a>方法3：使用在线传输网址</h3><p>以<a href="https://cowtransfer.com/">奶牛快传</a>为例。</p><ol><li><p>将 ics 文件传至奶牛快传。</p></li><li><p>此时奶牛快传将会给出文件链接和提取码，点击「Copy both」进行复制，并通过QQ，微信等社交软件传至 iOS 设备。</p></li><li><p>将文件链接复制到 Safari 浏览器中，输入提取码，点击「下载」。</p></li><li><p>此时系统会自动弹出日程，单击右上角「添加全部」。</p></li><li><p><strong>这点十分重要！！！</strong> 请点击右下角「添加日历」，输入日历名称并选中，之后点击「完成」。</p></li></ol><hr><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="关于仓山校区"><a href="#关于仓山校区" class="headerlink" title="关于仓山校区"></a>关于仓山校区</h2><p>开发者在课表后端返回数据中发现了指示校区的部分，目前已经实现根据校区的不同自动调整时间。</p><hr><h2 id="关于不同学期"><a href="#关于不同学期" class="headerlink" title="关于不同学期"></a>关于不同学期</h2><p>本项目于 2022 年 9 月 26 日首次上传，故默认适配学期为 2022-2023 学年上半学期。</p><p>若需要在其他学期使用，请打开<code>main.py</code>，将<code>current_time</code> 一行中最后的数字改为当前学期第一周周一的日期，格式为<code>(年, 月, 日)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">current_time = datetime.datetime(<span class="number">2022</span>, <span class="number">8</span>, <span class="number">29</span>) </span><br><span class="line"><span class="comment">#该学期为 2022-2023 学年上半学期，第一周周一为 2022 年 8 月 29 日</span></span><br></pre></td></tr></table></figure><hr><h2 id="关于其他学校"><a href="#关于其他学校" class="headerlink" title="关于其他学校"></a>关于其他学校</h2><p>若你非福建师范大学或重庆邮电大学学生，且想要基于本项目开发自己学校的课表，请阅读<a href="https://github.com/payphone-x/FJNU-ics/blob/main/doc/custom_interface.md">自定义接口</a></p><hr><h1 id="隐私政策与保护"><a href="#隐私政策与保护" class="headerlink" title="隐私政策与保护"></a>隐私政策与保护</h1><ul><li><p>程序运行过程中，需要收集您在<code>jwglxt.fjnu.edu.cn</code>域下的cookies，以模拟用户登录并获取请求结果。</p></li><li><p>我们保证您的cookies只会用于 ics 文件的生成，且不会在除您的设备外的任何地方以任何形式存储。</p></li><li><p>我们只保证本 repo 中的文件遵守以上规则，若您得到的文件与本 repo 中文件不完全一致，则您需要自行承担可能的风险与后果。</p></li></ul><p>使用此程序即代表您了解并同意上述条件。</p><hr><h1 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h1><ul><li><p>于<a href="https://github.com/payphone-x/FJNU-ics/">本项目Github仓库</a>中提交 issue</p></li><li><p>telegram：<a href="https://t.me/MoveToEx">@MoveToEx</a>，<a href="https://t.me/album921">@Album.</a></p></li></ul><p>或在本站的 <a href="https://album921.cc/about/">About Me</a>页面中寻找更多的作者联系方式。</p><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【成长之路】再见，高三</title>
      <link href="2022/09/07/back/"/>
      <url>2022/09/07/back/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=750 height=86 src="//music.163.com/outchain/player?type=2&id=440355687&auto=1&height=66"></iframe><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>9月7日，星期三。距离大学的报道日期，还有两天。</p><p>闲来无事在网上翻阅别人的博客，看着一篇又一篇的游记，心中感慨万千。</p><p>好多人都以各种方式记录下来了自己生命中的重要时刻与感受，但自己却总以忙为借口不愿记录，甚至找小时候的照片都找不到几张。翻阅自己曾经的博文，也大都是一些题解报告之类，真正记录性质的文章，少之又少。</p><p>很快，这些感受会被自己忘记，它们中的少部分或许会在某个时刻被某个记号被唤醒，但大部分都将消逝在记忆的长河之中，再也不见。</p><p>我想，如果写下些什么做个记号，即便只有寥寥数言，或许也能在将来忘记的时候，顺着这个记号，重新找回这个时刻的感受。</p><p>于是乎，就有了这篇流水账。</p><hr><h2 id="紧张的一轮复习"><a href="#紧张的一轮复习" class="headerlink" title="紧张的一轮复习"></a>紧张的一轮复习</h2><p>9月1日，星期三。那天，是高三开学的日子。</p><p>如果说高考是高三的决战，那么一轮复习应该算是高三的前哨战吧。但即使是前哨战，也能从中看到了竞争的残酷与无情。</p><p>看着自己不尽人意的成绩和曾经属于自己的排名被别人取代，我的不禁有些心寒。也许，这就是竞赛停课的代价吧。</p><p>但转机发生在期中考试。当我打开查分页面时，97分的地理单科赋分映入我的眼帘，让我感到了一丝丝的惊喜。</p><p>一轮复习的后半段开始变得轻松，一方面是因为受停课的影响在逐渐变小，另一方面也是因为心态使然。到最后的期末考试，我反而考出了之前想都不敢想的成绩。</p><p>或许，这就是相信的力量吧。</p><hr><h2 id="疫情下的备考生活"><a href="#疫情下的备考生活" class="headerlink" title="疫情下的备考生活"></a>疫情下的备考生活</h2><p>3月17日，星期四。那天，是学校封校的日子。</p><p>由于确诊病例的不断增加，高一高二全部放假，只留下了高三学生在校上课。</p><p>高三下学期无休无止的考试本就心烦，突如其来的封闭更是让人束手无策。封闭初期我整个人都不在状态，总是想着什么时候能够回家。但自己一点点提升的成绩却又给了自己一丝丝的安慰。</p><p>但到了后期也逐渐习惯了这样的生活。再加上当时每周都有将要解封的消息传来，久而久之也就略微麻木了。以至于真正解封的时候反而没有多么激动。</p><p>那段时间的具体生活我已经记不清了，但还记得在地理组吃到的零食和烤鸭。也许是因为这是封校生活中的唯一一点慰藉吧。</p><p>解封之后就到了高考的最后冲刺阶段，但与其他人不同的是，我的心态反而平静了下来。拿手的科目早已十拿九稳，不拿手的科目也没什么提升空间了。唯一担心的是自己的综招和强基，不知道初审能否通过。</p><p>但事实证明担心是多余的。大约高考前一周，我打开邮箱，发现华南理工大学，香港中文大学（深圳），哈尔滨工业大学（威海）都给我发送了初审通过的邮件。那一刻，我觉得自己的努力是值得的。</p><hr><h2 id="六月是你的高考"><a href="#六月是你的高考" class="headerlink" title="六月是你的高考"></a>六月是你的高考</h2><p>6月7日，星期二。那天，我走上了高考考场。</p><p>说不紧张是不可能的，但也没有多紧张，毕竟我的一二三模成绩都在不断进步。考前也做好了充分的预案，只要一切正常就能去个不错的学校。</p><p>第一场语文发下答题卡是就感觉有些不妙，看到从来没有的三个空让我脑子一懵，发下卷子之后看到手填成语的语用和 <code>本手，妙手，俗手</code> 的作文更是感到无从下手，只好尽力把答题卡写满。</p><p>但下午的数学才是真正的噩梦，当做到第4题就被卡壳时我就已经感到了不对，后面的6道大题更是没有一道有底。当收卷铃声打响的那一刻，我和对面的同班同学交换了一个眼神，从对方的眼神里我看到了深深的无奈与绝望。</p><p>那天下午，我和母亲一同在河边聊了很久，聊了很多复读和出国的话题。母亲的一句“不管怎样我们都支持你”让我找到了底。</p><p>或许是因为抱着破釜沉舟的心情，后面的几场考试倒是正常发挥，虽然物理化学各都有一道大题没怎么做，但考虑到山东卷的难度也觉得正常。</p><p>当地理的收卷铃声打响，我知道，我的高中，结束了。</p><p>是啊，没有想象中的书本碎片，也没有幻想中的泪如雨下，甚至在回校拿书时遇到喜欢的姑娘也只是轻轻一笑便走了过去。</p><p>也许还有很多的遗憾吧，但也没什么可后悔的。</p><hr><h2 id="综招与强基的遗憾"><a href="#综招与强基的遗憾" class="headerlink" title="综招与强基的遗憾"></a>综招与强基的遗憾</h2><p>6月14日，星期二。那天，我参加了香港中文大学（深圳）的综合评价测试。</p><p>测试的大部分题目早已记不清了，唯一记得的便是中文写作时的“大智”与“大勇”的辩证关系。但当看到公布的合格名单里有自己的名字时，一种甜甜的感觉不禁涌上心头。</p><p>后来又去了华南理工大学和哈尔滨工业大学（威海），两场面试都很顺利，都拿到了入围的资格。</p><p>但当高考成绩公布那日，我的心中便凉了半截。自己的数学成绩比平时少了接近50分。虽然早已料到可能会是这个结果，但不争气的眼泪还是在眼眶中打转。</p><p>提前批填报志愿时，虽然已经知道几乎不可能，但还是头铁填上了哈尔滨工业大学（威海）的志愿。但可惜并没有想象中的奇迹。</p><p>之后便是紧张的志愿填报。期间也是不停的反复斟酌，即使完成之后还是有些紧张焦虑，不知自己会去向何方。直到模拟投档线公布之后我才安下心来。</p><p>那几天里，我也渐渐地与自己和解。虽然自己的竞赛经历并没有给自己带来世俗意义上的价值，但每当我翻起博客，看着OJ上的提交记录，我便能想起那段干净，纯粹，那段为了梦想和热爱不断拼搏的日子。</p><p>这就够了。</p><hr><h2 id="通向未来的通知书"><a href="#通向未来的通知书" class="headerlink" title="通向未来的通知书"></a>通向未来的通知书</h2><p>8月1日，星期一。那天，是我收到录取通知书的日子。</p><p>收到通知书的那天上午还在辅导班打工，当我给台下的学弟学妹们讲课时，一通陌生的电话打来。</p><p>“你好，是xxx吗，你的录取通知书到了，请带着你的身份证和准考证过来签收……”</p><p>看着火红的通知书，回忆起高中三年的点点滴滴：外出集训时的期待，打 <code>Codeforces</code> 时的不眠，补文化课时的紧张，封闭在校时的盼望，进步时的喜悦，退步时的不甘，高考前的平静，面试时的沉稳……</p><p>而这一切，都已成为我对过往亲切的怀恋。</p><p>同时，我也开始畅想自己的大学生活。若我能在之后的四年里，做好自己喜爱的事，做些能够造福大家的事，我的大学生活就是有意义的。</p><p>故此，我拿起桌上的笔，写下八个字，贴到了录取通知书的盒子上。</p><p>“物象千万，山高水长。”</p><hr><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>正如引子中所说的，接近一年的回忆写出来，也不过只有寥寥数言。</p><p>本以为自己的故事一定能打动他人，但写出之后才发现，只有自己能够懂得当时的感受。</p><p>而这个感受，或许就是这篇流水账的意义所在。</p><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 成长之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长之路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JOI2017 Final】JOIOI 王国-题解</title>
      <link href="2020/11/29/loj2334/"/>
      <url>2020/11/29/loj2334/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>JOIOI 王国是一个 $H$ 行 $W$ 列的长方形网格，每个 $1 \times 1$ 的子网格都是一个正方形的小区块。为了提高管理效率，我们决定把整个国家划分成两个省 JOI 和 IOI。</p><p>我们定义，两个同省的区块互相连接，意为从一个区块出发，不用穿过任何一个不同省的区块，就可以移动到另一个区块。有公共边的区块间可以任意移动。</p><p>我们不希望划分得过于复杂，因此划分方案需满足以下条件：</p><ul><li>区块不能被分割为两半，一半属 JOI 省，一半属 IOI 省。</li><li>每个省必须包含至少一个区块，每个区块也必须属于且只属于其中一个省。</li><li>同省的任意两个小区块互相连接。对于每一行/列，如果我们将这一行/列单独取出，这一行/列里同省的任意两个区块互相连接。这一行/列内的所有区块可以全部属于一个省。</li></ul><p>现给出所有区块的海拔，第 $i$ 行第 $j$ 列的区块的海拔为 $A_{i,j}$。</p><p>设 JOI 省内各区块海拔的极差（最大值减去最小值）为 $ R<em>{JOI} $ ，IOI 省内各区块海拔的极差为 $ R</em>{IOI} $。</p><p>在划分后，省内的交流有望更加活跃。但如果两个区块的海拔差太大，两地间的交通会很不方便。 因此，理想的划分方案是 $max(R<em>{JOI},R</em>{IOI})$ 尽可能小。而你的任务是求出这个最小值。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，两个整数 $H,W$ ，用空格分隔。</p><p>在接下来的 $H$ 行中，第 $i$ 行有 $W$ 个整数 $A<em>{i,1},A</em>{i,2}, \cdots ,A_{i,W}$ ，用空格分隔。</p><p>输入的所有数的含义见题目描述。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，一个整数，表示 $max(R<em>{JOI},R</em>{IOI})$ 可能的最小值。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 12 6 11</span><br><span class="line">11 10 2 14</span><br><span class="line">10 1 9 20</span><br><span class="line">4 17 19 10</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $15\%$ 的数据， $H,W \leqslant 10$。</p><p>对于另外 $45\%$ 的数据， $H,W \leqslant 200$。</p><p>对于所有数据， $2 \leqslant H,W \leqslant 2000,A_{i,j} \leqslant 10^9 , 1 \leqslant i \leqslant H,1 \leqslant j \leqslant W$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目中提到<strong>最大值最小，明示二分答案</strong>。</p><p>考虑怎么书写 $\text{check}$ 函数？重新读一下题，不难发现能推出以下几条特性：</p><ol><li>划分的边界一定是<strong>阶梯状</strong>的。</li><li>一个区域中<strong>包含的点越少，其可能的极差越小</strong>。</li><li>整个矩阵的<strong>最大值 &amp; 最小值一定在分别两个区域中</strong>。</li></ol><p>其中性质 $2$ 的感性理解是考虑在一个区域中加一个点，其极差可能不变或变大，故点数越少其可能的极差越小。</p><p>故二分极差 $x$ ，且强行钦定最大值在区间 $\text{A}$ 中，这样就可以得到区间 $\text{A}$ 能取的最小值。接着把不会影响到极差的值全部加入到区间 $\text{A}$，以方便之后对剩下区间进行处理。</p><p>根据性质 $3$，剩下的区域一定有区间最小值。设其为区间 $\text{B}$，则我们可以根据二分出的极差求区间 $\text{B}$ 能取的最大值。之后暴力扫一遍区域 $\text{B}$ 中有没有比这个最大值大的元素即可。</p><p>还有一个细节就是阶梯状的边界可能是从左下到右上，右下到左上，右上到左下，左上到右下四种情况，分开 $\text{check}$ 的话比较麻烦，故可以在 $\text{check}$ 出一种情况之后翻转 $90°$ 再次 $\text{check}$，在四种情况中取最优的。</p><p>时间复杂度 $O(n^2 \log n)$。足以通过本题</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line">ll s[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line">ll maxn = <span class="number">-0x3f3f3f3f</span> , minn = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> poi = m + <span class="number">1</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , n) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        rep(j , <span class="number">1</span> , min(poi , m)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxn - s[i][j] &lt;= x) t = max(t , j);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        poi = t;</span><br><span class="line">        rep(j , t + <span class="number">1</span> , m) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] - minn &gt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll l = <span class="number">0</span> , r = maxn - minn;</span><br><span class="line">    <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(check(l)) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrunR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i , <span class="number">1</span> , n) &#123;</span><br><span class="line">        rep(j , <span class="number">1</span> , m / <span class="number">2</span>) &#123;</span><br><span class="line">            swap(s[i][j] , s[i][m - j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrunL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i , <span class="number">1</span> , n / <span class="number">2</span>) &#123;</span><br><span class="line">        rep(j , <span class="number">1</span> , m) &#123;</span><br><span class="line">            swap(s[i][j] , s[n - i + <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;joioi.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;joioi.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n) , read(m);</span><br><span class="line">    rep(i , <span class="number">1</span> , n) &#123;</span><br><span class="line">        rep(j , <span class="number">1</span> , m) &#123;</span><br><span class="line">            read(s[i][j]);</span><br><span class="line">            maxn = max(maxn , s[i][j]);</span><br><span class="line">            minn = min(minn , s[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    ans = min(ans , solve()) , TrunR();</span><br><span class="line">    ans = min(ans , solve()) , TrunL();</span><br><span class="line">    ans = min(ans , solve()) , TrunR();</span><br><span class="line">    ans = min(ans , solve());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 多校联考 </tag>
            
            <tag> 二分 </tag>
            
            <tag> JOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JOI2017 Final】准高速电车-题解</title>
      <link href="2020/11/29/loj2333/"/>
      <url>2020/11/29/loj2333/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>JOI 铁路公司是 JOI 国唯一的铁路公司。</p><p>在某条铁路沿线共有 $N$ 座车站，依次编号为 $1\ldots N$。 目前，正在服役的车次按照运行速度可分为两类：高速电车（简称快车）与普通电车（简称慢车）。</p><ul><li><p>慢车每站都停。乘慢车时，对于任意一座车站 $i(1\leqslant i&lt;N)$，车站 $i$ 到车站 $i+1$ 用时均为 $A$。</p></li><li><p>快车只在车站 $S_1, S_2, \ldots, S_M$ 停车 $(1=S_1&lt;S_2&lt;\cdots&lt;S_M=N)$。</p></li></ul><p>乘快车时，对于任意一座车站 $i(1\leqslant i&lt;N)$，车站 $i$ 到车站 $i+1$ 用时均为 $B$。</p><p>JOI 铁路公司现拟开设第三类车次：准高速电车（简称准快车）。乘准快车时，对于任意一座车站 $i(1\leqslant i&lt;N)$，车站 $i$ 到车站 $i+1$ 用时均为 $C$。准快车的停站点尚未确定，但满足以下条件：</p><ul><li>快车在哪些站停车，准快车就得在哪些站停车。</li><li>准快车必须恰好有 $K$ 个停站点。</li></ul><p>JOI 铁路公司希望，在 $T$ 分钟内（不含换乘时间），车站 $1$ 可以抵达的车站（不含车站 $1$）的数量尽可能多。但是，「后经过的车站的编号」必须比「先经过的车站的编号」大。</p><p>求出在 $T$ 分钟内，可抵达车站的最大数目。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有三个整数 $N, M, K$，用空格分隔。</p><p>第二行有三个整数 $A, B, C$，用空格分隔。</p><p>第三行有一个整数 $T$。</p><p>在接下来的 $M$ 行中，第 $i$ 行有一个整数 $S_i$。</p><p>输入的所有数的含义见题目描述。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，一个整数，表示在 $T$ 分钟内，可抵达车站的最大数目。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">10 3 5</span><br><span class="line">10 3 5</span><br><span class="line">30</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $30\%$ 的数据，$N\leqslant 300, K-M=2, A\leqslant 10^6, T\leqslant 10^9$。</p><p>对于另外 $40\%$ 的数据，$N\leqslant 300$。</p><p>对于所有数据，$1\leqslant N\leqslant 10^9, 2\leqslant M\leqslant K\leqslant 3000, K\leqslant N, 1\leqslant B&lt;C&lt;A\leqslant 10^9, 1\leqslant T\leqslant 10^{18}, 1=S_1&lt;S_2&lt;\cdots&lt;S_M=N$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>比较好想的贪心，但不太好写。</p><p>对于一个位置，我们到达它必定是<code>快车</code> -&gt; <code>准快车</code> -&gt; <code>慢车</code>，其中三段都可以为空。</p><p>而题目中给出的快车点刚好将总路程分成了 $m$ 段以快车开头的路程，故可以单独对每一段路程进行思考。</p><p>考虑什么情况下我们会在该位置设立准快车站？</p><p>显然，在坐慢车 $T$ 时刻内能到的点设立准快车站对答案没有贡献。而节省的时间越多对后面越有利。</p><p>故我们在坐慢车能到的下一个点放置准快车站，之后重复上述过程即可。</p><p>时间复杂度为 $O(km)$。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n , m , K;</span><br><span class="line">ll A , B , C;</span><br><span class="line">ll T , S[<span class="number">5005</span>] , Z[<span class="number">5005</span>] , cnt , ans;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;car.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;car.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n) , read(m) , read(K);</span><br><span class="line">    read(A) , read(B) , read(C);</span><br><span class="line">    read(T);</span><br><span class="line">    rep(i , <span class="number">1</span> , m) read(S[i]);</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; Z;</span><br><span class="line">    rep(i , <span class="number">2</span> , m) &#123;</span><br><span class="line">        ll tim = (S[i - <span class="number">1</span>] - <span class="number">1</span>) * B;</span><br><span class="line">        <span class="keyword">if</span>(tim &gt; T) <span class="keyword">break</span>;</span><br><span class="line">        ll dis = (T - tim) / A;</span><br><span class="line">        ans += min(S[i] - S[i - <span class="number">1</span>] - <span class="number">1</span> , dis);</span><br><span class="line">        <span class="keyword">if</span>(dis &gt; S[i] - S[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        ll  pla = S[i - <span class="number">1</span>] + min(S[i] - S[i - <span class="number">1</span>] - <span class="number">1</span> , (T - tim) / C) , tims = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p = S[i - <span class="number">1</span>] + dis + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p &lt;= pla) &#123;</span><br><span class="line">            ll tmp = (T - tim - (p - S[i - <span class="number">1</span>]) * C) / A;</span><br><span class="line">            tmp = min(tmp , S[i] - p - <span class="number">1</span>);</span><br><span class="line">            Z.pb(tmp + <span class="number">1</span>);</span><br><span class="line">            p += tmp + <span class="number">1</span>;</span><br><span class="line">            tims ++;</span><br><span class="line">            <span class="keyword">if</span>(tims + m &gt;= K) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i , <span class="number">2</span> , m) &#123;</span><br><span class="line">        <span class="keyword">if</span>((S[i] - <span class="number">1</span>) * B &lt;= T) ans ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Z.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans) , <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sort(all(Z));</span><br><span class="line">        per(i , (<span class="keyword">int</span>)Z.size() - <span class="number">1</span> , <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(K &gt; m) K -- , ans += Z[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 多校联考 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> JOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JOI2019 Final】硬币收藏-题解</title>
      <link href="2020/11/27/loj3013/"/>
      <url>2020/11/27/loj3013/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>JOI 先生的收藏室里有一张巨大的桌子，上面有许多稀有的硬币。为了清理桌子，他要重新摆放硬币。</p><p>桌面可视为 $(2\times 10^9+1)\times (2\times 10^9+1)$ 的网格。JOI 先生有 $2N$ 枚硬币。初始时，第 $i$ 枚 $(1\le i\le 2N)$ 硬币被放在坐标为 $(X_i,Y_i)$ 的格子里。</p><p>JOI 先生的目标是在每个满足 $1\le x \le N,1\le y\le 2$ 的格子 $(x,y)$ 上恰好放一枚硬币。为了不损坏硬币，他能做的唯一一个操作是钦定一枚硬币然后将其移动到相邻的一个格子中（我们说两个格子相邻，当且仅当这两个格子有公共边）。</p><p>在移动硬币的过程中，允许两个硬币处在同一个格子中。JOI 先生希望通过尽量少的操作次数完成目标。</p><p>现在给出硬币的数量和初始时所在的位置，编写一个程序，计算完成 JOI 先生目标所需的最少操作次数。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $N$。</p><p>接下来 $2N$ 行，第 $i$ 行为两个整数 $X_i$ 和 $Y_i$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数，表示完成目标所需的最少操作次数。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 0</span><br><span class="line">0 4</span><br><span class="line">4 0</span><br><span class="line">2 1</span><br><span class="line">2 5</span><br><span class="line">-1 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">3 1</span><br><span class="line">3 1</span><br><span class="line">3 1</span><br><span class="line">3 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-3"><a href="#Input-‘s-eg-3" class="headerlink" title="Input ‘s eg 3"></a>Input ‘s eg 3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1000000000 1000000000</span><br><span class="line">-1000000000 1000000000</span><br><span class="line">-1000000000 -1000000000</span><br><span class="line">1000000000 -1000000000</span><br><span class="line">-1 -5</span><br><span class="line">-2 2</span><br><span class="line">2 8</span><br><span class="line">4 7</span><br><span class="line">-2 5</span><br><span class="line">7 3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-3"><a href="#Output-‘s-eg-3" class="headerlink" title="Output ‘s eg 3"></a>Output ‘s eg 3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8000000029</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $100\%$ 的数据，$1 \leq N \leq 10^5,-10^9\le X_i,Y_i\le 10^9$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先考虑矩形范围只有一行时候怎么做。</p><p>显然，只有一行的时候就把所有的硬币以最短路径移动到该行中，然后扫一遍就行了。</p><p>之后考虑两行的时候有什么不同？</p><p>两行时显然我们还要把每个硬币以最短路径移动到矩形中，移动之后可能会出现某些格子里没有硬币，而某些格子里硬币很多的状况。</p><p>开一个桶 $cnt[i][1/2]$ 表示第 $1/2$ 行的第 $i$ 列还需要多少硬币，之后从前往后扫一遍。</p><p>若出现两行中同一列的 $cnt$ 一正一副，则移动至其中一行为 $0$ ，否则将多余的硬币分给下一列即可。</p><p>时间复杂度为 $O(n)$</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n , x[M] , y[M];</span><br><span class="line">ll cnt[M][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">ll res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;c.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;c.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n);</span><br><span class="line">    rep(i , <span class="number">1</span> , <span class="number">2</span> * n) &#123;</span><br><span class="line">        read(x[i]) , read(y[i]);</span><br><span class="line">        <span class="keyword">if</span>(x[i] &lt; <span class="number">1</span>) res += (ll)<span class="built_in">abs</span>(<span class="number">1</span> - x[i]) , x[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[i] &gt; n) res += (ll)<span class="built_in">abs</span>(x[i] - n) , x[i] = n;</span><br><span class="line">        <span class="keyword">if</span>(y[i] &lt; <span class="number">1</span>) res += (ll)<span class="built_in">abs</span>(<span class="number">1</span> - y[i]) , y[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y[i] &gt; <span class="number">2</span>) res += (ll)<span class="built_in">abs</span>(y[i] - <span class="number">2</span>) , y[i] = <span class="number">2</span>;</span><br><span class="line">        cnt[x[i]][y[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll l1 = <span class="number">0</span> , l2 = <span class="number">0</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , n) &#123;</span><br><span class="line">        l1 += cnt[i][<span class="number">1</span>] - <span class="number">1</span> , l2 += cnt[i][<span class="number">2</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt; <span class="number">0</span> &amp;&amp; l2 &gt; <span class="number">0</span>) ++ l1 , -- l2 , ++ res;</span><br><span class="line">        <span class="keyword">while</span>(l2 &lt; <span class="number">0</span> &amp;&amp; l1 &gt; <span class="number">0</span>) ++ l2 , -- l1 , ++ res;</span><br><span class="line">        res += <span class="built_in">abs</span>(l1) + <span class="built_in">abs</span>(l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 多校联考 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> JOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JOI2019 Final】有趣的家庭菜园3</title>
      <link href="2020/11/27/loj3012/"/>
      <url>2020/11/27/loj3012/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>家庭菜园专家 JOI 先生在他的家庭菜园中种植了一种叫 Joy 草的植物。在他的菜园里，有 $n$ 个花盆自东向西摆放，编号分别为 。每个花盆中有一株 Joy 草。</p><p>春天到了，JOI 先生注意到 Joy 草如他期望地长出了各种颜色的叶子，但他也发现 Joy 草的生长速度没有他期望的那么快。他查阅了书籍，找到了草的以下特点：</p><ul><li>Joy 草有三种品种，分别会长出红色、绿色和黄色的叶子。</li><li>如果两株同一颜色的 Joy 草紧密相邻，它们的生长速度就会减慢。</li></ul><p>因此，JOI 先生决定重新摆放花盆，使得没有两株相邻的 Joy 草颜色相同。</p><p>花盆非常沉重，因此 JOI 先生每次只能交换相邻的两个花盆。形式化的说，JOI 先生每次操作可以选择一个 $i$，然后交换花盆 $i$ 和花盆 $i + 1$。</p><p>请编写一个程序，计算最少的交换次数。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $N$。</p><p>接下来一行一个长度为 $N$ 的字符串 ，每个字符为 <code>R,G,Y</code> 中的一个，表示 Joy 草的颜色。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数，表示完成目标所需的最少操作次数。如果无解，输出 <code>-1</code>。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">RRGYY</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">RRRRRG</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-3"><a href="#Input-‘s-eg-3" class="headerlink" title="Input ‘s eg 3"></a>Input ‘s eg 3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">20</span><br><span class="line">YYGYYYGGGGRGYYGRGRYG</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-3"><a href="#Output-‘s-eg-3" class="headerlink" title="Output ‘s eg 3"></a>Output ‘s eg 3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $5\%$ 的数据，$0 \leq N \leq 15$。</p><p>对于 $60\%$ 的数据，$0 \leq N \leq 60$。</p><p>另有 $15\%$ 的数据，字符串仅包含 <code>R,G</code>。</p><p>对于 $100\%$ 的数据，$0 \leq N \leq 400$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看到 $n \leq 400$ 的数据范围很容易猜到高维 $\text{dp}$。</p><p>将三种颜色分别换成 $0 / 1 / 2$，则可以设 $f[i][j][k][0 / 1 / 2]$ 表示当前有 $i$ 个颜色0，$j$ 个颜色1，$k$ 个颜色2的最小交换次数。</p><p>显然，每一个状态都可以从上一个状态转移过来，例如：</p><script type="math/tex; mode=display">f[i][j][k][0] = f[i - 1][j][k][0/1/2] + cost</script><p>其他的都同理。</p><p>考虑如何快速计算 $cost$，设 $p[0 / 1 / 2][i]$ 表示颜色 $0 / 1 / 2$ 在序列中出现的第 $i$ 次的位置，$g[A][B][i][j] (A,B \in \lbrack 0 , 2 \rbrack)$ 为第 $i$ 个颜色 $A$ 的后边有前 $j$ 个颜色 $B$ 中的多少个颜色 $B$ 出现。则有： </p><script type="math/tex; mode=display">g[A][B][i][j] = g[A][B][i][j - 1] + (p[A][i] < p[B][j])</script><p>而颜色 $A$ 转移的贡献为除颜色 $A$ 以外的另外两种颜色的 $g$ 值之和。可以在预处理 $g$ 数组后直接进行查询。</p><p>预处理复杂度为 $O(n^2)$，总时间复杂度为 $O(n^3)$，可以通过本题。</p><p>细节部分详见代码。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">405</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , s[M] , pla[<span class="number">3</span>][M] , tot[<span class="number">3</span>]; </span><br><span class="line"><span class="keyword">char</span> str[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">3</span>][<span class="number">3</span>][M][M] , f[M][M][M][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cost</span><span class="params">(<span class="keyword">int</span> col , <span class="keyword">int</span> x , <span class="keyword">int</span> y , <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span> , tp = <span class="number">0</span>;</span><br><span class="line">    rep(i , <span class="number">0</span> , <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != col) &#123;</span><br><span class="line">            tp ++;</span><br><span class="line">            <span class="keyword">if</span>(tp &amp; <span class="number">1</span>) res += g[col][i][x][y];</span><br><span class="line">            <span class="keyword">else</span> res += g[col][i][x][z];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;x , <span class="keyword">int</span> y)</span> </span>&#123; x = min(x , y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;b.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;b.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span> , str + <span class="number">1</span>);</span><br><span class="line">    rep(i , <span class="number">1</span> , n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;R&#x27;</span>) s[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;G&#x27;</span>) s[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;Y&#x27;</span>) s[i] = <span class="number">2</span>;</span><br><span class="line">        pla[s[i]][++ tot[s[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(op , <span class="number">0</span> , <span class="number">2</span>) &#123;</span><br><span class="line">        rep(op2 , <span class="number">0</span> , <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(op == op2) <span class="keyword">continue</span>;</span><br><span class="line">            rep(i , <span class="number">1</span> , tot[op])&#123;</span><br><span class="line">                rep(j , <span class="number">1</span> , tot[op2]) &#123;</span><br><span class="line">                    g[op][op2][i][j] = g[op][op2][i][j - <span class="number">1</span>] + (pla[op][i] &lt; pla[op2][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clean(f , <span class="number">0x3f</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    rep(i , <span class="number">0</span> , <span class="number">2</span>) f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    rep(i , <span class="number">0</span> , tot[<span class="number">0</span>]) &#123;</span><br><span class="line">        rep(j , <span class="number">0</span> , tot[<span class="number">1</span>]) &#123;</span><br><span class="line">            rep(k , <span class="number">0</span> , tot[<span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i) rep(sta , <span class="number">0</span> , <span class="number">2</span>) <span class="keyword">if</span>(sta != <span class="number">0</span>) upd(f[i][j][k][<span class="number">0</span>] , f[i - <span class="number">1</span>][j][k][sta] + cost(<span class="number">0</span> , i , j , k));</span><br><span class="line">                <span class="keyword">if</span>(j) rep(sta , <span class="number">0</span> , <span class="number">2</span>) <span class="keyword">if</span>(sta != <span class="number">1</span>) upd(f[i][j][k][<span class="number">1</span>] , f[i][j - <span class="number">1</span>][k][sta] + cost(<span class="number">1</span> , j , i , k));</span><br><span class="line">                <span class="keyword">if</span>(k) rep(sta , <span class="number">0</span> , <span class="number">2</span>) <span class="keyword">if</span>(sta != <span class="number">2</span>) upd(f[i][j][k][<span class="number">2</span>] , f[i][j][k - <span class="number">1</span>][sta] + cost(<span class="number">2</span> , k , i , j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i , <span class="number">0</span> , <span class="number">2</span>) ans = min(ans , f[tot[<span class="number">0</span>]][tot[<span class="number">1</span>]][tot[<span class="number">2</span>]][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , ans == <span class="number">0x3f3f3f3f</span> ? <span class="number">-1</span> : ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 多校联考 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> JOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JOI2019 Final】画展-题解</title>
      <link href="2020/11/27/loj3011/"/>
      <url>2020/11/27/loj3011/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>你将举办一个画展。在展览中，你需要将一些画放入一些画框中并摆放成一排。</p><p>展览有 $N$ 幅候选画，编号从 $1$ 到 $N$。画 $i ( 1 \le i \le N)$ 具有大小 $S_i$ 和美观度 $V_i$。</p><p>另外，有 $M$ 个候选画框，编号从 $1$ 到 $M$。画框 $j ( 1 \le j \le M)$ 的大小为 $C_j$。</p><p>只有大小不超过 $C_j$ 的画才能放入画框 $j$ 中。每个画框中最多只能放一幅画。每幅要展出的画都必须放在一个画框中。</p><p>考虑到美观因素，展出的画必须满足以下条件：</p><ul><li>对于任意两幅相邻的画，右边的画框大小不小于左边的画框</li><li>对于任意两幅相邻的画，右边的画的美观度不小于左边的画的美观度</li></ul><p>你需要求出你最多能展出多少幅画。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数 $N$ 和 $M$。</p><p>接下来 $N$ 行，第 $i$ 行为两个整数 $S_i$ 和 $V_i$。</p><p>接下来 $M$ 行，第 $i$ 行为一个整数 $C_i$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数，表示你最多能展出的画的数量。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">10 20</span><br><span class="line">5 1</span><br><span class="line">3 5</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">10</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于所有输入数据，有 $1 \le N, M \le 10^5, 1 \le S_i, V_i, C_j \le 10^9 (1 \le i \le N, 1 \le j \le M)$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>很裸的贪心题。</p><p>首先显然我们把画框大小排序之后答案是不变的，且排序之后就有了单调性，方便处理。故需要对其进行排序。</p><p>之后考虑如何处理画？我们将画按照美观度为第一关键字，大小为第二关键字进行排序，这样画的美观度就有了单调性。</p><p>显然，大画框是可以放小画的，且因为之前的两次排序，我们画框的大小和美观度都有了单调性，故直接扫一遍，能放就放即可。</p><p>时间复杂度 $O(n \log n)$ ，瓶颈在于排序。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n , m , c[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ll s , v;</span><br><span class="line">&#125;k[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a , Node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.v == b.v) <span class="keyword">return</span> a.s &lt; b.s; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;a.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;a.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n) , read(m);</span><br><span class="line">    rep(i , <span class="number">1</span> , n) read(k[i].s) , read(k[i].v);   </span><br><span class="line">    rep(i , <span class="number">1</span> , m) read(c[i]);</span><br><span class="line">    </span><br><span class="line">    sort(c + <span class="number">1</span> , c + <span class="number">1</span> + m);</span><br><span class="line">    sort(k + <span class="number">1</span> , k + <span class="number">1</span> + n , cmp);</span><br><span class="line">    </span><br><span class="line">    ll now = n , ans = <span class="number">0</span>;</span><br><span class="line">    per(i , m , <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(now &amp;&amp; k[now].s &gt; c[i]) now --;</span><br><span class="line">        <span class="keyword">if</span>(now) ans ++ , now --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 多校联考 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> JOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【总结篇】考场策略 &amp; 常犯错误总结</title>
      <link href="2020/11/26/noip-error/"/>
      <url>2020/11/26/noip-error/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="常犯错误"><a href="#常犯错误" class="headerlink" title="常犯错误"></a>常犯错误</h2><p>以下为笔者或笔者的学弟学妹曾在比赛中犯过的错误，在此列出，以供参考。</p><hr><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><ol><li><strong>忘记初始化</strong>。</li><li>合并时不先寻找祖先，直接进行合并。</li><li><code>find()</code> 函数忘记路径压缩。</li></ol><hr><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><ol><li><strong>无向边不开双倍空间</strong>。</li><li>使用 <code>next</code> 作为数组名导致 $\text{CE}$。</li></ol><hr><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><ol><li><strong>不开四倍空间</strong>。</li><li><code>#define lson(x) x &lt;&lt; 1</code> 时，<code>x &lt;&lt; 1</code> 不加括号。</li><li>不建议在数据结构中使用 <code>num</code> 作为变量名，因为意义过于广泛。</li></ol><hr><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><ol><li>排序时把 $n$ 与 $m$ 弄反。</li><li>试图使用 <code>memset</code> 将非 <code>bool</code> 数组赋值为 $1$。</li><li><strong>在</strong> <code>STL</code> <strong>容器为空时访问其顶部或队首元素</strong>。</li><li><code>xxx.size()</code> 返回的是 <code>unsigned</code> 类型整数，尽量不要对其作减法运算</li><li>在 <code>multiset</code> 中，删除一个元素为 <code>s.erase(s.find(x))</code> , 不是 <code>s.erase(x)</code></li></ol><hr><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li><strong>数据类型不对 （不开或只有部分变量开了</strong> <code>long long</code> , <code>double</code> , <code>long double</code>）</li><li>大整数相乘时不乘 <code>1ll</code> 导致运算时溢出</li><li>将 <code>long long</code> 类型的数据传入 <code>int</code> 的形参。</li></ol><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><strong>不加 <code>#include &lt;cstdio&gt;</code></strong> （$\text{Windows}$ 下不会报错，但 $\text{Linux}$ 一定 $\text{CE}$）</li><li>将 <code>#include &lt;bits/stdc++.h&gt;</code> 中的 <code>/</code> 打反 (同上)</li><li>有返回值的函数不 <code>return</code></li><li><strong>开小数组</strong>。</li><li>负数下标导致 $\text{RE}$</li><li><strong>不开文件或文件输入输出写错</strong></li><li>使用不关流的 <code>cin</code> 读入 $10^6$ 级别的大数据。</li><li><code>inf</code> 设小 （一般 <code>int</code> 设为 <code>0x3f3f3f3f</code> 比较保险，<code>long long</code> 可以设为 <code>1e18</code>）。</li><li><code>inf</code> 设大导致溢出 （<strong>不要使用数据类型的上界作为</strong> <code>inf</code>）</li><li>二分边界达到 <code>2e9</code> 时 <code>mid</code> 不开 <code>long long</code></li><li><strong>忘记取模或取模不及时</strong></li><li><strong>多测不清空或清空不完全</strong></li><li>提交前不删除调试信息。</li><li>使用各种不能用的变量 （<code>y1</code> , <code>j1</code> 等单字母变量 + 数字很容易与 <code>cmath</code> 库冲突，<code>end</code> , <code>_end</code>, <code>rank</code> 都是 <code>Linux</code> 保留字）。</li></ol><hr><h2 id="考场策略与技巧"><a href="#考场策略与技巧" class="headerlink" title="考场策略与技巧"></a>考场策略与技巧</h2><ol><li><strong>对拍模板在试机时就写完（因为一定会用到）</strong></li><li>$\text{T1}$ 不一定是最简单的，请先通读一遍题目之后再考虑从哪里开始</li><li>读过题目之后请简化题意，即使用形象化的语言复述一遍题意</li><li><strong>前两小时打满暴力，后两个半小时思考正解</strong>，这样就算什么都没思考出来也不至于空手而归，而且暴力可以用于对拍</li><li>边界处理拿不准时就在纸上举个例子再写。</li><li><strong>数据分治</strong>（注意别判错子任务）</li><li>最后 $5 min$ 不要修改程序，只去检查题目名，文件夹，文件输入输出等是否正确即可。</li><li>对拍的使用方法：点<a href="https://payphone-x.top/2019/09/17/same/">这里</a></li><li>程序使用内存的查看方法（以 A + B 为例子）：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;    </span></span></span><br><span class="line"><span class="comment">//windows.h 与 system 语句在提交之前务必删除或注释，否则会爆零</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a , b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;a , &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , a + b);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;size a.exe&quot;</span>);    </span><br><span class="line">    <span class="comment">//假设文件名为 a.cpp</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其运行后会产生这样一个界面</p><p><img src= "/img/loading.gif" data-lazy-src="https://shop.io.mi-img.com/app/shop/img?id=shop_04bf23368f04a9738ca00b343765a6f0.png" alt="image.png"></p><p>其中 <code>bss</code> 是所有全局变量所占用的空间之和， <code>dec</code> 是所有变量所占用的空间之和（单位均为字节），故 $\frac{dec}{1024 \times 1024}$ 为程序消耗的总空间（单位为 $\text{MB}$）。</p><hr><p>祝大家 $\text{NOIP}$ 都能取得好成绩。</p><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 成长之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结篇 </tag>
            
            <tag> 成长之路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【多校联考2020】巡游-题解</title>
      <link href="2020/11/25/ZLOJ10187/"/>
      <url>2020/11/25/ZLOJ10187/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>数轴上分布着 $n$ 个礼品店，第 $i$ 个礼品店在位置 $i$。进入礼品店 $i$ 后，你能够购买一个重量为 $a_i$ 的礼品，每个物品最多购买一次。</p><p>你需要从 $0$ 位置出发，最后返回 $0$位置。每次可以选择购买当前位置的礼品，或者向左或右移动 $1$ 单位的距离。</p><p>如果你当前携带着重量之和为 $s$ 的礼品，每次移动你需要消耗 $s+1$ 的能量。</p><p>问在消耗不超过 $e$ 的能量的情况下，最多能带回多少重量的礼品。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 $n,e$，表示礼品店的数量和消耗能量的上界。</p><p>第二行包含 $n$ 个整数 $a_i$ ，表示第 $i$ 个礼品店中礼品的重量。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共一行一个整数，表示最多能带回的礼品的重量。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4 25</span><br><span class="line">3 30 1 3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于 $20\%$ 的数据，满足 $n \le 20,e \le 10^2$。</p><p>对于 $40\%$ 的数据，满足 $n \le 10^3, e \le 3 \cdot 10^3$。</p><p>对于 $70\%$ 的数据，满足 $n \le 10^5, e \le 3\cdot 10^5$。</p><p>另有 $10\%$ 的数据，满足 $a_i \le 1$。</p><p>对于全部数据，满足 $1 \le n \le 10^6, 1 \le e \le 3 \cdot 10^7, 0 \le a_i \le 10^6$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>考场上硬是没看出来背包</del></p><h3 id="40pts"><a href="#40pts" class="headerlink" title="40pts"></a>40pts</h3><p>物品只要在身上就会在移动时花费相应的体力，我们要尽量节省体力，故要让每个物品在身上的时间尽量的短。</p><p>故最优策略一定是走到某个物品 $x$ 之后掉头往左走，在回来的路上购买其他物品。</p><p>设 $f[i][j]$ 表示走到第 $i$ 个物品后掉头，花费体力为 $j$ 时的最大收益，则有</p><script type="math/tex; mode=display">f[i][j] = max(f[i - 1][j] , f[i - 1][j - i \times a[i]] + a[i])</script><p>时间复杂度 $O(n \times e)$ ，无法通过本题，但可以拿到 $40$ 分的好成绩。</p><hr><h3 id="100pts"><a href="#100pts" class="headerlink" title="100pts"></a>100pts</h3><p>满分做法需要发现一个小性质：对于一个物品 $i$ ，若 $e &lt; a[i] \times i$，则该物品一定无法选择。</p><p>考虑从右往左 dp ，设 $f[i][j]$ 表示走到第 $i$ 个礼品店后掉头，收益为 $j (j &lt; \frac{e}{i})$ 所需要的最小体力。则有转移 ：</p><script type="math/tex; mode=display">f[i][j] = max(f[i - 1][j] , f[i - 1][j - a[i]] + i \times a[i])</script><p>状态总数为 $\sum_{i = 1}^{n} \frac{e}{i}$，故时间复杂度为 $O(e \log n)$，足以通过所有数据。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">30000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , e , a[M];</span><br><span class="line"></span><br><span class="line">ll f[M] , ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n) , read(e);</span><br><span class="line">    rep(i , <span class="number">1</span> , n) read(a[i]);</span><br><span class="line">    </span><br><span class="line">    clean(f , <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    per(i , n , <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] * i &gt; e) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lim = e / i;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">2</span> * i;</span><br><span class="line">        per(j , lim , a[i]) f[j] = min(f[j] , f[j - a[i]] + a[i] * i);</span><br><span class="line">    &#125;</span><br><span class="line">    per(i , e , <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i] &lt;= e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , i) , <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 多校联考 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【多校联考2020】溯源-题解</title>
      <link href="2020/11/25/ZLOJ10185/"/>
      <url>2020/11/25/ZLOJ10185/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>你有一张 $n$ 个点 $m$ 条边的无向连通简单图，每条边的边权都为 $1$。</p><p>小 A 选择了一个起始点 $s$，并求出起始点 $s$ 到每个节点 $u$ 的最短路 $d_u$。</p><p>小 A 告诉了你所有 $d[u] \bmod 3$ 的值，请你找到所有可能的起始点。</p><p>如果不存在，请输出 <code>−1</code>。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 $n,m$，表示无向图的点数和边数。</p><p>第二行包含 $n$ 个整数 $a_1,a_2,\cdots,a_n$ ，其中 $a_i \equiv d_i \pmod 3$。</p><p>接下来的 $m$ 行，每行包含两个整数 $u_i,v_i$，表示第 $i$ 条无向边的两个端点。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共一行，包含所有合法的起始点 $s$，按照升序输出并用一个空格分隔。</p><p>如果不存在解，输出一行一个 <code>-1</code>。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">1 0 1 1 2</span><br><span class="line">5 4</span><br><span class="line">1 2</span><br><span class="line">3 2</span><br><span class="line">3 4</span><br><span class="line">4 2</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于 $50\%$ 的数据，满足 $n,m \le 1000$。</p><p>另有 $70\%$ 的数据，满足合法起始点的数量不超过 $55$ 个。</p><p>对于 $100\%$ 的数据，满足 $1 \le n, m \le 2 \times 10^6$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>考虑什么样子的点可以作为原点？</p><p>对于点 $u$ ，若其可以作为原点，则需满足：</p><ul><li>$a[u] = 0$</li><li>对于与其直接相连的任意一个点 $v$ ，需要满足 $a[v] = 1$</li></ul><p>且图中只能存在一个原点。</p><p>故我们找出满足以上条件的点，若有多个显然无解，否则 <code>bfs</code> 判断一下该点到其他点的最短路 $\bmod 3$ 的值是否与 $a$ 数组相同即可。</p><p>时间复杂度 $O(n + m)$</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , d[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , last;</span><br><span class="line">&#125;edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;to , head[from]&#125;; head[from] = edge_num;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;from , head[to]&#125;; head[to] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[M] , inq[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> sta)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">clean(dis , <span class="number">0x3f3f3f3f</span>) , clean(inq , <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">q.push(sta);</span><br><span class="line">inq[sta] = <span class="number">1</span> , dis[sta] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> fro = q.front(); q.pop();</span><br><span class="line">inq[fro] = <span class="number">0</span>;</span><br><span class="line">PE(i , fro) &#123;</span><br><span class="line"><span class="keyword">int</span> to = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(dis[to] &gt; dis[fro] + <span class="number">1</span>) &#123;</span><br><span class="line">dis[to] = dis[fro] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!inq[to]) &#123;</span><br><span class="line">inq[to] = <span class="number">1</span>;</span><br><span class="line">q.push(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rep(i , <span class="number">1</span> , n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[i] % <span class="number">3</span> != d[i]) <span class="keyword">return</span> (<span class="keyword">void</span>)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , sta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;source.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;source.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n) , read(m);</span><br><span class="line">    rep(i , <span class="number">1</span> , n) read(d[i]);</span><br><span class="line">    rep(i , <span class="number">1</span> , m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u , v;</span><br><span class="line">        read(u) , read(v);</span><br><span class="line">        add_edge(u , v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> poi = <span class="number">0</span>;</span><br><span class="line">    rep(x , <span class="number">1</span> , n) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(d[x] == <span class="number">0</span>) &#123;</span><br><span class="line">            PE(i , x) &#123;</span><br><span class="line">                <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">                flag &amp;= (d[to] == <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span> &amp;&amp; d[x] == <span class="number">0</span>) &#123;</span><br><span class="line">            poi = x; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!poi) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> bfs(poi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 多校联考 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 最短路树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【多校联考2020】盘王节-题解</title>
      <link href="2020/11/23/ZLOJ10281/"/>
      <url>2020/11/23/ZLOJ10281/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>盘王节是祭祀瑶族祖先盘古王的重大节日.</p><p>小 L 望着眼前的小 Q 穿着盛装, 鼓声镲声交错耳边, 远古而悠长的音节从小 Q 的口中淌出, 仿佛构筑起一条现世与始祖神灵的通路. 身旁的舞龙队伍盛大地游行着, 小 Q 的一双手突然拉住了小 L, 他们融进了欢庆的人群中兴奋地共舞, 夜空之下烟火绽开, 华光渲染了他俩的眼眸, 更照亮了少年内心暗暗涌动的情愫…</p><p>节日庆典上, 小 Q 向小 L 介绍了一种特色双人益智游戏, 以下为游戏的大体内容:</p><ul><li>双方分为<strong>进攻方</strong>与<strong>防守方</strong>.</li><li>进攻方有 $n$ 种不同的<strong>兵符</strong>, 第 $i$ 种能力值为 $a_i$, 各有 $x_i$ 个.</li><li>防守方有 $m_1$ 种不同的先灵庇佑的<strong>御符</strong> , 第 $i$ 种能力值为 $b_i$, 各有 $y_i$ 个.</li><li>防守方还有 $m_2$ 种不同的<strong>兵符</strong> , 第 $i$ 种能力值为 $c_i$, 各有 $z_i$ 个.</li></ul><p>这个游戏由进攻方主动, 每次可以<strong>选择一个兵符击破防守方的任意一个御符或任意一个兵符</strong>.</p><ol><li>若进攻御符, <strong>不会对对方造成伤害</strong>, 但如果能力值<strong>不低于</strong>对方, 则可以破除对方这个符咒。</li><li>若进攻兵符, 会对对方造成为两者能力值差的伤害, 如果能力值<strong>不低于</strong>对方, 则可以破除对方这个符咒</li></ol><p>注意：</p><ul><li>自己的<strong>符咒是消耗品, 每个只能用一次</strong></li><li>如果<strong>自己的符能力值没有对方高, 视作无效操作. 且也会浪费当前符咒</strong>.</li><li>当对方<strong>所有御符都被破除后</strong>, 自己还剩下的兵符<strong>可以越过对方兵符, 直接对对方造成能力值的伤害</strong>.</li></ul><p>你需要最大化进攻方对防守方的伤害。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>从文件 <code>panwang.in</code> 中读入数据。</p><p>第一行三个整数, 表示 $n, m1, m2$</p><p>接下来 $n$ 行, 每一行分别给出 $a_i, x_i$</p><p>接下来 $m_1$ 行, 每一行分别给出 $b_i, y_i$</p><p>接下来 $m_2$ 行, 每一行分别给出 $c_i, z_i$</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出到文件 <code>panwang.out</code> 中。</p><p>一行一个整数, 表示最大伤害</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 1 3</span><br><span class="line">15 1</span><br><span class="line">64 1</span><br><span class="line">18 1</span><br><span class="line">9 1</span><br><span class="line">61 1</span><br><span class="line">86 1</span><br><span class="line">57 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">82</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><div class="table-container"><table><thead><tr><th style="text-align:center">测试点编号</th><th style="text-align:center">$n,m \leq$</th><th style="text-align:center">$\sum x_i + y_i + z_i \leq$</th></tr></thead><tbody><tr><td style="text-align:center">$1 \to 4$</td><td style="text-align:center">$5$</td><td style="text-align:center">$15$</td></tr><tr><td style="text-align:center">$5 \to 10$</td><td style="text-align:center">$1000$</td><td style="text-align:center">$6000$</td></tr><tr><td style="text-align:center">$11 \to 14$</td><td style="text-align:center">$10^6$</td><td style="text-align:center">$6 \times 10^6$</td></tr><tr><td style="text-align:center">$15 \to 20$</td><td style="text-align:center">$10^6$</td><td style="text-align:center">无特殊限制</td></tr></tbody></table></div><p>对于所有数据, $1 \leq n ≤ 10^6; 1 \leq m1 , m2 ≤ 10^6$, 所有能力值为<strong>绝对值</strong> 小于 $100$ 的整数,单个种类的符咒数量不超过 $10^9$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看到题目给出一个双人游戏自然会向贪心或博弈上想，而这题只提到了进攻方，故八成是贪心。</p><p>读完题目，不难发现只有两种情况可能是最优解。分别是<strong>打目前能打的最小兵符一直打到没有收益为止</strong> 与 <strong>打破所有盾之后去打脸</strong></p><p>其中第一个情况直接用大的打对方小的即可。</p><p>对于第二种情况，我们需要尽量用能力值小的兵去击破对方的盾，则我们将对方的盾和自己的兵从大到小排序，之后选择刚好比对方能力值大的兵去打即可。</p><p>对方的盾全部击破之后就相当于其多了个能力值为 $0$，数目为无限的兵，然后就变成了第一种情况。</p><p>但要注意，<strong>题目中可能存在能力值小于</strong> $0$ <strong>的兵</strong>，此时打这个兵是比直接打脸要更优的，处理时候注意一下即可。</p><p>剩下的就是细节问题了，直接参考代码吧。</p><p><del>以及不要乱用 j1 , j2 一类的字母作为变量名(来自考场上用了 j1 而爆零的笔者)</del></p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种打法：一直打最小的兵或者破掉所有盾之后打max(最小的兵,胡脸)</span></span><br><span class="line"></span><br><span class="line">ll n , m1 , m2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Jian</span>&#123;</span></span><br><span class="line">    ll bru , num;</span><br><span class="line">&#125;J1[M] , J2[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dun</span>&#123;</span></span><br><span class="line">    ll bru , num;</span><br><span class="line">&#125;d[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(Jian a , Jian b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.bru == b.bru) <span class="keyword">return</span> a.num &lt; b.num;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.bru &lt; b.bru;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Dun a , Dun b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(a.bru == b.bru) <span class="keyword">return</span> a.num &lt; b.num;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.bru &lt; b.bru;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Jian a[M] , b[M];</span><br><span class="line">Dun c[M];</span><br><span class="line"></span><br><span class="line">ll ans1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// J1 为进攻方的兵，J2 为防守方的兵，d 为防守方的盾</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    copy(a , J1) , copy(b , J2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pla = <span class="number">1</span>;</span><br><span class="line">    per(i , n , <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].bru &lt;= b[pla].bru) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(pla &gt; m2) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(a[i].bru &gt; b[pla].bru &amp;&amp; a[i].num &gt; <span class="number">0</span> &amp;&amp; pla &lt;= m2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].num &gt;= b[pla].num)&#123;</span><br><span class="line">                ll val = a[i].bru - b[pla].bru;</span><br><span class="line">                val *= b[pla].num;</span><br><span class="line">                ans1 += val;</span><br><span class="line">                a[i].num -= b[pla].num , b[pla].num = <span class="number">0</span>;</span><br><span class="line">                pla ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ll val = a[i].bru - b[pla].bru;</span><br><span class="line">                val *= a[i].num;</span><br><span class="line">                ans1 += val;</span><br><span class="line">                b[pla].num -= a[i].num;</span><br><span class="line">                a[i].num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// J1 为进攻方的兵，J2 为防守方的兵，d 为防守方的盾</span></span><br><span class="line"></span><br><span class="line">ll ans2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    copy(a , J1) , copy(b , J2) , copy(c , d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pla = <span class="number">1</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pla &gt; m1) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(a[i].bru &gt;= c[pla].bru &amp;&amp; a[i].num &gt; <span class="number">0</span> &amp;&amp; pla &lt;= m1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].num &gt;= c[pla].num)&#123;</span><br><span class="line">                a[i].num -= c[pla].num;</span><br><span class="line">                c[pla].num = <span class="number">0</span>;</span><br><span class="line">                pla ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                c[pla].num -= a[i].num;</span><br><span class="line">                a[i].num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pla &lt;= m1) <span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    rep(i , <span class="number">1</span> , m2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i].bru &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            b[i].bru = <span class="number">0</span> , b[i].num = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b[m2 + <span class="number">1</span>].bru = <span class="number">0</span> , b[m2 + <span class="number">1</span>].num = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    </span><br><span class="line">    pla = <span class="number">1</span>;</span><br><span class="line">    per(i , n , <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].bru &lt;= b[pla].bru) <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(a[i].bru &gt; b[pla].bru &amp;&amp; a[i].num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].num &gt;= b[pla].num)&#123;</span><br><span class="line">                ll val = a[i].bru - b[pla].bru;</span><br><span class="line">                val *= b[pla].num;</span><br><span class="line">                ans2 += val;</span><br><span class="line">                a[i].num -= b[pla].num;</span><br><span class="line">                b[pla].num = <span class="number">0</span>;</span><br><span class="line">                pla ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ll val = a[i].bru - b[pla].bru;</span><br><span class="line">                val *= a[i].num;</span><br><span class="line">                ans2 += val;</span><br><span class="line">                b[pla].num -= a[i].num;</span><br><span class="line">                a[i].num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;panwang.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;panwang.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n) , read(m1) , read(m2);</span><br><span class="line">    rep(i , <span class="number">1</span> , n) read(J1[i].bru) , read(J1[i].num);</span><br><span class="line">    rep(i , <span class="number">1</span> , m1) read(d[i].bru) , read(d[i].num);</span><br><span class="line">    rep(i , <span class="number">1</span> , m2) read(J2[i].bru) , read(J2[i].num);</span><br><span class="line">    </span><br><span class="line">    sort(J1 + <span class="number">1</span> , J1 + <span class="number">1</span> + n , cmp1);</span><br><span class="line">    sort(J2 + <span class="number">1</span> , J2 + <span class="number">1</span> + m2 , cmp1);</span><br><span class="line">    sort(d + <span class="number">1</span> , d + <span class="number">1</span> + m1 , cmp2);</span><br><span class="line">    </span><br><span class="line">    solve1() , solve2();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , max(ans1 , ans2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 多校联考 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【多校联考2020】球-题解</title>
      <link href="2020/11/22/ZLOJ10229/"/>
      <url>2020/11/22/ZLOJ10229/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>小 T 有 $n$ 个桶和 $2n − 1$ 个球，其中第 $i$ 个桶能装前 $2i − 1$ 个球。每个桶只能<br>装一个球。</p><p>现在小 T 取了 $m$ 个桶和 $m$ 个球，并将这些球各自放在这些桶里。问这样的方案有多少？两种方案不同当且仅当选择了不同的桶或球或者同一个桶在两种方案放了不同的球。</p><p>由于方案的数量可能很大，所以只需要求方案数模 $998244353$ 后的结果。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>从输入文件 <code>ball.in</code> 中读入数据。</p><p>第一行一个整数 $T$，表示数据组数。</p><p>接下来 $T$ 行，每行两个整数 $n, m$，含义见【问题描述】。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出到文件 <code>ball.out</code> 中。</p><p>输出共 $T$ 行，每行一个整数表示一组数据的答案。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">2 2</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">2 2</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><div class="table-container"><table><thead><tr><th style="text-align:center">测试点编号</th><th style="text-align:center">$n \leq$</th><th style="text-align:center">$m \leq$</th></tr></thead><tbody><tr><td style="text-align:center">$1$</td><td style="text-align:center">$5$</td><td style="text-align:center">$5$</td></tr><tr><td style="text-align:center">$2$</td><td style="text-align:center">$10$</td><td style="text-align:center">$10$</td></tr><tr><td style="text-align:center">$3$</td><td style="text-align:center">$15$</td><td style="text-align:center">$15$</td></tr><tr><td style="text-align:center">$4$</td><td style="text-align:center">$100$</td><td style="text-align:center">$100$</td></tr><tr><td style="text-align:center">$5$</td><td style="text-align:center">$100000$</td><td style="text-align:center">$100$</td></tr><tr><td style="text-align:center">$6$</td><td style="text-align:center">$100000$</td><td style="text-align:center">$100$</td></tr><tr><td style="text-align:center">$7$</td><td style="text-align:center">$100000$</td><td style="text-align:center">$100$</td></tr><tr><td style="text-align:center">$8$</td><td style="text-align:center">$100000$</td><td style="text-align:center">$100000$</td></tr><tr><td style="text-align:center">$9$</td><td style="text-align:center">$10^7$</td><td style="text-align:center">$10^7$</td></tr><tr><td style="text-align:center">$10$</td><td style="text-align:center">$10^7$</td><td style="text-align:center">$10^7$</td></tr></tbody></table></div><p>对于 $100\%$ 的测试点，保证 $1 ≤ T ≤ 10^5 , 1 ≤ m ≤ n ≤ 10^7$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>考场上找出了规律，然后抄错式子就爆零了</del></p><h3 id="70pts"><a href="#70pts" class="headerlink" title="70pts"></a>70pts</h3><p>$70$ 分的做法是一个比较直观的 $\text{dp}$。</p><p>设 $f[i][j]$ 为用了 $i$ 个桶，$j$ 个球的方案数。</p><p>之后分两种情况进行转移：</p><ul><li>若第 $i$ 个桶没有放球，则有 $f[i - 1][j]$ 种方案。</li><li>若第 $i$ 个桶放了球，则先考虑前 $i - 1$ 个桶的状况，一共有 $f[i - 1][j - 1]$ 种不同的方案，而第 $i$ 个桶放的球必须在剩下的 $(2i - 1) - (j - 1) = 2i - j$ 个球中选择，则共有 $(2i - j) \times f[i - 1][j - 1]$ 种不同的方案。</li></ul><p>综上所述，有 $f[i][j] = f[i - 1][j] + (2i - j) \times f[i - 1][j - 1]$。</p><p>初始化为 $f[i][0] = 1 (i \in \lbrack 0 , 10^5 \rbrack)$</p><p>代码也很好写：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">100005</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    rep(i , <span class="number">0</span> , <span class="number">100000</span>) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    rep(i , <span class="number">2</span> , <span class="number">100000</span>)&#123;</span><br><span class="line">        rep(j , <span class="number">1</span> , min(i , <span class="number">100</span>))&#123;</span><br><span class="line">            ll tmp = <span class="number">1l</span>l * (<span class="number">2</span> * i - j) % HA * f[i - <span class="number">1</span>][j - <span class="number">1</span>] % HA;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j] + tmp % HA , f[i][j] %= HA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n , m;</span><br><span class="line">    read(n) , read(m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , f[n][m] % HA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;ball.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;ball.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    prepare();</span><br><span class="line">    <span class="keyword">int</span> t; read(t);</span><br><span class="line">    <span class="keyword">while</span>(t --) solve();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="100pts"><a href="#100pts" class="headerlink" title="100pts"></a>100pts</h3><p>$10^7$ 的数据范围与 $10^5$ 的询问次数已经明确表示标算一定是 $O(T \log n)$ 或 $O(T)$ 的。</p><p>考虑<del>打表找规律(其实表也不用打因为有大样例)</del>可知:</p><script type="math/tex; mode=display">f[n][m] = [C_{n}^{m}]^2 \times m!</script><p>证明如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/11/22/fZkR78xBbJIwsAE.png" alt=""></p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll fac[M] , inv[M];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll a , ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> a % HA;</span><br><span class="line">    ll mid = Pow(a , n / <span class="number">2</span>) % HA;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) <span class="keyword">return</span> mid * mid % HA * a % HA;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mid * mid % HA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , lim)&#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % HA;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[lim] = Pow(fac[lim] , HA - <span class="number">2</span>);</span><br><span class="line">    per(i , lim , <span class="number">1</span>)&#123;</span><br><span class="line">        inv[i - <span class="number">1</span>] = inv[i] * i % HA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n , ll m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % HA * inv[n - m] % HA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n , m;</span><br><span class="line">    read(n) , read(m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , C(n , m) * C(n , m) % HA * fac[m] % HA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define LOCAL </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;ball.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;ball.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    prepare((<span class="keyword">int</span>)<span class="number">1e7</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t; read(t);</span><br><span class="line">    <span class="keyword">while</span>(t --) solve();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 乱搞 </tag>
            
            <tag> 多校联考 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSP-S2020】函数调用-题解</title>
      <link href="2020/11/16/luoguP7077/"/>
      <url>2020/11/16/luoguP7077/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>函数是各种编程语言中一项重要的概念，借助函数，我们总可以将复杂的任务分解成一个个相对简单的子任务，直到细化为十分简单的基础操作，从而使代码的组织更加严密、更加有条理。然而，过多的函数调用也会导致额外的开销，影响程序的运行效率。</p><p>某数据库应用程序提供了若干函数用以维护数据。已知这些函数的功能可分为三类：</p><ol><li>将数据中的指定元素加上一个值； </li><li>将数据中的每一个元素乘以一个相同值； </li><li><strong>依次</strong>执行若干次函数调用，保证不会出现递归（即不会直接或间接地调用本身）。</li></ol><p>在使用该数据库应用时，用户可一次性输入要调用的函数序列（一个函数可能被调用多次），在<strong>依次</strong>执行完序列中的函数后，系统中的数据被加以更新。 某一天，小 A 在应用该数据库程序处理数据时遇到了困难：由于频繁而低效的函数调用，系统在执行操作时进入了无响应的状态，他只好强制结束了数据库程序。为了计算出正确数据，小 A 查阅了软件的文档，了解到每个函数的具体功能信息，现在他想请你根据这些信息帮他计算出更新后的数据应该是多少。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数 $n$，表示数据的个数。 </p><p>第二行 $n$ 个整数，第 $i$ 个整数表示下标为 $i$ 的数据的初始值为 $a_i$。 </p><p>第三行一个正整数 $m$，表示数据库应用程序提供的函数个数。函数从 $1\ldots m$ 编号。 </p><p>接下来 $m$ 行中，第 $j$（$1 \le j \le m$）行的第一个整数为 $T_j$，表示 $j$ 号函数的类型：</p><ol><li>若 $T_j = 1$，接下来两个整数 $P_j,~V_j$ 分别表示要执行加法的元素的下标及其增加的值；</li><li>若 $T_j = 2$，接下来一个整数 $V_j$ 表示所有元素所乘的值； </li><li>若 $T<em>j = 3$，接下来一个正整数 $C_j$ 表示 $j$ 号函数要调用的函数个数，随后 $C_j$ 个整数 $g_1^{(j)},~g_2^{(j)},~\ldots,~g</em>{C_j}^{(j)}$，依次表示其所调用的函数的编号。</li></ol><p>第 $m + 4$ 行一个正整数 $Q$，表示输入的函数操作序列长度。</p><p>第 $m + 5$ 行 $Q$ 个整数 $f_i$，第 $i$ 个整数表示第 $i$ 个执行的函数的编号。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行 $n$ 个用空格隔开的整数，按照下标 $1\ldots n$ 的顺序，分别输出在执行完输入的函数序列后，数据库中每一个元素的值。<strong>答案对</strong> $\boldsymbol{998244353}$ <strong>取模。</strong></p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 </span><br><span class="line">1 2 3 </span><br><span class="line">3 </span><br><span class="line">1 1 1 </span><br><span class="line">2 2 </span><br><span class="line">3 2 1 2 </span><br><span class="line">2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6 8 12 </span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">10 </span><br><span class="line">1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">8</span><br><span class="line">3 2 2 3 </span><br><span class="line">3 2 4 5 </span><br><span class="line">3 2 5 8 </span><br><span class="line">2 2 </span><br><span class="line">3 2 6 7 </span><br><span class="line">1 2 5 </span><br><span class="line">1 7 6 </span><br><span class="line">2 3 </span><br><span class="line">3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">36 282 108 144 180 216 504 288 324 360</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><div class="table-container"><table><thead><tr><th style="text-align:center">测试点编号</th><th style="text-align:center">$n,m,Q\le$</th><th style="text-align:center">$\sum C_j$</th><th style="text-align:center">其他特殊限制</th></tr></thead><tbody><tr><td style="text-align:center">$1\sim 2$</td><td style="text-align:center">$1000$</td><td style="text-align:center">$=m-1$</td><td style="text-align:center">函数调用关系构成一颗树</td></tr><tr><td style="text-align:center">$3\sim 4$</td><td style="text-align:center">$1000$</td><td style="text-align:center">$\le 100$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$5\sim 6$</td><td style="text-align:center">$20000$</td><td style="text-align:center">$\le 40000$</td><td style="text-align:center">不含第 $2$ 类函数或不含第 $1$ 类函数</td></tr><tr><td style="text-align:center">$7$</td><td style="text-align:center">$20000$</td><td style="text-align:center">$=0$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$8\sim 9$</td><td style="text-align:center">$20000$</td><td style="text-align:center">$=m-1$</td><td style="text-align:center">函数调用关系构成一颗树</td></tr><tr><td style="text-align:center">$10\sim 11$</td><td style="text-align:center">$20000$</td><td style="text-align:center">$\le 2\times 10^5$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$12\sim 13$</td><td style="text-align:center">$10^5$</td><td style="text-align:center">$\le 2\times 10^5$</td><td style="text-align:center">不含第 $2$ 类函数或不含第 $1$ 类函数</td></tr><tr><td style="text-align:center">$14$</td><td style="text-align:center">$10^5$</td><td style="text-align:center">$=0$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$15\sim 16$</td><td style="text-align:center">$10^5$</td><td style="text-align:center">$=m-1$</td><td style="text-align:center">函数调用关系构成一颗树</td></tr><tr><td style="text-align:center">$17\sim 18$</td><td style="text-align:center">$10^5$</td><td style="text-align:center">$\le 5\times 10^5$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$19\sim 20$</td><td style="text-align:center">$10^5$</td><td style="text-align:center">$\le 10^6$</td></tr></tbody></table></div><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>官方数据水到写了就是50起步真的可以……</del></p><p>读完题后不难发现数列的初始化相当于对于每一个 $i(i \in \lbrack 1 , n \rbrack)$ 执行操作 <code>1 i a[i]</code>。</p><p>先考虑不含操作三的 $10$ 分<del>(可以直接线段树2草过去，但对于正解无任何启发作用)</del>，手玩几组数据看一下操作二的本质：</p><p>设 $a = \lbrack 2 , 3 , 4 \rbrack$，操作序列分别为 $(1 , 1 , 1) , (2 , 4) , (1 , 1 , 2) , (2 , 3) , (1 , 2 , 4)$。</p><p>从初始化开始模拟，过程如下：</p><ul><li>设初始时 $a = \lbrack 0 , 0 , 0 \rbrack$。</li></ul><ol><li>将 $1$ 号位置加 $2$，此时 $a = \lbrack 2 , 0 , 0 \rbrack$。</li><li>将 $2$ 号位置加 $3$，此时 $a = \lbrack 2 , 3 , 0 \rbrack$。</li><li>将 $3$ 号位置加 $4$，此时 $a = \lbrack 2 , 3 , 4 \rbrack$。</li><li>将 $1$ 号位置加 $1$，此时 $a = \lbrack 3 , 3 , 4 \rbrack$。</li><li>全局乘 $4$，此时 $a = \lbrack 12 , 12 , 16 \rbrack$。</li><li>将 $1$ 号位置加 $2$，此时 $a = \lbrack 14 , 12 , 16 \rbrack$。</li><li>全局乘 $3$，此时 $a = \lbrack 42 , 36 , 48 \rbrack$。</li><li>将 $2$ 号位置加 $4$，此时 $a = \lbrack 42 , 36 , 52 \rbrack$。</li></ol><p>为行文方便，下文中用<strong>操作一</strong>代表题干中的操作一，用 $i$ <strong>号操作</strong>代指上面模拟时的编号 $i$。</p><p>之后考虑每一个操作二对其前面操作的影响，可以发现，$5$ 号操作相当于让前四个操作执行了 $4$ 次，而 $7$ 号操作相当于让 “前四个操作执行 $4$ 次” 这个操作再执行 $3$ 次，故前四个操作总共执行了 $12$ 次。</p><p>综上所述，<strong>操作二的本质即让前面的操作执行</strong> $val_i$ <strong>次</strong>。</p><p>定义执行 $T$ 次操作二之后 (下文简称 $T$ 时刻) 所有操作执行的次数为 $T$时刻的 <strong>叠乘系数</strong>，则对于上面的情况我们只需要维护这个叠乘系数即可，这可以通过倒着处理所有操作实现。</p><p>接下来继续考虑有操作三的情况，我们<strong>将每一个操作抽象为一个点，对于每一个操作三，我们将其向其所有子操作连边</strong>。因为题面已经提到不会出现递归，故<strong>完成后的图一定是一个</strong> $\text{DAG}，则我们可以通过 \text{dp}$ 计算每个操作之后叠乘系数将会乘上的值 $V_i$。</p><p>设在当前情况下第 $i$ 号操作会执行 $C_i$ 次，若 $i$ 号操作之后还有操作需要执行时，$C_i$ 将会乘上该操作之后所有操作的 $\prod V_j$。当其后面没有操作(即没有<strong>入</strong>度)，就可以对其进行更新并且将其删除。故对整张图进行拓扑排序，顺着拓扑序进行处理即可。</p><p>还有一个值得提到的细节就是<strong>若出现无用操作，则我们需要直接将其忽略</strong>，否则其产生的度数将对拓扑序产生影响。</p><p>剩下的细节详见代码。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><p>写的是真的丑……但感觉思路还是比较清晰的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , last;</span><br><span class="line">&#125;edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[M &lt;&lt; <span class="number">1</span>] , in[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;to , head[from]&#125;; head[from] = edge_num; in[to] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n , m , op[M] , val[M] , pla[M] , t[M];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[x] != <span class="number">-1</span>) <span class="keyword">return</span> t[x];</span><br><span class="line">    t[x] = <span class="number">1</span>;</span><br><span class="line">    PE(i , x)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        t[x] *= dfs(to) % HA; t[x] %= HA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans[M] , bas[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    rep(i , <span class="number">0</span> , n + m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    op[<span class="number">0</span>] = <span class="number">3</span> , bas[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> fro = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">int</span> cal = bas[fro];</span><br><span class="line">        <span class="keyword">if</span>(op[fro] == <span class="number">3</span>)&#123;</span><br><span class="line">            PE(i , fro)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">                bas[to] = (cal + bas[to]) % HA;</span><br><span class="line">                -- in[to];</span><br><span class="line">                <span class="keyword">if</span>(in[to] == <span class="number">0</span>) q.push(to);</span><br><span class="line">                cal = (cal * t[to]) % HA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[fro] == <span class="number">1</span>)&#123;</span><br><span class="line">            ans[pla[fro]] = val[fro] * cal + ans[pla[fro]] % HA;  </span><br><span class="line">            ans[pla[fro]] %= HA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;call3.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;call3.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="keyword">int</span> x; read(x);</span><br><span class="line">        op[i] = <span class="number">1</span> , t[i] = <span class="number">1</span>;</span><br><span class="line">        pla[i] = i , val[i] = x;</span><br><span class="line">        add_edge(<span class="number">0</span> , i);</span><br><span class="line">    &#125;</span><br><span class="line">    read(m);</span><br><span class="line">    rep(i , n + <span class="number">1</span> , n + m)&#123;</span><br><span class="line">        read(op[i]);</span><br><span class="line">        <span class="keyword">if</span>(op[i] == <span class="number">1</span>)&#123;</span><br><span class="line">            read(pla[i]) , read(val[i]);</span><br><span class="line">            t[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[i] == <span class="number">2</span>)&#123;</span><br><span class="line">            read(val[i]);</span><br><span class="line">            t[i] = val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[i] == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt , x; read(cnt);</span><br><span class="line">            rep(j , <span class="number">1</span> , cnt)&#123;</span><br><span class="line">                read(x); add_edge(i , x + n);</span><br><span class="line">            &#125;</span><br><span class="line">            t[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i , <span class="number">1</span> , n + m) dfs(i);</span><br><span class="line">    <span class="keyword">int</span> q; read(q);</span><br><span class="line">    rep(i , <span class="number">1</span> , q)&#123;</span><br><span class="line">        <span class="keyword">int</span> x; read(x);</span><br><span class="line">        add_edge(<span class="number">0</span> , n + x);</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span> , ans[i] % HA);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 图论 </tag>
            
            <tag> Luogu </tag>
            
            <tag> NOIP </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSP-S2020】动物园-题解</title>
      <link href="2020/11/16/luoguP7076/"/>
      <url>2020/11/16/luoguP7076/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>动物园里饲养了很多动物，饲养员小 A 会根据饲养动物的情况，按照《饲养指南》购买不同种类的饲料，并将购买清单发给采购员小 B。 </p><p>具体而言，动物世界里存在 $2^k$ 种不同的动物，它们被编号为 $0 \ldots 2^k − 1$。动物园里饲养了其中的 $n$ 种，其中第 $i$ 种动物的编号为 $a_i$。</p><p>《饲养指南》中共有 $m$ 条要求，第 $j$ 条要求形如“如果动物园中饲养着某种动物，满足其编号的二进制表示的第 $p_j$ 位为 $1$，则必须购买第 $q_j$ 种饲料”。其中饲料共有 $c$ 种，它们从 $1 \ldots c$ 编号。本题中我们将动物编号的二进制表示视为一个 $k$ 位 01 串，第 $0$ 位是最低位，第 $k − 1$ 位是最高位。 </p><p>根据《饲养指南》，小 A 将会制定饲料清单交给小 B，由小 B 购买饲料。清单形如一个 $c$ 位 01 串，第 $i$ 位为 $1$ 时，表示需要购买第 $i$ 种饲料；第 $i$ 位为 $0$ 时，表示不需要购买第 $i$ 种饲料。 实际上根据购买到的饲料，动物园可能可以饲养更多的动物。更具体地，如果将当前未被饲养的编号为 $x$ 的动物加入动物园饲养后，饲料清单没有变化，那么我们认为动物园当前还能饲养编号为 $x$ 的动物。</p><p>现在小 B 想请你帮忙算算，动物园目前还能饲养多少种动物。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含四个以空格分隔的整数 $n,~m,~c,~k$。</p><p>分别表示动物园中动物数量、《饲养指南》要求数、饲料种数与动物编号的二进制表示位数。 </p><p>第二行 $n$ 个以空格分隔的整数，其中第 $i$ 个整数表示 $a_i$。</p><p>接下来 $m$ 行，每行两个整数 $p_i,~q_i$ 表示一条要求。</p><p>数据保证所有 $a_i$ 互不相同，所有的 $q_i$ 互不相同。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅一行，一个整数表示答案。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 3 5 4 </span><br><span class="line">1 4 6</span><br><span class="line">0 3 </span><br><span class="line">2 4</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2 2 4 3</span><br><span class="line">1 2 </span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $20\%$ 的数据：$k \le n \le 5，m \le 10，c \le 10$，所有的 $p_i$ 互不相同。 </p><p>对于 $40\%$ 的数据：$n \le 15，k \le 20，m \le 20，c \le 20$。</p><p>对于 $60\%$ 的数据：$n \le 30，k \le 30，m \le 1000$。</p><p>对于 $100\%$ 的数据：$0 \le n,~m \le 10^6，0 \le k \le 64，1 \le c \le 10^8$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>u1s1，这才是真正的 T1</del></p><p>先想办法算出动物园中已经有的动物的二进制串，显然，直接把所有的 $a_i$ 或起来即可。</p><p>之后算限制，因为题目中已经规定所有的 $q_i$ 都不相同，故我们不需要记录具体的 $q_i$，只需要记录该位有没有要求即可。</p><p>然后去找哪些位是可以满足的，<strong>一个二进制位可以满足当且仅当这一位没有要求</strong>或者<strong>这一位在已有动物的二进制串中为</strong> $1$。</p><p>注意特判<strong>原本动物已经全部养满</strong>和<strong>原本一个动物都没有</strong>两种特殊情况，以及注意 $2^{64}$ 无法用 <code>unsigned long long</code> 存储，需要先计算 $2^{63} - n$ 之后加上 $2^{63}$</p><p>剩下的细节部分详见代码 <del>(虽然感觉也没啥细节)</del></p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ull n , m , c , k , a[M] , lim , hav , ans;</span><br><span class="line"></span><br><span class="line">ull p[M] , q[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n) , read(m) , read(c) , read(k);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        ull x; read(x);</span><br><span class="line">        hav |= x;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i , <span class="number">1</span> , m)&#123;</span><br><span class="line">        ull x , y; read(x) , read(y);</span><br><span class="line">        lim |= (<span class="number">1u</span>ll &lt;&lt; x);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i , <span class="number">0</span> , k)&#123;</span><br><span class="line">        ans += !((lim &gt;&gt; i) &amp; <span class="number">1</span>) || ((hav &gt;&gt; i) &amp; <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ans == <span class="number">65</span> &amp;&amp; n == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;18446744073709551616&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="number">1u</span>ll &lt;&lt; (ans - <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span> , ans - n + ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> Luogu </tag>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSP-S2020】儒略日-题解</title>
      <link href="2020/11/16/luoguP7075/"/>
      <url>2020/11/16/luoguP7075/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>为了简便计算，天文学家们使用儒略日（Julian day）来表达时间。</p><p>所谓儒略日，其定义为<strong>从公元前 4713 年 1 月 1 日正午 12 点到此后某一时刻间所经过的天数</strong>，不满一天者用小数表达。若利用这一天文学历法，则每一个时刻都将被均匀的映射到数轴上，从而得以很方便的计算它们的差值。</p><p>现在，给定一个不含小数部分的儒略日，请你帮忙计算出该儒略日（一定是某一天的中午 $12$ 点）所对应的公历日期。</p><p>我们现行的公历为格里高利历（Gregorian calendar），它是在公元 $1582$ 年由教皇格里高利十三世在原有的儒略历（Julian calendar）的基础上修改得到的（注：儒略历与儒略日并无直接关系）。具体而言，现行的公历日期按照以下规则计算：</p><ol><li><p>公元 $1582$ 年 $10$ 月 $15$ 日（含）以后：适用格里高利历，每年一月 $31$ 天、 二月 $28$ 天或 $29$ 天、三月 $31$ 天、四月 $30$ 天、五月 $31$ 天、六月 $30$ 天、七月 $31$ 天、八月 $31$ 天、九月 $30$ 天、十月 $31$ 天、十一月 $30$ 天、十二月 $31$ 天。其中，闰年的二月为 $29$ 天，平年为 $28$ 天。当年份是 $400$ 的倍数，或日期年份是 $4$ 的倍数但不是 $100$ 的倍数时，该年为闰年。</p></li><li><p>公元 $1582$ 年 $10$ 月 $5$ 日（含）至 $10$ 月 $14$ 日（含）：不存在，这些日期被删除，该年 $10$ 月 $4$ 日之后为 $10$ 月 $15$ 日。</p></li><li><p>公元 $1582$ 年 $10$ 月 $4$ 日（含）以前：适用儒略历，每月天数与格里高利历 相同，但只要年份是 $4$ 的倍数就是闰年。</p></li><li><p>尽管儒略历于公元前 $45$ 年才开始实行，且初期经过若干次调整，但今天人类习惯于按照儒略历最终的规则反推一切 $1582$ 年 $10$ 月 $4$ 日之前的时间。注意，公元零年并不存在，即公元前 $1$ 年的下一年是公元 $1$ 年。因此公元前 $1$ 年、前 $5$ 年、前 $9$ 年、前 $13$ 年……以此类推的年份应视为闰年。</p></li></ol><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $Q$，表示询问的组数。</p><p>接下来 $Q$ 行，每行一个非负整数 $r_i$ ，表示一个儒略日。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每一个儒略日 $r_i$ ，输出一行表示日期的字符串 $s_i$ 。共计 $Q$ 行。 $s_i$的格式如下：</p><p>若年份为公元后，输出格式为 <code>Day Month Year</code>。其中日（Day）、月（Month）、年（Year）均不含前导零，中间用一个空格隔开。</p><p>若年份为公元前，输出格式为 <code>Day Month Year BC</code>。其中年（Year）输出该年份的数值，其余与公元后相同。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10</span><br><span class="line">100</span><br><span class="line">1000</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">11 1 4713 BC</span><br><span class="line">10 4 4713 BC</span><br><span class="line">27 9 4711 BC</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2000000</span><br><span class="line">3000000</span><br><span class="line">4000000</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">14 9 763</span><br><span class="line">15 8 3501</span><br><span class="line">12 7 6239</span><br></pre></td></tr></table></figure><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>把这题放 T1 的组题人就该拖出去捶一顿算完</del></p><p>大模拟，但单纯 Day By Day 的模拟得分很低。</p><p>看数据范围不难发现需要 $O(1)$ 或 $O(\log n)$ 的回答单次询问，但 $O(1)$ 做法代码难度较大，且不方便考场调试。故笔者提供一种较为好写的 $O(q \log n)$ 做法。</p><p>考虑二分年份。确定年份之后，剩下的日期最多也就 $365$ 天，暴力处理即可。</p><p>考虑如何判断当前年份与目标年份的相对大小。显然，我们只需要计算当前天数到二分年份的 $1$ 月 $1$ 日的天数即可。</p><p>但直接做的话在进入公元时会出问题，因为公元 $0$ 年并不存在。为了避免使用公元 $0$ 年，我们考虑将公元前的年份前移一年，最后算完之后若在公元前则减去一年即可。</p><p>那么就有</p><script type="math/tex; mode=display">ans = 365 \times (x + 4712) + cnt - 10 \times [x > 1582]</script><p>其中 $cnt$ 为闰年的数目。</p><p>考虑如何快速计算闰年的数目。首先先算出 $4$ 的倍数的年数，即 $\lceil \frac{x + 4712}{4} \rceil$</p><p>之后减去 $1583$ 年之后的整百年份，即 $\lceil \frac{x - 1600}{100} \rceil$</p><p>之后加上 $1583$ 年之后能被 $400$ 整除的年份，即 $\lceil \frac{x - 1600}{400} \rceil$</p><p>还有什么的话，就是 <strong>所有变量都需要 long long</strong>。</p><p>题目细节较多，建议对照代码仔细理解。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">0</span> , y = <span class="number">-4713</span> , m = <span class="number">1</span> , d = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> days[] = &#123;<span class="number">0</span> , <span class="number">31</span> , <span class="number">28</span> , <span class="number">31</span> , <span class="number">30</span> , <span class="number">31</span> , <span class="number">30</span> , <span class="number">31</span> , <span class="number">31</span> , <span class="number">30</span> , <span class="number">31</span> , <span class="number">30</span> , <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_RUN</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;  <span class="comment">//判断闰年</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        x *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">4</span> == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="number">1582</span>) <span class="keyword">return</span> x % <span class="number">4</span> == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (x % <span class="number">400</span> == <span class="number">0</span>) || ((x % <span class="number">4</span> == <span class="number">0</span>) &amp;&amp; (x % <span class="number">100</span> != <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;    <span class="comment">//计算当前年份1月1日对应的天数</span></span><br><span class="line">    ll day = <span class="number">0</span>;</span><br><span class="line">    day += <span class="number">1l</span>l * (x + <span class="number">4712</span>) * <span class="number">365</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1582</span>) day -= <span class="number">10</span>;</span><br><span class="line">    day += <span class="number">1l</span>l * (x + <span class="number">4712</span> + <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">1600</span>)&#123;</span><br><span class="line">        x -= <span class="number">1601</span>;</span><br><span class="line">        day += x / <span class="number">400</span>;</span><br><span class="line">        day -= x / <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_day</span><span class="params">()</span></span>&#123; <span class="comment">//暴力模拟天数</span></span><br><span class="line">    d ++;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">1582</span> &amp;&amp; m == <span class="number">10</span> &amp;&amp; d == <span class="number">5</span>) d += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(d &gt; days[m] + (check_RUN(y) &amp;&amp; m == <span class="number">2</span>)) m ++ , d = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m &gt; <span class="number">12</span>) y ++ , m = <span class="number">1</span> , d = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; read(n);</span><br><span class="line">    m = <span class="number">1</span> , d = <span class="number">1</span>;</span><br><span class="line">    ll l = <span class="number">-4712</span> , r = <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;  </span><br><span class="line">        ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid) &gt; n)&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span> , y = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    n -= check(y);</span><br><span class="line">    <span class="keyword">if</span>(y &lt;= <span class="number">0</span>) y -= <span class="number">1</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , n) &#123;</span><br><span class="line">        get_day();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y &lt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld %lld BC\n&quot;</span> , d , m , -y);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld %lld \n&quot;</span> , d , m , y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t; read(t);</span><br><span class="line">    <span class="keyword">while</span>(t --) solve();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 二分 </tag>
            
            <tag> Luogu </tag>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【AGC002E】Candy Piles-题解</title>
      <link href="2020/11/06/AGC002E/"/>
      <url>2020/11/06/AGC002E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>桌上有 $n$ 堆糖果 , 其中第 $i$ 堆糖果有 $a_i$ 个糖。</p><p>Alice 与 Bob 在玩游戏，轮流进行，每次进行下列两个操作中的一个：</p><ul><li><p>将当前糖数最多的那堆糖果全部吃完</p></li><li><p>将每堆糖果吃掉一个</p></li></ul><p>吃掉最后一颗糖果的人败者，假设两人足够聪明，问先手还是后手必胜？</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有一个整数 $n$ 表示糖果的堆数。</p><p>接下来一行有 $n$ 个正整数，其中第 $i$ 个整数 $a_i$ 表示第 $i$ 堆糖果的数目。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出<code>First</code>（表示第一个人必胜），或<code>Second</code>（表示第二个人必胜）</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Second</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">First</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于 $100\%$ 的数据，满足 $1 \leq n \leq 10^5 , 1 \leq a_i \leq 10^9$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>思维难度较大的博弈。</p><p>题目中的第一个操作要求取走当前最多的糖果，且第二种操作不会改变糖果的相对大小，故我们先将数列 $a$ 进行降序排序。</p><p>举个栗子，设 $a = (7 , 6 , 7 , 4 , 7 , 4 , 2 , 4 , 2)$，则排过序之后就成了下面的样子：</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/13/uxC5ND.png" alt="a = (7 , 6 , 7 , 4 , 7 , 4 , 2 , 4 , 2)排序之后的结果"></p><p>考虑两种操作的本质。不难发现，<strong>消去最大值的实质就是消去最左边的一行，而全局减一的实质就是消去最下面的一行</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/13/uxCT9H.png" alt="两种操作的实质"></p><p>之后将其转换为网格图，设左下角为 $(0 , 0)$，就有了下面那张图。</p><p>想想上面两种操作在网格图上相当于什么？不难发现，<strong>消去最大值相当于在当前位置向右移一格，而全局减一相当于向上移一格</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/13/uxiGyn.png" alt="网格图"></p><p>显然，网格图的边界就相当于最后一颗糖果，为必败态。</p><p>根据引理可知：<strong>对于一场游戏，假设先后手公平，那么一个状态为必胜，当前仅当其能转移的状态有一个为必输；而一个状态为必输，当前仅当其能转移的状态均为必赢</strong>。</p><p>把引理套到题目上，就可知<strong>对于任意一个不在边界上的点，如果它的上面和右面都是必败点，则这个点是必胜点；否则为必败点。</strong></p><p>知道这个之后我们就可以建出这个网格图了(图中以○表示必败点，×表示必胜点)。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/13/uxite0.png" alt="建出后的网格图"></p><p>之后看一下原点是必胜还是必败，<strong>若为必胜则后手必胜，反之后手必败</strong>(因为先手会转移至原点右边或上边的点，即 $(1 , 0)$ 或 $(0 , 1)$。故这两个点才是先手的状态点)。</p><p>但这样建图复杂度为 $O(n^2)$ 的，无法通过本题。</p><p>考虑找规律，不难发现<del>(不难个鬼)</del><strong>除边界外，图上对角线的胜败状态一致。</strong></p><p>故我们可以找到以原点为左下角的最大正方形，之后看其右上角到两个边界的距离，若其中一个为奇数则该点为必败点，否则为必胜点</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/13/uxiNwV.png" alt="规律及做法"></p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , a[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n);</span><br><span class="line">    rep(i , <span class="number">1</span> , n) read(a[i]);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    rep(i , <span class="number">1</span> , n)</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; a[j + i + <span class="number">1</span>] == i; ++j);</span><br><span class="line">            <span class="keyword">if</span> (((a[i] - i) &amp; <span class="number">1</span>) || (j &amp; <span class="number">1</span>)) <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> AtCoder </tag>
            
            <tag> 乱搞 </tag>
            
            <tag> 多校联考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HDU4597】Play Game-题解</title>
      <link href="2020/11/03/HDU4597/"/>
      <url>2020/11/03/HDU4597/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>Alice 和 Bob 在玩游戏。</p><p>有两堆卡片。每一堆有 $n$ 张牌，每一张牌都有一个分数。</p><p>他们轮流从任何一堆中拿起最上面或最下面的一张牌，这张牌的分数将加到他的总分中。</p><p>Alice 和 Bob都够聪明，他们都会以最优方式拿起卡片从而尽可能多地得分。</p><p>请你求出来如果 Alice 先手能得多少分。</p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目中告诉我们取牌必须从序列的两段取出，故我们保留的牌堆一定是一段连续的区间</p><p>设 $f[i][j][l][r]$ 表示对于第一堆牌保留的区间为 $i$ 到 $j$ ，第二堆保留的为 $l$ 到 $r$ 时 Alice 的最大得分。</p><p>递推的话需要考虑的情况较多，故我们采用记忆化搜索实现代码。</p><p>但在搜索时有一个细节：每一次拓展时取牌的人会更换，故拓展时拓展出的是 Bob 所能获得的最大得分。而最后 Alice 的得分是总分数减去 Bob 的分数。故最后的答案是：</p><script type="math/tex; mode=display">ans = max \lbrack sum - dfs(sum - tot) \rbrack</script><p>其中 $tot$ 为被取走的牌，需要分四种情况进行讨论。</p><p>剩下的细节详见代码。</p><hr><h3 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , a[M] , b[M] , f[<span class="number">30</span>][<span class="number">30</span>][<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//f[i][j][l][r] 对于第一堆牌保留的区间为 $i$ 到 $j$ ，第二堆保留的为 $l$ 到 $r$ 时先手的最大得分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> al , <span class="keyword">int</span> ar , <span class="keyword">int</span> bl , <span class="keyword">int</span> br , <span class="keyword">int</span> sm)</span></span>&#123;    </span><br><span class="line"><span class="keyword">if</span>(f[al][ar][bl][br]) <span class="keyword">return</span> f[al][ar][bl][br];    <span class="comment">//如果已经搜到过，则直接返回结果</span></span><br><span class="line"><span class="keyword">if</span>(al &gt; ar &amp;&amp; bl &gt; br) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//若无牌可取，则返回0</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(al &lt;= ar)&#123;    </span><br><span class="line">ans = max(ans , sm - dfs(al + <span class="number">1</span> , ar , bl , br , sm - a[al])); </span><br><span class="line"><span class="comment">//注意：此时拓展的为 Bob 的最大得分，而 Alice 的最大得分为 sm - Bob的最大得分，</span></span><br><span class="line">ans = max(ans , sm - dfs(al , ar - <span class="number">1</span> , bl , br , sm - a[ar]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bl &lt;= br)&#123;</span><br><span class="line">ans = max(ans , sm - dfs(al , ar , bl + <span class="number">1</span> , br , sm - b[bl]));</span><br><span class="line">ans = max(ans , sm - dfs(al , ar , bl , br - <span class="number">1</span> , sm - b[br]));</span><br><span class="line">&#125;</span><br><span class="line">f[al][ar][bl][br] = ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">read(n);</span><br><span class="line">ll sm = <span class="number">0</span>;</span><br><span class="line">rep(i , <span class="number">1</span> , n) read(a[i]) , sm += a[i];</span><br><span class="line">rep(i , <span class="number">1</span> , n) read(b[i]) , sm += b[i];</span><br><span class="line"></span><br><span class="line">clean(f , <span class="number">0</span>);</span><br><span class="line">ll res = dfs(<span class="number">1</span> , n , <span class="number">1</span> , n , sm);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> t; read(t);</span><br><span class="line"><span class="keyword">while</span>(t --) solve();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 多校联考 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 记忆化搜索 </tag>
            
            <tag> HDU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法笔记】01-Trie的维护与应用</title>
      <link href="2020/11/02/01Trie/"/>
      <url>2020/11/02/01Trie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法起源"><a href="#算法起源" class="headerlink" title="算法起源"></a>算法起源</h1><p>在算法竞赛中，我们经常会碰到一些与<strong>异或运算</strong>(即 C++ 中 <code>^</code>) 相关的题目，其套路在于<strong>按位考虑，即将十进制数拆为二进制数后进行计算</strong>。</p><p>但对于二进制位的直接维护并不是一件方便的事。故我们将字典树修改为 $\text{01-Trie}$，方便对二进制位进行维护与查询。</p><hr><h1 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h1><p>$\text{01-Trie}$ 的应用主要有两种，一是维护异或极值，二是维护异或和。</p><h2 id="维护异或极值"><a href="#维护异或极值" class="headerlink" title="维护异或极值"></a>维护异或极值</h2><p>为方便讲述，我们先引入一道例题：<a href="https://www.luogu.com.cn/problem/P4551">Luogu P4551 最长异或路径</a></p><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一颗 $n$ 个点的树，边有边权，求出两个点 $u$ 与 $v$ 使得 $u$ 到 $v$ 路径上的边权异或和最大。</p><p>$1 \leq n \leq 10^5$，边权的范围为 $\lbrack 0 , 2^{31} \rbrack$。</p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>(由于异或没有较为统一的符号表示，本文中统一使用 $\oplus$ 表示异或运算)。</p><p>设 $X(u , v)$ 表示 $u$ 到 $v$ 路径上的边权异或和。</p><p>众所周知，异或具有可抵消的特点，即 $a \oplus a = 0$。</p><p>故</p><script type="math/tex; mode=display">X(u , v) = X(root , u) \oplus X(root , v)</script><p>而 $X(root , i) , i \in \lbrack 1 , n \rbrack$ 可以用一遍 $\text{dfs}$ 在 $O(n)$ 的时间复杂度内与处理出来。</p><p>之后将 $X(root , i) , i \in \lbrack 1 , n \rbrack$ 全部插入到 $\text{01-Trie}$ 中，插入代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ch[M][<span class="number">2</span>] , cnt = <span class="number">1</span>; <span class="comment">//ch[i][0/1] 表示i号节点的两个儿子的编号，ch[i][0] 指下一位为0，ch[i][1] 指下一位为1</span></span><br><span class="line"><span class="comment">//cnt 指节点数目，由于 Trie 树初始时有一个无实际意义的根节点，故初始化为1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = ((x &gt;&gt; i) &amp; <span class="number">1</span>); <span class="comment">//取出二进制上第i位的数</span></span><br><span class="line">        <span class="keyword">if</span>(ch[now][t]) now = ch[now][t];  <span class="comment">//如果有的话，就直接走过去即可</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ch[now][t] = ++ cnt;    <span class="comment">//否则就新建一个</span></span><br><span class="line">            now = ch[now][t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的问题是如何查询，考虑一下按位异或的定义</p><ul><li>对于两个数的所有二进制位从后向前进行比较，若相同则为 $0$，不同则为 $1$。</li></ul><p>且二进制数的相对大小取决于高位，即<strong>高位大的一定大</strong>。故我们只需要根据高位进行贪心，让位于高位的两个二进制数尽量不同即可。查询代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span> , ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = ((x &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ch[now][t ^ <span class="number">1</span>]) now = ch[now][t ^ <span class="number">1</span>] , ans = (<span class="number">1</span> &lt;&lt; i);   <span class="comment">//如果两个二进制数可以不同，则设为不同，且记录答案</span></span><br><span class="line">        <span class="keyword">else</span> now = ch[now][t];  <span class="comment">//否则只能相同了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Code-Luogu-P4551"><a href="#Code-Luogu-P4551" class="headerlink" title="Code[Luogu P4551]"></a>Code[Luogu P4551]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to , last;</span><br><span class="line">ll dis;</span><br><span class="line">&#125;edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , ll dis)</span></span>&#123;</span><br><span class="line">edge[++ edge_num] = (Edge)&#123;to , head[from] , dis&#125;; head[from] = edge_num;</span><br><span class="line">edge[++ edge_num] = (Edge)&#123;from , head[to] , dis&#125;; head[to] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[M] , dis[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">fa[x] = f;</span><br><span class="line">PE(i , x)&#123;</span><br><span class="line"><span class="keyword">int</span> to = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(to == f) <span class="keyword">continue</span>;</span><br><span class="line">dis[to] = (dis[x] ^ edge[i].dis);</span><br><span class="line">dfs(to , x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Trie&#123; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) ch[x][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) ch[x][1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[M &lt;&lt; <span class="number">5</span>][<span class="number">2</span>] , cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">per(i , <span class="number">30</span> , <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> t = ((x &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ch[now][t]) now = ch[now][t];</span><br><span class="line"><span class="keyword">else</span> ch[now][t] = ++ cnt , now = ch[now][t];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">1</span> , ans = <span class="number">0</span>;</span><br><span class="line">per(i , <span class="number">30</span> , <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> t = ((x &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ch[now][t ^ <span class="number">1</span>]) now = ch[now][t ^ <span class="number">1</span>] , ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line"><span class="keyword">else</span> now = ch[now][t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lson</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rson</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Trie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> n; read(n);</span><br><span class="line">rep(i , <span class="number">1</span> , n - <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> u , v; ll w;</span><br><span class="line">read(u) , read(v) , read(w);</span><br><span class="line">add_edge(u , v , w);</span><br><span class="line">&#125;</span><br><span class="line">dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">dfs(<span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">insert(dis[i]);</span><br><span class="line">&#125;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line">rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">res = max(res , <span class="number">1l</span>l * query(dis[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="维护异或和"><a href="#维护异或和" class="headerlink" title="维护异或和"></a>维护异或和</h2><p>$\text{01-Trie}$ 用于维护数字异或和时可支持插入，删除和全局加一(即让维护的所有数值 $+1$)。<strong>维护时需要按值从低位到高位建树</strong></p><p>且在维护异或和时，我们<strong>仅需要知道某一位上</strong> $0$ <strong>与</strong> $1$ <strong>数目的奇偶性即可</strong>，也就是说，<strong>对于某一位上的</strong> $1$ <strong>而言，当且仅当这一位上数字</strong> $1$ <strong>的个数为奇数个时，这一位上的数字才是</strong> $1$。并不需要知道我们维护了哪些数字。</p><p>举个例子：</p><script type="math/tex; mode=display">(10)_2 = 1010</script><script type="math/tex; mode=display">(12)_2 = 1100</script><script type="math/tex; mode=display">(14)_2 = 1110</script><script type="math/tex; mode=display">(10 \oplus 12 \oplus 14)_2 = 1000 = (8)_{10}</script><p>其中最高位上数字 $1$ 的个数为 $3$ ，是个奇数，故最后结果中最高位为 $1$，而后面三位中 $1$ 的个数分别为 $2 , 2 , 0$，均不为奇数，故最后结果中后面三位均为 $0$。</p><hr><h3 id="单节点维护"><a href="#单节点维护" class="headerlink" title="单节点维护"></a>单节点维护</h3><p>对于每一个节点，我们需要维护以下三个信息：</p><ul><li><p><code>ch[x][0] &amp; ch[x][1]</code> 即左右儿子，<code>ch[x][0]</code> 代表下一位是 $0$ ，<code>ch[x][1]</code> 代表下一位是 $1$。</p></li><li><p><code>w[x]</code> 指节点 $x$ 到其父亲节点这条边的权值。每当插入一个数字 $n$ 时，$n$ 二进制拆分后在 $\text{01-Trie}$ 上的权值都会 $+1$。</p></li><li><p><code>xorv[x]</code> 指以 $x$ 为根节点的子树维护的异或和。</p></li></ul><p>代码也很好写：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    w[x] = xorv[x] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span>(ch[x][<span class="number">0</span>])&#123;  </span><br><span class="line">        w[x] += w[ch[x][<span class="number">0</span>]];</span><br><span class="line">        xorv[x] ^= (xorv[ch[x][<span class="number">0</span>]] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ch[x][<span class="number">1</span>])&#123;</span><br><span class="line">        w[x] += w[ch[x][<span class="number">0</span>]];</span><br><span class="line">        xorv[x] ^= (xorv[ch[x][<span class="number">0</span>]] &lt;&lt; <span class="number">1</span>) | (w[ch[x][<span class="number">1</span>] &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="插入-amp-删除"><a href="#插入-amp-删除" class="headerlink" title="插入 &amp; 删除"></a>插入 &amp; 删除</h3><p>插入与删除操作也很容易，首先，我们维护一个最大深度 $H$，强行把每个叶子节点到根的距离设置为 $H$，以方便之后的进位处理。</p><p>之后按位插入并修改叶子节点的 <code>w[x]</code> 即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> H = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mknode</span><span class="params">()</span></span>&#123;   <span class="comment">//新建一个节点</span></span><br><span class="line">    cnt ++ , ch[cnt][<span class="number">0</span>] = ch[cnt][<span class="number">1</span>] = w[cnt] = xorv[cnt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x , <span class="keyword">int</span> val , <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) x = mknode();    <span class="comment">//如果当前没有这个节点，就新建一个</span></span><br><span class="line">    <span class="keyword">if</span>(dep &gt; H) <span class="keyword">return</span> (<span class="keyword">void</span>)(w[x] ++); <span class="comment">//如果到了叶子节点，就修改 w[x]</span></span><br><span class="line">    insert(ch[x][val &amp; <span class="number">1</span>] , val &gt;&gt; <span class="number">1</span> , dep + <span class="number">1</span>);    <span class="comment">//否则递归处理 val 的每一位</span></span><br><span class="line">    update(x);  <span class="comment">//之后合并节点两个子树的信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> val , <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep &gt; H) <span class="keyword">return</span> (<span class="keyword">void</span>)(w[x] --);<span class="comment">//同上</span></span><br><span class="line">    Delete(ch[x][val &amp; <span class="number">1</span>] , val &gt;&gt; <span class="number">1</span> , dep + <span class="number">1</span>);</span><br><span class="line">    update(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>$\text{01-Trie}$ 的合并类似于线段树合并，分三种情况讨论一下即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b) <span class="keyword">return</span> a + b;  <span class="comment">//若 a 与 b 的任意一颗子树为空，则直接返回即可</span></span><br><span class="line"></span><br><span class="line">    xorv[a] ^= xorv[b];</span><br><span class="line">    w[a] += w[b];</span><br><span class="line"></span><br><span class="line">    ch[a][<span class="number">0</span>] = merge(ch[a][<span class="number">0</span>] , ch[b][<span class="number">0</span>]);  <span class="comment">//分别合并左右子树</span></span><br><span class="line">    ch[a][<span class="number">1</span>] = merge(ch[a][<span class="number">1</span>] , ch[b][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="全局-1"><a href="#全局-1" class="headerlink" title="全局+1"></a>全局+1</h3><p>思考一下二进制意义下的 $+1$ 是如何操作的？</p><p>我们只需要从低位到高位找出第一个出现的 $0$ ，将其变为 $1$ ，之后把这个位置后面的 $1$ 都变为 $0$ 即可。</p><p>举个几个例子：</p><script type="math/tex; mode=display">(0111)_2 + 1 = (1000)_2</script><script type="math/tex; mode=display">(11000)_{2} + 1 = (11001)_{2}</script><script type="math/tex; mode=display">(1110010)_{2} + 1 = (1110011)_{2}</script><p>而对应到 $\text{01-Trie}$ 上就是交换左右儿子，之后顺着<strong>交换后</strong>的左儿子向下递归操作即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    swap(ch[x][<span class="number">0</span>] , ch[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[x][<span class="number">0</span>]) add1(ch[x][<span class="number">0</span>]);</span><br><span class="line">    update(x);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="例题-联合省选2020-A卷-树"><a href="#例题-联合省选2020-A卷-树" class="headerlink" title="例题:[联合省选2020 A卷] 树"></a>例题:[联合省选2020 A卷] 树</h3><p>下面我们以<a href="https://www.luogu.com.cn/problem/P6623">Luogu P6623 [联合省选2020 A卷] 树</a>为例题，实地练习一下 $\text{01-Trie}$ 维护异或和。</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一颗 $n$ 个的点的有根树，节点从 $1$ 开始编号且以 $1$ 为根，每个点有点权，记为 $v[i]$。</p><p>设 $x$ 号结点的子树内（包含 $x$ 自身）的所有结点编号为 $c_1, c_2, \dots, c_k$，定义 $x$ 的价值为：</p><p>定义节点 $x$ 的价值为：</p><script type="math/tex; mode=display">val(x) = (v_{c_1} + d(c_1, x)) \oplus (v_{c_2} + d(c_2, x)) \oplus \cdots \oplus (v_{c_k} + d(c_k, x))</script><p>其中 $d(x, y)$ 表示树上 $x$ 号结点与 $y$ 号结点间唯一简单路径所包含的边数，$d(x, x) = 0$。</p><p>请你求出 $\sum_{i=1}^n val(i)$ 的结果。</p><hr><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><del>省选赛场上胡了个换根，然后胡没了。</del></p><p>先考虑一下最无脑的 $10$ 分暴力怎么写：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span> , x = i;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">val[x] ^= (cnt + v[i]);</span><br><span class="line">cnt ++;</span><br><span class="line">x = fa[x];</span><br><span class="line">&#125;<span class="keyword">while</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) ans += val[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans);</span><br></pre></td></tr></table></figure><p>很明显，这段代码就是在枚举每个点并计算其对其祖先的贡献。</p><p>考虑使用 $\text{01-Trie}$ 来加速这个过程。</p><p>我们对每个节点均建立一颗 $\text{01-Trie}$。初始时只存了这个节点的权值。</p><p>每一次操作，我们自底而上的合并每个子节点，之后全局 $+1$，统计答案即可。</p><hr><h3 id="Code-Luogu-P6623"><a href="#Code-Luogu-P6623" class="headerlink" title="Code[Luogu P6623]"></a>Code[Luogu P6623]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">530000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , val[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to , last;</span><br><span class="line">&#125;edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">edge[++ edge_num] = (Edge)&#123;to , head[from]&#125;; head[from] = edge_num;</span><br><span class="line">edge[++ edge_num] = (Edge)&#123;from , head[to]&#125;; head[to] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Trie&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) ch[x][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) ch[x][1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> H = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[M * H][<span class="number">2</span>] , w[M * H] , xorv[M * H] , cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mknode</span><span class="params">()</span></span>&#123;</span><br><span class="line">cnt ++ , ch[cnt][<span class="number">0</span>] = ch[cnt][<span class="number">1</span>] = w[cnt] = xorv[cnt] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">w[x] = xorv[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(lson(x))&#123;</span><br><span class="line">w[x] += w[lson(x)];</span><br><span class="line">xorv[x] ^= (xorv[lson(x)] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rson(x))&#123;</span><br><span class="line">w[x] += w[rson(x)];</span><br><span class="line">xorv[x] ^= ((xorv[rson(x)] &lt;&lt; <span class="number">1</span>) | (w[rson(x)] &amp; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">w[x] &amp;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x , <span class="keyword">int</span> val , <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x) x = mknode();</span><br><span class="line"><span class="keyword">if</span>(dep &gt; H) <span class="keyword">return</span> (<span class="keyword">void</span>)(w[x] ++);</span><br><span class="line">insert(ch[x][val &amp; <span class="number">1</span>] , val &gt;&gt; <span class="number">1</span> , dep + <span class="number">1</span>);</span><br><span class="line">update(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> val , <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dep &gt; <span class="number">20</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(w[x] --);</span><br><span class="line">erase(ch[x][val &amp; <span class="number">1</span>] , val &gt;&gt; <span class="number">1</span> , dep + <span class="number">1</span>);</span><br><span class="line">update(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">swap(lson(x) , rson(x));</span><br><span class="line"><span class="keyword">if</span>(lson(x)) add1(lson(x));</span><br><span class="line">update(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!a || !b) <span class="keyword">return</span> a + b;</span><br><span class="line">w[a] = w[a] + w[b];</span><br><span class="line">xorv[a] ^= xorv[b];</span><br><span class="line">lson(a) = merge(lson(a) , lson(b));</span><br><span class="line">rson(a) = merge(rson(a) , rson(b));</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lson</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rson</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Trie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rt[M];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">PE(i , x)&#123;</span><br><span class="line"><span class="keyword">int</span> to = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(to == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(to , x);</span><br><span class="line">rt[x] = merge(rt[x] , rt[to]);</span><br><span class="line">&#125;</span><br><span class="line">add1(rt[x]);</span><br><span class="line">insert(rt[x] , val[x] , <span class="number">0</span>);</span><br><span class="line">ans += xorv[rt[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n);</span><br><span class="line">    rep(i , <span class="number">1</span> , n) read(val[i]);</span><br><span class="line">    rep(i , <span class="number">2</span> , n)&#123;</span><br><span class="line"><span class="keyword">int</span> x; read(x);</span><br><span class="line">add_edge(x , i);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Trie树 </tag>
            
            <tag> 异或 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSP-S2019】Emiya家今天的饭-题解</title>
      <link href="2020/10/29/luoguP5664/"/>
      <url>2020/10/29/luoguP5664/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>Emiya 是个擅长做菜的高中生，他共掌握 $n$ 种<strong>烹饪方法</strong>，且会使用 $m$ 种<strong>主要食材</strong>做菜。为了方便叙述，我们对烹饪方法从 $1 \sim n$ 编号，对主要食材从 $1 \sim m$ 编号。</p><p>Emiya 做的每道菜都将使用<strong>恰好一种</strong>烹饪方法与<strong>恰好一种</strong>主要食材。更具体地，Emiya 会做 $a_{i,j}$ 道不同的使用烹饪方法 $i$ 和主要食材 $j$ 的菜 $(1\le i\le n, 1\le j\le m)$ ，这也意味着 Emiya 总共会做菜的数目为：</p><script type="math/tex; mode=display">\displaystyle \sum_{i = 1}^n \sum_{j = 1}^m a_{i,j}</script><p>Emiya 今天要准备一桌饭招待 Yazid 和 Rin 这对好朋友，然而三个人对菜的搭配有不同的要求，更具体地，对于一种包含 $k$ 道菜的搭配方案而言:</p><ul><li><p>Emiya 不会让大家饿肚子，所以将做<strong>至少一道菜</strong>，即 $k \ge 1$</p></li><li><p>Rin 希望品尝不同烹饪方法做出的菜，因此她要求每道菜的<strong>烹饪方法互不相同</strong></p></li><li><p>Yazid 不希望品尝太多同一食材做出的菜，因此他要求每种<strong>主要食材</strong>至多在<strong>一半</strong>的菜（即 $\lfloor \frac k2 \rfloor$ 道菜）中被使用</p><ul><li>这里的 $\lfloor x\rfloor$ 为下取整函数，表示不超过 $x$ 的最大整数</li></ul></li></ul><p>这些要求难不倒 Emiya，但他想知道共有多少种不同的符合要求的搭配方案。两种方案不同，当且仅当存在至少一道菜在一种方案中出现，而不在另一种方案中出现。</p><p>Emiya 找到了你，请你帮他计算，你只需要告诉他符合所有要求的搭配方案数对质数 $998,244,353$ 取模的结果。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>从文件 <code>meal.in</code> 中读入数据。</p><p>第 $1$ 行两个用单个空格隔开的整数 $n, m$。</p><p>第 $2$ 行至第 $n + 1$ 行，每行 $m$ 个用单个空格隔开的整数，其中第 $i + 1$ 行的 $m$ 个数依次为 $a<em>{i,1}, a</em>{i,2}, \dots, a_{i,m}$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出到文件 <code>meal.out</code> 中。 仅一行一个整数，表示所求方案数对 $998,244,353$ 取模的结果。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 0 1</span><br><span class="line">0 1 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例解释-1"><a href="#样例解释-1" class="headerlink" title="样例解释 1"></a>样例解释 1</h3><p>由于在这个样例中，对于每组 $i, j$，Emiya 都最多只会做一道菜，因此我们直接通过给出烹饪方法、主要食材的编号来描述一道菜。</p><p>符合要求的方案包括：</p><ul><li>做一道用烹饪方法 $1$、主要食材 $1$ 的菜和一道用烹饪方法 $2$、主要食材 $2$ 的菜</li><li>做一道用烹饪方法 $1$、主要食材 $1$ 的菜和一道用烹饪方法 $2$、主要食材 $3$ 的菜</li><li>做一道用烹饪方法 $1$、主要食材 $3$ 的菜和一道用烹饪方法 $2$、主要食材 $2$ 的菜</li></ul><p>因此输出结果为 $3 \bmod 998,244,353 = 3$。 需要注意的是，所有只包含一道菜的方案都是不符合要求的，因为唯一的主要食材在超过一半的菜中出现，这不满足 Yazid 的要求。</p><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">4 5 0</span><br><span class="line">6 0 0</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">190</span><br></pre></td></tr></table></figure><h3 id="样例解释-2"><a href="#样例解释-2" class="headerlink" title="样例解释 2"></a>样例解释 2</h3><p>Emiya 必须至少做 $2$ 道菜。</p><p>做 $2$ 道菜的符合要求的方案数为 $100$。</p><p>做 $3$ 道菜的符合要求的方案数为 $90$。</p><p>因此符合要求的方案数为 $100 + 90 = 190$。</p><h3 id="Input-‘s-eg-3"><a href="#Input-‘s-eg-3" class="headerlink" title="Input ‘s eg 3"></a>Input ‘s eg 3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 0 0 1 1</span><br><span class="line">0 1 0 1 0</span><br><span class="line">1 1 1 1 0</span><br><span class="line">1 0 1 0 1</span><br><span class="line">0 1 1 0 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-3"><a href="#Output-‘s-eg-3" class="headerlink" title="Output ‘s eg 3"></a>Output ‘s eg 3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">742</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><div class="table-container"><table><thead><tr><th style="text-align:center">测试点编号</th><th style="text-align:center">$n=$</th><th style="text-align:center">$m=$</th><th style="text-align:center">$a_{i,j}&lt;$</th></tr></thead><tbody><tr><td style="text-align:center">$1$</td><td style="text-align:center">$2$</td><td style="text-align:center">$2$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center">$2$</td><td style="text-align:center">$2$</td><td style="text-align:center">$3$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center">$3$</td><td style="text-align:center">$5$</td><td style="text-align:center">$2$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center">$4$</td><td style="text-align:center">$5$</td><td style="text-align:center">$3$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center">$5$</td><td style="text-align:center">$10$</td><td style="text-align:center">$2$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center">$6$</td><td style="text-align:center">$10$</td><td style="text-align:center">$3$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center">$7$</td><td style="text-align:center">$10 $</td><td style="text-align:center">$2$</td><td style="text-align:center">$1000$</td></tr><tr><td style="text-align:center">$8$</td><td style="text-align:center">$10 $</td><td style="text-align:center">$3$</td><td style="text-align:center">$1000$</td></tr><tr><td style="text-align:center">$9\sim 12$</td><td style="text-align:center">$40$</td><td style="text-align:center">$2$</td><td style="text-align:center">$1000$</td></tr><tr><td style="text-align:center">$13\sim 16$</td><td style="text-align:center">$40$</td><td style="text-align:center">$3$</td><td style="text-align:center">$1000$</td></tr><tr><td style="text-align:center">$17\sim 21$</td><td style="text-align:center">$40$</td><td style="text-align:center">$500$</td><td style="text-align:center">$1000$</td></tr><tr><td style="text-align:center">$22\sim 25$</td><td style="text-align:center">$100$</td><td style="text-align:center">$2000$</td><td style="text-align:center">$998,244,353$</td></tr></tbody></table></div><p>对于所有测试点，保证 $1 \le n \le 100$，$1 \le m \le 2000$，$0 \le a_{i,j} &lt; 998,244,353$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>去年 Day2 考场上看 T1 是组合想都没想就写了个十来分的暴力扔了，现在发现仔细想想就有 64 分……</del></p><h3 id="64pts"><a href="#64pts" class="headerlink" title="64pts"></a>64pts</h3><p>观察一下数据范围，不难发现测试点 $1$ 到 $16$ 的 $m \leq 3$ ，即最多只有三种食材。</p><p>那我们不妨设 $f[i][j][k][l]$ 表示对于前 $i$ 种烹饪方法，用食材一做 $j$ 道菜，食材二做 $k$ 道菜，食材三做 $l$ 道菜的方案数，之后大力 $\text{dp}$ 即可。</p><p>时间复杂度 $O(n^4)$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n , m , a[<span class="number">50</span>][<span class="number">50</span>]; </span><br><span class="line">ll f[<span class="number">50</span>][<span class="number">50</span>][<span class="number">50</span>][<span class="number">50</span>];<span class="comment">//f[i][j][k][l] 对于前i种烹饪方式，选择j道食材1，k食材2，l食材3的2方案数目 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n) , read(m);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">rep(j , <span class="number">1</span> , m)&#123;</span><br><span class="line">read(a[i][j]); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">rep(j , <span class="number">0</span> , i)&#123;</span><br><span class="line">rep(k , <span class="number">0</span> , i)&#123;</span><br><span class="line">rep(l , <span class="number">0</span> , i)&#123;</span><br><span class="line">f[i][j][k][l] += f[i - <span class="number">1</span>][j][k][l] % HA , f[i][j][k][l] %= HA;</span><br><span class="line"><span class="keyword">if</span>(j) f[i][j][k][l] += (f[i - <span class="number">1</span>][j - <span class="number">1</span>][k][l] * a[i][<span class="number">1</span>]) % HA , f[i][j][k][l] %= HA;</span><br><span class="line"><span class="keyword">if</span>(k) f[i][j][k][l] += (f[i - <span class="number">1</span>][j][k - <span class="number">1</span>][l] * a[i][<span class="number">2</span>]) % HA , f[i][j][k][l] %= HA;</span><br><span class="line"><span class="keyword">if</span>(l) f[i][j][k][l] += (f[i - <span class="number">1</span>][j][k][l - <span class="number">1</span>] * a[i][<span class="number">3</span>]) % HA , f[i][j][k][l] %= HA;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line">rep(i , <span class="number">0</span> , n / <span class="number">2</span>)&#123;</span><br><span class="line">rep(j , <span class="number">0</span> , n / <span class="number">2</span>)&#123;</span><br><span class="line">rep(k , <span class="number">0</span> , n / <span class="number">2</span>)&#123;</span><br><span class="line">ll lim = (i + j + k) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(i &gt; lim || j &gt; lim || k &gt; lim) <span class="keyword">continue</span>;</span><br><span class="line">res += f[n][i][j][k] , res %= HA;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , (res - <span class="number">1</span>) % HA);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="84pts"><a href="#84pts" class="headerlink" title="84pts"></a>84pts</h3><p>后面的测试点 $m$ 变的很大，已经难以直接维护合法的方案数目了。</p><p>正难则补，则我们维护不合法的方案数目，之后用总方案数减去即可。</p><p>考虑不合法方案的特点：<strong>不合法的方案会有且仅有一种食材的使用次数大于总菜数的一半</strong>，则我们考虑钦定一种食材作为这个食材，为了下文叙述方便，我们称其为<strong>主菜</strong></p><p>设 $f[i][j][k]$ 表示对于前 $i$ 种烹饪方法，做了 $j$ 到菜，有 $k$ 到是主菜的方案数，$sum[i]$ 表示第 $i$ 种烹饪方法能够做出的总菜数，且前作为主菜的原料为 $l$ 。则有三种不同的决策，分别是<strong>第</strong> $i$ <strong>种烹饪方式不选，选它做主菜，选它做副菜</strong>，写成方程，就是：</p><script type="math/tex; mode=display">f[i][j][k] = f[i - 1][j][k] + f[i - 1][j - 1][k - 1] \times a[i][l] + f[i - 1][j - 1][k] \times a[i][l]</script><p>其中，不合法的方案数为：</p><script type="math/tex; mode=display">\sum_{j < 2k} f[n][j][k]</script><p>之后用总方案数减一下即可。</p><p>这样时间复杂度是 $O(m \times n^3)$ 的，无法通过本题，但可以拿到 $84$ 分的好成绩。</p><hr><h3 id="100pts"><a href="#100pts" class="headerlink" title="100pts"></a>100pts</h3><p>满分做法实际上是在 $84$ 分的基础上进行优化。</p><p>移一下项，则 $j &lt; 2k$ 相当于 $2k - j &gt; 0$。设 $j’ = 2k - j$，则我们只需要表示 $f[i][j’]$ 的结果即可。</p><p>但 $2k - j$ 可能是负数，因此我们需要数组平移。</p><p>时间复杂度 $O(m \times n^2)$，足以通过本题。</p><p>剩下的细节详见下方代码。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n , m , a[<span class="number">105</span>][<span class="number">2005</span>]; </span><br><span class="line"></span><br><span class="line">ll sum[<span class="number">105</span>];</span><br><span class="line">ll f[<span class="number">105</span>][<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n) , read(m);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">rep(j , <span class="number">1</span> , m)&#123;</span><br><span class="line">read(a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll cnt = <span class="number">1</span>;</span><br><span class="line">rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">rep(j , <span class="number">1</span> , m)&#123;</span><br><span class="line">sum[i] += a[i][j] , sum[i] %= HA;</span><br><span class="line">&#125;</span><br><span class="line">cnt *= (sum[i] + <span class="number">1</span>) % HA , cnt %= HA;</span><br><span class="line">&#125;</span><br><span class="line">ll del = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CON = <span class="number">105</span>;</span><br><span class="line">    rep(k , <span class="number">1</span> , m)&#123;</span><br><span class="line">    clean(f , <span class="number">0</span>) , f[<span class="number">0</span>][CON] = <span class="number">1</span>;</span><br><span class="line">rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = CON - i; j &lt;= CON + i; j ++)&#123;</span><br><span class="line">f[i][j] = f[i - <span class="number">1</span>][j] % HA;</span><br><span class="line"><span class="keyword">if</span>(j) f[i][j] += f[i - <span class="number">1</span>][j - <span class="number">1</span>] * a[i][k] , f[i][j] %= HA;</span><br><span class="line">f[i][j] += f[i - <span class="number">1</span>][j + <span class="number">1</span>] * (sum[i] - a[i][k] + HA) % HA , f[i][j] %= HA;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = CON + <span class="number">1</span>; i &lt;= <span class="number">2</span> * CON; i ++) del += f[n][i] , del %= HA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , (cnt - del - <span class="number">1</span> + HA) % HA);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 数学 </tag>
            
            <tag> Luogu </tag>
            
            <tag> 容斥原理 </tag>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 97 (Rated for Div. 2)-部分题解</title>
      <link href="2020/10/29/CF1437-part/"/>
      <url>2020/10/29/CF1437-part/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一场不算太难的 $\text{Edu}$。</p><hr><h2 id="A-Marketing-Scheme"><a href="#A-Marketing-Scheme" class="headerlink" title="A - Marketing Scheme"></a>A - Marketing Scheme</h2><h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>给出 $l , r$ ，判断是否存在一个数 $x$ 使得对于区间 $\lbrack l , r \rbrack$ 中的每一个整数有 $\frac{x}{2} \leq i \bmod x$。</p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><del>其实直接看样例手玩也能找出规律</del></p><p>考虑一下 $x$ 与区间 $\lbrack l , r \rbrack$ 的关系。</p><ul><li>$\frac{x}{2} \leq l$，否则的话 $\lbrack l , \frac{x}{2} \rbrack$ 不满足题意。</li><li>$r &lt; x$，否则的话 $\lbrack x , r \rbrack$ 不满足题意。</li></ul><p>综上，若 $l \leq \frac{r}{2}$，则存在，否则不存在。</p><hr><h3 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll l , r; </span><br><span class="line">read(l) , read(r);</span><br><span class="line"><span class="keyword">if</span>(l * <span class="number">2</span> &lt;= r) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t; read(t);</span><br><span class="line">    <span class="keyword">while</span>(t --) solve();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="B-Reverse-Binary-Strings"><a href="#B-Reverse-Binary-Strings" class="headerlink" title="B - Reverse Binary Strings"></a>B - Reverse Binary Strings</h2><h3 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>给定一个长度为偶数的 $01$ 串，每次可以选择一个连续子串并将其翻转。</p><p>要求最后翻转为一个交替 $01$ 串(即类似于 $010101……$ 或 $101010……$ 的串)，请求出最小的操作次数 </p><hr><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>一次操作的有三种情况：让原本挨在一起的两个 $0$ 与两个 $1$ 不挨在一起，只让原本挨在一起的两个 $0$ 不挨在一起，只让原本挨在一起的两个 $1$ 不挨在一起。</p><p>因此答案就是最长的连续全 $0$ 串与连续全 $1$ 串的长度的最大值。</p><hr><h3 id="Code-Accepted-1"><a href="#Code-Accepted-1" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[M] , b[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n; read(n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span> , a + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> max0 = <span class="number">0</span> , max1 = <span class="number">0</span> , lst = a[<span class="number">1</span>] , cnt = <span class="number">0</span>;</span><br><span class="line">rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; a[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) max1 ++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; a[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) max0 ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , max(max0 , max1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t; read(t);</span><br><span class="line">    <span class="keyword">while</span>(t --) solve();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="C-Chef-Monocarp"><a href="#C-Chef-Monocarp" class="headerlink" title="C - Chef Monocarp"></a>C - Chef Monocarp</h2><h3 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>有一个厨师在 $0$ 时刻把 $n$ 道菜放到了烤箱里，每一个菜品都有一个烘烤时间 $t_i$。</p><p>在接下来的每一个时刻里，他可以从烤箱中拿出不超过一个菜品，设他在时间 $T$ 拿出了烘烤时间为 $t_i$ 的菜品，则该菜品的不美味度为 $|T - t_i|$。</p><p>厨师不想让所有菜品的不美味度之和太大，所以请你帮他求出所有菜品不美味度之和的最小值。</p><hr><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>先考虑烘烤时间短的菜品一定是更优的，因此我们先将菜品按照烘烤时间进行排序。</p><p>之后考虑 $\text{dp}$。</p><p>设 $f[i][j]$ 表示在时间 $i$ 拿出前 $j$ 个菜品的最小不美味度，则有：</p><script type="math/tex; mode=display">f[i][j] = min(f[i][j] , f[i][j - 1] + |i - t[j]|)</script><p>发现 $i$ 这一维完全没什么用，删掉，就成了：</p><script type="math/tex; mode=display">f[j] = min(f[j] , f[j - 1] + |i - t[j]|)</script><p>大力 $\text{dp}$ 即可。</p><p>时间复杂度 $O(n^2)$，可以通过本题。</p><hr><h3 id="Code-Accepted-2"><a href="#Code-Accepted-2" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , a[M] , t[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">read(n);</span><br><span class="line">rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">read(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">clean(f , <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">sort(a + <span class="number">1</span> , a + <span class="number">1</span> + n);</span><br><span class="line">rep(i , <span class="number">1</span> , <span class="number">2</span> * n)&#123;</span><br><span class="line">per(j , n , <span class="number">1</span>)&#123;</span><br><span class="line">f[j] = min(f[j] , f[j - <span class="number">1</span>] + <span class="built_in">abs</span>(a[j] - i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , f[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t; read(t);</span><br><span class="line">    <span class="keyword">while</span>(t --) solve();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="D-Minimal-Height-Tree"><a href="#D-Minimal-Height-Tree" class="headerlink" title="D - Minimal Height Tree"></a>D - Minimal Height Tree</h2><h3 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h3><p>给你一棵树的 $\text{bfs}$ 序，规定这棵树以 $1$ 为根节点，$\text{bfs}$ 时会优先遍历编号较小的节点。</p><p>请求出这棵树的最小可能高度。</p><hr><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>不难发现，对于某个点后面出现的节点，如果它的编号比前面的节点小，那么就可以将其与前面的节点放在同一层上。</p><p>直接贪心即可。</p><hr><h3 id="Code-Accepted-3"><a href="#Code-Accepted-3" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">300000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , a[M] , dep[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">clean(dep , <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">2</span>;</span><br><span class="line">q.push(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> fro = q.front(); q.pop();</span><br><span class="line"><span class="keyword">int</span> lst = cnt;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt; n) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">while</span>(a[cnt] &lt; a[cnt + <span class="number">1</span>] &amp;&amp; cnt &lt; n)&#123;</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line">rep(i , lst , cnt)&#123;</span><br><span class="line">dep[a[i]] = dep[fro] + <span class="number">1</span>;</span><br><span class="line">q.push(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">read(n);</span><br><span class="line">rep(i , <span class="number">1</span> , n) read(a[i]);</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">bfs();</span><br><span class="line">rep(i , <span class="number">1</span> , n) res = max(res , dep[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t; read(t);</span><br><span class="line">    <span class="keyword">while</span>(t --) solve();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="E-Make-It-Increasing"><a href="#E-Make-It-Increasing" class="headerlink" title="E - Make It Increasing"></a>E - Make It Increasing</h2><h3 id="题意翻译-1"><a href="#题意翻译-1" class="headerlink" title="题意翻译"></a>题意翻译</h3><p>给你一个数列 $a$ 与一个集合 $B$。</p><p>对于集合 $B$ 中的任意一个元素 $x$，$a_x$ 的值不可以被修改。除此之外，$a$ 中的元素均可以被修改。</p><p>请最小化将 $a$ 序列变为严格递增序列的修改次数，或者判断无解。</p><hr><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>先考虑什么情况无解：即存在任意一组 $i,j ∈ B , i &lt; j$ 且 $a_i &gt; a_j$。</p><p>转换一下，就成了 $i,j ∈ B , i &lt; j , a_j - a_i &lt; j - i$</p><p>之后考虑 $k = 0$ 时(即没有修改限制)的情况。若 $k = 0$，则原问题就变成了一个经典的 $\text{dp}$问题。</p><p>将原数列变形为 $a_i - i$，之后跑一遍最长不下降子序列，设其长度为 $len$，则最后的答案是 $n - len$，代码如下。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a 为已知的数列，d[i]为长度为i的最长不下降子序列末尾元素的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) a[i] -= i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;    <span class="comment">//cnt 为长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span> || a[i] &gt;= d[cnt])&#123; </span><br><span class="line">        d[++ cnt] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = upper_bound(d + <span class="number">1</span> , d + <span class="number">1</span> + cnt , a[i]) - d; <span class="comment">//替换掉第一个比它大的元素</span></span><br><span class="line">        d[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想想上面的代码在干什么？它会在遍历 $a$ 数组时尽量最小化一个假想的答案序列，以尽量容下一个新的值来增大答案。</p><p>在判掉不合法的情况之后，我们已经确保有解，但与之同时我们需要保证不修改不能修改的位置，故我们需要让他们处于这个假想的答案序列中，于是我们可以魔改一下上面的代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//lst 上一个维护的不能修改的值在假想答案序列中的位置</span></span><br><span class="line"><span class="comment">//cant[i]  a数组的第i位是否禁止修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) a[i] -= i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span> || a[i] &gt; d[cnt])&#123;</span><br><span class="line">        d[++ cnt] = a[i];</span><br><span class="line">        <span class="keyword">if</span>(cant[i] == <span class="number">1</span>) lst = cnt; <span class="comment">//更新lst</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = upper_bound(d + <span class="number">1</span> , d + <span class="number">1</span> + cnt , a[i]) - d;</span><br><span class="line">        <span class="keyword">if</span>(j &lt;= lst) <span class="keyword">continue</span>;  <span class="comment">//如果我们要更改的位置在上一个不能修改的值之前，则不能修改，否则上一个不能修改的位置将不在答案序列中</span></span><br><span class="line">        d[j] = a[i];</span><br><span class="line">        <span class="keyword">if</span>(cant[i]) lst = j , cnt = j;  </span><br><span class="line">        <span class="comment">//若这一位不能修改，则其答案序列后面的位置都不满足条件，因为它们不能大于这个不能修改的位置，因此对我们要的最长不下降子序列不能产生贡献。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(建议配合代码进行理解)。</p><p>时间复杂度为 $O(n \log n)$，足以通过本题。</p><hr><h3 id="Code-Accepted-4"><a href="#Code-Accepted-4" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , k , a[M] , b[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[M];</span><br><span class="line"><span class="keyword">int</span> cant[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n) , read(k);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">read(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">rep(i , <span class="number">1</span> , k)&#123;</span><br><span class="line">read(b[i]);</span><br><span class="line">cant[b[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(b + <span class="number">1</span> , b + k + <span class="number">1</span>);</span><br><span class="line">rep(i , <span class="number">2</span> , k)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[b[i - <span class="number">1</span>]] - a[b[i]] &gt; b[i - <span class="number">1</span>] - b[i]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>) , <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">rep(i , <span class="number">1</span> , n) a[i] -= i;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span> , lst = <span class="number">0</span>;</span><br><span class="line">rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">0</span> || a[i] &gt;= d[cnt])&#123;</span><br><span class="line">d[++ cnt] = a[i];</span><br><span class="line"><span class="keyword">if</span>(cant[i] == <span class="number">1</span>)&#123;</span><br><span class="line">lst = cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> j = upper_bound(d + <span class="number">1</span> , d + <span class="number">1</span> + cnt , a[i]) - d;</span><br><span class="line"><span class="keyword">if</span>(j &lt;= lst) <span class="keyword">continue</span>;</span><br><span class="line">d[j] = a[i];</span><br><span class="line"><span class="keyword">if</span>(cant[i]) lst = j , cnt = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , n - cnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> Codeforces </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JLOI2011】不等式组-题解</title>
      <link href="2020/10/09/luoguP5482/"/>
      <url>2020/10/09/luoguP5482/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>给出 $n$ 次操作，每次操作是下列的一种：</p><ul><li>添加一条形如 $ax + b &gt; c$ 的不等式</li><li>删除其中一条不等式</li><li>询问当 $x = k$ 时成立的不等式的个数</li></ul><p>请快速处理以上操作并输出相应的结果。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为一个正整数 $n$，代表接下来有 $n$ 行。</p><p>接下来每一行可能有 $3$ 种形式：</p><ul><li><p><code>Add a b c</code>：表明要往不等式组添加一条不等式 $ax+b&gt;c$。</p></li><li><p><code>Del i</code>：代表删除掉第 $i$ 条添加的不等式（最先添加的是第 $1$ 条）。</p></li><li><p><code>Query k</code>：代表一个询问，即当 $x=k$ 时，在当前不等式组内成立的不等式的数量。</p></li></ul><p>注意：一开始不等式组为空，$a,b,c,i,k$ 均为整数，且保证所有操作均合法，不会出现要求删除尚未添加的不等式的情况。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每一个询问 <code>Query k</code>，输出一行一个整数，代表询问的答案。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">Add 1 1 1</span><br><span class="line">Add -2 4 3</span><br><span class="line">Query 0</span><br><span class="line">Del 1</span><br><span class="line">Query 0</span><br><span class="line">Del 2</span><br><span class="line">Query 0</span><br><span class="line">Add 8 9 100</span><br><span class="line">Query 10</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $20\%$ 的数据，保证 $n\leq 10^3$。</p><p>对于 $40\%$ 的数据，保证 $n\leq 10^4$。</p><p>对于 $100\%$ 的数据，保证 $1\leq n\leq 10^5$ ，$a,b,c \in \lbrack -10^8,10^8 \rbrack$，$k\in \lbrack-10^6,10^6 \rbrack$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>直接带入维护并不好维护，考虑移项。</p><p>对于不等式 $ax + b &gt; c$ ，移项之后有以下三种情况：</p><ul><li>$a = 0$，移项后成了 $b &gt; c$。这种情况要么恒成立要么永远不成立，特判即可</li><li>$a &gt; 0$，移项后成了 $x &gt; \lceil \frac{c - b}{a} \rceil$。</li><li>$a &lt; 0$，移项后成了 $x &lt; \lfloor \frac{c - b}{a} \rfloor$。</li></ul><p>对于情况 $2$ 和情况 $3$，我们各开一个树状数组<strong>维护区间内大于或小于某个数的个数</strong>即可。</p><p>设 $t1$ 维护 $a &gt; 0$ 的情况 ， $t2$ 维护 $a &lt; 0$ 的情况 ，则查询 $x = k$ 的答案即为</p><script type="math/tex; mode=display">cnt + \sum_{i = k + 1}^{10^6} t1[i] + \sum_{i = 1}^{k - 1} t2[i]</script><p>其中，$cnt$ 为恒成立的不等式的数目。</p><p>单次操作的时间复杂度均为 $O(\log k)$，总时间复杂度为 $O(n \log k)$。足以通过本题。</p><p>细节部分将在代码注释中呈现，建议仔细参考。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tree1[M &lt;&lt; <span class="number">1</span>] , tree2[M &lt;&lt; <span class="number">1</span>] , lim = (M &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> val , <span class="keyword">int</span> tree[])</span></span>&#123;     </span><br><span class="line">    <span class="comment">//由于树状数组不可以有0 ，为防止越界，我在每一个x上加了一个M&#x27;</span></span><br><span class="line">    x += M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= lim; i += lowbit(i))&#123;</span><br><span class="line">        tree[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> tree[])</span></span>&#123;</span><br><span class="line">    x += M;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i ; i -= lowbit(i))&#123;</span><br><span class="line">        ans += tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> type[M &lt;&lt; <span class="number">1</span>] , tk[M &lt;&lt; <span class="number">1</span>] , tot , cnt; </span><br><span class="line"></span><br><span class="line"><span class="comment">// type[i] 第i个操作的类型    tk[i] 第i个操作的x值 或 k值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type[i] = 2 第i个操作需要变号    type[i] = 1 不需要变号</span></span><br><span class="line"><span class="comment">// type[i] = (1 &lt;&lt; 30) 恒成立且可忽视  type[i] = -(1 &lt;&lt; 30) 不成立且可忽视</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a , b , c;</span><br><span class="line">    read(a) , read(b) , read(c);</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>)&#123; <span class="comment">//处理恒成立情况</span></span><br><span class="line">        <span class="keyword">if</span>(b &gt; c)&#123;</span><br><span class="line">            cnt ++ , type[++ tot] = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            type[++ tot] = -(<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        tk[++ tot] = (<span class="built_in">ceil</span>)((<span class="number">1.0</span> * c - b) / a);</span><br><span class="line">        type[tot] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tk[tot] &gt; (<span class="keyword">int</span>)<span class="number">1e6</span>)&#123;</span><br><span class="line">            <span class="comment">//由于k的范围为[-1e6 , 1e6]，则解出结果大于1e6 或 小于-1e6 的不等式均可视为恒成立不等式</span></span><br><span class="line">            cnt ++ , type[tot] = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tk[tot] &lt; (<span class="keyword">int</span>)<span class="number">-1e6</span>)&#123;</span><br><span class="line">            type[tot] = -(<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//树状数组维护小于某个数的个数</span></span><br><span class="line">            add(tk[tot] , <span class="number">1</span> , tree2);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; <span class="number">0</span>)&#123; <span class="comment">//大体同上</span></span><br><span class="line">        tk[++ tot] = (<span class="built_in">floor</span>)((<span class="number">1.0</span> * c - b) / a);</span><br><span class="line">        type[tot] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tk[tot] &gt; (<span class="keyword">int</span>)<span class="number">1e6</span>)&#123;</span><br><span class="line">            type[tot] = -(<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tk[tot] &lt; (<span class="keyword">int</span>)<span class="number">-1e6</span>)&#123;</span><br><span class="line">            cnt ++ , type[tot] = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            add(tk[tot] , <span class="number">1</span> , tree1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> del[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k; read(k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(del[k]) <span class="keyword">return</span> ; <span class="comment">//记录该不等式是否已经删除</span></span><br><span class="line">    del[k] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据删除的不等式的不同选择删除的树状数组</span></span><br><span class="line">    <span class="keyword">if</span>(type[k] == (<span class="number">1</span> &lt;&lt; <span class="number">30</span>)) cnt --;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type[k] == <span class="number">1</span>)&#123;  </span><br><span class="line">        add(tk[k] , <span class="number">-1</span> , tree1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type[k] == <span class="number">2</span>)&#123;</span><br><span class="line">        add(tk[k] , <span class="number">-1</span> , tree2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; read(x);</span><br><span class="line">    <span class="comment">//利用前缀和思想进行查询</span></span><br><span class="line">    <span class="keyword">return</span> cnt + query(x - <span class="number">1</span> , tree1) + query((<span class="keyword">int</span>)<span class="number">1e6</span> , tree2) - query(x , tree2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; read(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span> , op + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            insert();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            Delete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , Query());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces】Link Cut Centroids-题解</title>
      <link href="2020/09/16/CF1406C/"/>
      <url>2020/09/16/CF1406C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>给定一棵节点数为 $n$ 的树 ，请你在树上删一条边然后加上一条边 ，使得该树的重心唯一。（删掉的边和加上的边可以是同一条）</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行一个正整数 $T$ ，表示有 $T$ 组测试数据。 </p><p>对于每组测试数据，第 $1$ 行一个正整数 $n$ ，表示该树有 $n$ 个节点</p><p>第 $2$ 行到第 $n$ 行每行两个正整数 $x,y$， 表示 $x$ 到 $y$ 有一条无向边。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每一组测试数据 。</p><p>第 $1$ 行两个正整数 $x_1,y_1$ ，表示删的边的端点为 $x_1,y_1$。</p><p>第 $2$ 行两个正整数 $x_2,y_2$ ，表示连的边的端点为 $x_2,y_2$。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br><span class="line">6</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $100\%$ 的数据，满足 $1 \leq \sum n \leq 10^5$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>树的重心的简单应用题。</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>第一遍 $\text{dfs}$ 找出树的重心，若只有一个重心的话就直接随便删一条边然后加上即可。</p><p>否则的话，则两个重心必然相邻（否则取这两个重心路径上的中点作为重心更优）。我们钦定其中一个为根节点，那么另一个一定是其子节点。</p><p>之后在不是根节点的重心上随便删掉一个通往子节点的边，并将其与根节点链接即可。</p><hr><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>那么为什么这是对的呐？</p><p>显然，被钦定为根的节点操作之后依然是重心，而未被钦定的那个因为删去了一个子节点，其最大子树大小变大，显然不再是重心了。</p><p>由于以上操作只是这三个点之间的操作，与另外的节点没有关系。因此另外的节点也不会是重心。</p><p>综上，命题得证。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from , to , last;</span><br><span class="line">&#125;edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;from , to , head[from]&#125;; head[from] = edge_num;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;to , from , head[to]&#125;; head[to] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[M] , size[M] , cnt = <span class="number">0x3f3f3f3f</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line">    PE(i , x)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to == f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(to , x);</span><br><span class="line">        size[x] += size[to];</span><br><span class="line">        sz = max(sz , size[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    sz = max(sz , n - size[x]);</span><br><span class="line">    <span class="keyword">if</span>(sz &lt; cnt)&#123;</span><br><span class="line">        cnt = sz; root[<span class="number">1</span>] = x , root[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sz == cnt)&#123;</span><br><span class="line">        root[<span class="number">2</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> leaf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[x] == <span class="number">1</span>)&#123;</span><br><span class="line">        leaf = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PE(i , x)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to == f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(to , x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t; read(t);</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        edge_num = <span class="number">0</span>;</span><br><span class="line">        rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">            head[i] = fa[i] = size[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        root[<span class="number">1</span>] = root[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        read(n);</span><br><span class="line">        rep(i , <span class="number">1</span> , n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> u , v;</span><br><span class="line">            read(u) , read(v);</span><br><span class="line">            add_edge(u , v);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(<span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(root[<span class="number">1</span>] != <span class="number">0</span> &amp;&amp; root[<span class="number">2</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n%d %d\n&quot;</span> , edge[<span class="number">1</span>].from , edge[<span class="number">1</span>].to , edge[<span class="number">1</span>].to , edge[<span class="number">1</span>].from);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fa[root[<span class="number">1</span>]] != root[<span class="number">2</span>]) swap(root[<span class="number">1</span>] , root[<span class="number">2</span>]);</span><br><span class="line">        dfs2(root[<span class="number">1</span>] , root[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n%d %d\n&quot;</span> , leaf , fa[leaf] , leaf , root[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Codeforces </tag>
            
            <tag> 树的重心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces】Two Types of Spells-题解</title>
      <link href="2020/09/16/CF1398E/"/>
      <url>2020/09/16/CF1398E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>你在玩一种纸牌游戏。</p><p>牌有两种，一种是普通牌，使用它可以得到它的得分；另一种是加倍牌，使用它不但可以得到它的得分，还可以让排在它后面的牌的得分 $\times 2$。</p><p>一组牌的使用顺序可以任意，其得分为每一张牌的得分之和。</p><p>现在有两种操作，每一次操作形如 <code>opt d</code>。</p><p>其中，$opt$ 代表牌的类型($1$ 为加倍牌，$0$ 为普通牌)。</p><p>而 $d$ 的正负代表操作类型，若 $d &gt; 0$ ，代表你抽到了一张得分为 $d$ 的牌；反之，代表你丢弃了一张得分为 $|d|$ 的牌(丢弃纸牌不会得分)。</p><p>请回答每次操作后<strong>可能得到的最大得分</strong>。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$ ，表示总操作次数。</p><p>之后 $n$ 行，每行两个整数 $opt$ , $d$ ，意义同上。</p><p>保证不会同时有两张 $d$ 相同的纸牌</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 $n$ 行，每行一个整数，表示该操作后可能得到的最大得分。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 5</span><br><span class="line">0 10</span><br><span class="line">1 -5</span><br><span class="line">0 5</span><br><span class="line">1 11</span><br><span class="line">0 -10</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">25</span><br><span class="line">10</span><br><span class="line">15</span><br><span class="line">36</span><br><span class="line">21</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $100\%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^9 \leq d \leq 10^9$，$opt ∈ \lbrack 0 , 1 \rbrack$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>$\text{set}$ 练手题。</p><p>先说一个众所周知的事实，$\text{Codeforces}$ 的 $\text{Div 2} \text{D , E}$ 如果要支持插入删除一般都是 $\text{set}$ <del>因为别的真的没得考了……</del></p><p>现在回到这道题上。对于这道题，我们先考虑一下不带修的时候怎么做。</p><p>设 $k$ 为加倍牌的数量，有一个显然的想法就是将 $d$ 最大的 $k$ 张牌加倍。</p><p>但需要特判最大的 $k$ 张牌都是加倍牌的情况。对此，我们需要从不加倍的牌中找一个最大的替换掉加倍牌中最小的。</p><p>之后考虑如何带修。我们需要维护的东西有：加倍牌的数目，牌的类型与价值。</p><p>对此，我们可以开两个 $\text{set}$ ，一个维护前 $k$ 大，另一个维护剩下的牌。</p><p>剩下的就是细节问题了。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"><span class="built_in">set</span>&lt;PLL&gt; big , small;</span><br><span class="line">ll smb , sma , smk , k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n);</span><br><span class="line">    ll now = <span class="number">0</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        ll opt , d;</span><br><span class="line">        read(opt) , read(d);</span><br><span class="line">        <span class="keyword">if</span>(d &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            now += opt;</span><br><span class="line">            <span class="keyword">if</span>(small.empty() || d &gt;= small.rbegin()-&gt;fi)&#123;</span><br><span class="line">                big.insert(MP(d , opt));</span><br><span class="line">                smb += d;</span><br><span class="line">                <span class="keyword">if</span>(opt == <span class="number">1</span>) smk += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                small.insert(MP(d , opt));</span><br><span class="line">                sma += d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            now -= opt , d = -d;</span><br><span class="line">            <span class="keyword">if</span>(big.count(MP(d , opt)))&#123;</span><br><span class="line">                big.erase(big.find(MP(d , opt)));</span><br><span class="line">                smb -= d;</span><br><span class="line">                <span class="keyword">if</span>(opt == <span class="number">1</span>) smk -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                small.erase(small.find(MP(d , opt)));</span><br><span class="line">                sma -= d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(big.size() &gt; now)&#123;</span><br><span class="line">            small.insert(*big.begin());</span><br><span class="line">            smb -= big.begin()-&gt;fi;</span><br><span class="line">            sma += big.begin()-&gt;fi;</span><br><span class="line">            <span class="keyword">if</span>(big.begin()-&gt;se == <span class="number">1</span>) smk -= <span class="number">1</span>;</span><br><span class="line">            big.erase(big.begin());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(big.size() &lt; now)&#123;</span><br><span class="line">            big.insert(*small.rbegin());</span><br><span class="line">            sma -= small.rbegin()-&gt;fi;</span><br><span class="line">            smb += small.rbegin()-&gt;fi;</span><br><span class="line">            <span class="keyword">if</span>(small.rbegin()-&gt;se == <span class="number">1</span>) smk += <span class="number">1</span>;</span><br><span class="line">            small.erase(--small.end());</span><br><span class="line">        &#125;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(smk != now || now == <span class="number">0</span>)&#123;</span><br><span class="line">            res = smb * <span class="number">2</span> + sma;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(small.empty())&#123;</span><br><span class="line">                res = smb * <span class="number">2</span> + sma - big.begin()-&gt;fi;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res = smb * <span class="number">2</span> + sma - big.begin()-&gt;fi + small.rbegin()-&gt;fi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Codeforces </tag>
            
            <tag> STL </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces】Codeforces Round 669(Div 2)-题解</title>
      <link href="2020/09/10/CF1407/"/>
      <url>2020/09/10/CF1407/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一场比较简单的 $\text{Div} 2$。</p><hr><h2 id="A-Ahahahahahahahaha"><a href="#A-Ahahahahahahahaha" class="headerlink" title="A - Ahahahahahahahaha"></a>A - Ahahahahahahahaha</h2><h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>即给定一个长度为 $n$ $(2 \leq n \leq 10^3)$ 的 $01$ 串，要求至多删去 $\frac{n}{2}$ 个字符，使得剩下的串中<strong>奇数位的数之和 = 偶数位之和</strong>， 要求输出删去后剩下的串。</p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>注意一下 $0$ 与 $1$ 的数量，不难发现总会有一个小于 $\frac{n}{2}$。</p><p>则我们将小于 $\frac{n}{2}$ 的那个数字全部删掉即可。</p><p>若我们删掉的是数字 $0$ ，则还要注意一下剩下的 $1$ 的个数，若剩下的数目为奇数需要则多删去一个。</p><p>时间复杂度 $O(n)$。</p><hr><h3 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> t; read(t);</span><br><span class="line"><span class="keyword">while</span>(t --)&#123;</span><br><span class="line"><span class="keyword">int</span> x , n , cnt[<span class="number">2</span>] = &#123;<span class="number">0</span> , <span class="number">0</span>&#125;;</span><br><span class="line">read(n);</span><br><span class="line">rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">cnt[x] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt[<span class="number">0</span>] &gt;= cnt[<span class="number">1</span>])&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n - cnt[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">rep(i , <span class="number">1</span> , n - cnt[<span class="number">1</span>])&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>((n - cnt[<span class="number">0</span>]) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n - cnt[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">rep(i , <span class="number">1</span> , n - cnt[<span class="number">0</span>])&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n - cnt[<span class="number">0</span>] - <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">rep(i , <span class="number">1</span> , n - cnt[<span class="number">0</span>] - <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="B-Big-Vova"><a href="#B-Big-Vova" class="headerlink" title="B - Big Vova"></a>B - Big Vova</h2><h3 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>给定一个长度为 $n (1 \leq n \leq 10^3)$ 的数列，要求对这个数列重新指定顺序，使得这个数列的每一个前缀 $text{gcd} $组成的新序列的字典序最大。</p><hr><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>$n$ 很小，直接枚举即可。</p><p>时间复杂度 $O(n^2 \log n)$。</p><hr><h3 id="Code-Accepted-1"><a href="#Code-Accepted-1" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line">ll a[M] , n , b[M] , ans[M];</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a , ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !b ? a : gcd(b , a % b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> vis[M];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> t; read(t);</span><br><span class="line"><span class="keyword">while</span>(t --)&#123;</span><br><span class="line">clean(vis , <span class="number">0</span>) , clean(a , <span class="number">0</span>);</span><br><span class="line">read(n);</span><br><span class="line">rep(i , <span class="number">1</span> , n) read(a[i]);</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line"><span class="keyword">int</span> maxn = <span class="number">0</span> , pla = <span class="number">0</span>;</span><br><span class="line">rep(j , <span class="number">1</span> , n)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j] &amp;&amp; maxn &lt; gcd(a[j] , d))&#123;</span><br><span class="line">maxn = gcd(a[j] , d);</span><br><span class="line">pla = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[pla] = <span class="number">1</span>;</span><br><span class="line">d = gcd(d , a[pla]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[pla] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="C-Chocolate-Bunny"><a href="#C-Chocolate-Bunny" class="headerlink" title="C - Chocolate Bunny"></a>C - Chocolate Bunny</h2><h3 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>这是一道交互题。</p><p>有一个 $n$ 个数的排列，每次询问 $x,y$ 得到 $a_x\bmod a_y$ 的值。</p><p>最多询问 $2\times n$ 次，请猜出这个序列。</p><hr><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>最多 $2 \times n$ 次的询问限制暗示我们需要询问 $x \bmod y$ 与 $y \bmod x$。</p><p>如果 $x &gt; y$，则有</p><script type="math/tex; mode=display">x \bmod y < y</script><script type="math/tex; mode=display">y \bmod x = y</script><p>即 $x &gt; y$ 时，满足 $y = y \bmod x$。</p><p>如果 $x &lt; y$，则有</p><script type="math/tex; mode=display">x \bmod y = x</script><script type="math/tex; mode=display">y \bmod x < x</script><p>即 $x &lt; y$ 时，满足 $x = x \bmod y$。</p><p>直接询问即可，询问次数为 $2 \times n - 2$。</p><hr><h3 id="Code-Accepted-2"><a href="#Code-Accepted-2" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> p[M] , vis[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j + <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; j + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> y; <span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">            p[j] = y;</span><br><span class="line">            vis[y - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p[i] = x;</span><br><span class="line">            vis[x - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p[j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (vis[p[j] - <span class="number">1</span>]) ++p[j];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    rep(i , <span class="number">0</span> , n - <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="D-Discrete-Centrifugal-Jumps"><a href="#D-Discrete-Centrifugal-Jumps" class="headerlink" title="D - Discrete Centrifugal Jumps"></a>D - Discrete Centrifugal Jumps</h2><h3 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h3><p>你一开始站在第 $1$ 栋大楼楼顶，需要跳到第 $n (2 \le n \le 3 \times 10^5)$ 栋大楼楼顶。</p><p>每次可以向相邻的大楼跳跃，或者说如果中间一整段都比起点和终点都要低或高，就可以直接跳过去。</p><p>求 $1$ 到 $n$ 的最小跳跃次数。</p><hr><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>先考虑中间一整段都比两端点低的时候怎么做。</p><p>设 $f[i]$ 表示从 $1$ 跳到 $i$ 的最少次数，则显然有 $f[i] = f[j] + 1 (h[i] &gt; h[j])$。</p><p>那现在问题就成了如何维护 $i$ 号点前面第一个比 $i$ 号点高的点。直接单调栈维护即可。</p><p>另一种情况也同理。</p><p>时间复杂度 $O(n)$。</p><hr><h3 id="Code-Accepted-3"><a href="#Code-Accepted-3" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line">ll f[M] , h[M] , n;</span><br><span class="line">ll mx[M] , mn[M];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        read(h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;ll&gt; sta; sta.push(<span class="number">0</span>);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h[sta.top()] &gt;= h[i]) sta.pop();</span><br><span class="line">        mn[i] = sta.top();</span><br><span class="line">        sta.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;ll&gt; sta2; sta2.push(<span class="number">0</span>);</span><br><span class="line">    h[<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h[sta2.top()] &lt;= h[i]) sta2.pop();</span><br><span class="line">        mx[i] = sta2.top();</span><br><span class="line">        sta2.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(i , <span class="number">2</span> , n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h[i] == h[i - <span class="number">1</span>])&#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(h[i - <span class="number">1</span>] &lt; h[i])&#123;</span><br><span class="line">            ll pla = i - <span class="number">1</span>;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(pla != <span class="number">0</span>)&#123;</span><br><span class="line">                f[i] = min(f[i] , f[pla] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(h[pla] &gt;= h[i]) <span class="keyword">break</span>;</span><br><span class="line">                pla = mx[pla];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll pla = i - <span class="number">1</span>;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(pla != <span class="number">0</span>)&#123;</span><br><span class="line">                f[i] = min(f[i] , f[pla] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(h[pla] &lt;= h[i]) <span class="keyword">break</span>;</span><br><span class="line">                pla = mn[pla];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , f[n]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="E-Egor-in-the-Republic-of-Dagestan"><a href="#E-Egor-in-the-Republic-of-Dagestan" class="headerlink" title="E - Egor in the Republic of Dagestan"></a>E - Egor in the Republic of Dagestan</h2><h3 id="题意翻译-1"><a href="#题意翻译-1" class="headerlink" title="题意翻译"></a>题意翻译</h3><p>给出 $n$ 个点 $m$ 条边的有向图，边有黑白两种颜色。</p><p>现在要给点染色，每个点染成黑或白，白点只能走它连出的白色边，黑点只能走它连出的黑色边。</p><p>求一种染色方案使得 $1\to n$ 的最短路径最长。</p><hr><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>题目中能否走这条边取决于这条边起始点的颜色，这很不好处理。</p><p>考虑建反图，让能否走这条边就取决于终点的颜色。</p><p>之后从 $n$ 号点开始 $\text{bfs}$。</p><p>对于点 $i$，在其第一次被枚举到时就证明它在最短路上。为了避免走它，我们将其颜色染为与边的颜色相反的颜色。</p><p>若之后再次碰到 $i$，若 $i$ 的颜色与边的颜色相同则进行松弛，并加入队列之中。</p><p>这样就最大化了每个点到 $n$ 的距离，也包括 $1$ 到 $n$ 的距离。</p><p>至于自始至终没有染色的点证明根本走不到，随便染一下即可。</p><p>时间复杂度 $O(n)$。</p><hr><h3 id="Code-Accepted-4"><a href="#Code-Accepted-4" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500011</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to , last , dis;</span><br><span class="line">&#125;edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++ edge_num] = (Edge)&#123;to , head[from] , dis&#125;; head[from] = edge_num;</span><br><span class="line"><span class="comment">//edge[++ edge_num] = (Edge)&#123;from , head[to] , dis&#125;; head[to] = edge_num;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ll dis[M] , col[M];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">clean(dis , <span class="number">-1</span>) , clean(col , <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">q.push(n); </span><br><span class="line">dis[n] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> fro = q.front(); q.pop();</span><br><span class="line">PE(i , fro)&#123;</span><br><span class="line"><span class="keyword">int</span> to = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(dis[to] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(col[to] == <span class="number">-1</span>) col[to] = (edge[i].dis ^ <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(col[to] == edge[i].dis)&#123;</span><br><span class="line">dis[to] = dis[fro] + <span class="number">1</span>;</span><br><span class="line">q.push(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n) , read(m);</span><br><span class="line">rep(i , <span class="number">1</span> , m)&#123;</span><br><span class="line"><span class="keyword">int</span> u , v , w;</span><br><span class="line">read(u) , read(v) , read(w);</span><br><span class="line">add_edge(v , u , w);</span><br><span class="line">&#125; </span><br><span class="line">bfs();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , dis[<span class="number">1</span>]);</span><br><span class="line">rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , col[i] == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Codeforces </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 交互题 </tag>
            
            <tag> 线性dp </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces】Coloring Brackets-题解</title>
      <link href="2020/09/01/CF149D/"/>
      <url>2020/09/01/CF149D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>给出一个配对的括号序列，之后对该序列按以下方法进行染色： </p><ul><li>一个括号可以染红色、蓝色或不染色 </li><li>一对匹配的括号必须且只能将其中一个染色 </li><li>相邻两个括号颜色不能相同（但可以都不染色）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.luogu.com.cn/upload/vjudge_pic/CF149D/18f69b22b88c3423241947f144f2105947738984.png" alt=""></p><p>请求出符合条件的染色方案数，对 $10^9 + 7$ 取模</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入仅有一行，包含一个字符串 $|s|$ ，表示给定的括号序列</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，包含一个整数，表示符合条件的方案数对 $10^9 + 7$ 取模的结果</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">(())</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">(()())</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">40</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-3"><a href="#Input-‘s-eg-3" class="headerlink" title="Input ‘s eg 3"></a>Input ‘s eg 3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">()</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-3"><a href="#Output-‘s-eg-3" class="headerlink" title="Output ‘s eg 3"></a>Output ‘s eg 3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>设 $|s|$ 为输入括号序列的长度</p><p>对于 $100\%$ 的数据，保证 $1 \leq |s| \leq 700$，且保证 $s$ 括号匹配。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目中长度 $\leq 700$ 的数据范围基本在暗示两维以上的数组，且输入的是一个括号序列，不难想到区间 $\text{dp}$。</p><p>采用区间 $\text{dp}$ 的老套路，设 $f[l][r]$ 表示从 $l$ 到 $r$ 的范围内符合条件的方案数。</p><p>但这样不好处理相同颜色不可相邻的问题，考虑增加维度。设 $f[l][r][0/1/2][0/1/2]$ 表示从 $l$ 到 $r$ 中最左边染为无色/红色/蓝色，右边同理的方案数。</p><p>之后预处理每个左括号对应的右括号位置，这可以用一个栈辅助实现。</p><p>考虑转移。观察一下，可以发现每个合法的括号序列可以被拆解为更小的合法序列，比如 <code>()()</code> 就可以拆解为两个 <code>()</code>。</p><p>因此，我们采用记忆化搜索的方式，将整个括号序列拆解为若干小序列进行计算。</p><p>之后进行讨论，当 $l + 1 = r$ 时，则整个括号序列为 <code>()</code> ，此时有</p><script type="math/tex; mode=display">f[l][r][0][1] = f[l][r][0][2] = f[l][r][1][0] = f[l][r][2][0] = 1</script><p>若 $r$ 正好是 $l$ 的对应位置，则 $\lbrack l + 1 , r - 1 \rbrack$ 也是一对合法的括号序列，递归处理 $\lbrack l + 1 , r - 1 \rbrack$。</p><p>之后考虑 $l$ 与 $r$ 的颜色，可得</p><script type="math/tex; mode=display">f[l][r][1][0] += f[l + 1][r - 1][i][j] \;\;\;\;(l \neq 1)</script><script type="math/tex; mode=display">f[l][r][0][1] += f[l + 1][r - 1][i][j] \;\;\;\;(r \neq 1)</script><script type="math/tex; mode=display">f[l][r][2][0] += f[l + 1][r - 1][i][j] \;\;\;\;(l \neq 2)</script><script type="math/tex; mode=display">f[l][r][0][2] += f[l + 1][r - 1][i][j] \;\;\;\;(r \neq 2)</script><p>否则的话，我们将括号序列划分成两段，依次处理之后根据乘法原理相乘累加即可。</p><p>剩下的细节见代码即可。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[M];</span><br><span class="line">ll f[<span class="number">750</span>][<span class="number">750</span>][<span class="number">3</span>][<span class="number">3</span>] , dy[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        f[l][r][<span class="number">0</span>][<span class="number">1</span>] = f[l][r][<span class="number">0</span>][<span class="number">2</span>] = f[l][r][<span class="number">1</span>][<span class="number">0</span>] = f[l][r][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dy[l] == r)&#123;</span><br><span class="line">        dfs(l + <span class="number">1</span> , r - <span class="number">1</span>);</span><br><span class="line">        rep(i , <span class="number">0</span> , <span class="number">2</span>)&#123;</span><br><span class="line">            rep(j , <span class="number">0</span> , <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">1</span>) f[l][r][<span class="number">1</span>][<span class="number">0</span>] += f[l + <span class="number">1</span>][r - <span class="number">1</span>][i][j] , f[l][r][<span class="number">1</span>][<span class="number">0</span>] %= HA;</span><br><span class="line">                <span class="keyword">if</span>(j != <span class="number">1</span>) f[l][r][<span class="number">0</span>][<span class="number">1</span>] += f[l + <span class="number">1</span>][r - <span class="number">1</span>][i][j] , f[l][r][<span class="number">0</span>][<span class="number">1</span>] %= HA;</span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">2</span>) f[l][r][<span class="number">2</span>][<span class="number">0</span>] += f[l + <span class="number">1</span>][r - <span class="number">1</span>][i][j] , f[l][r][<span class="number">2</span>][<span class="number">0</span>] %= HA;</span><br><span class="line">                <span class="keyword">if</span>(j != <span class="number">2</span>) f[l][r][<span class="number">0</span>][<span class="number">2</span>] += f[l + <span class="number">1</span>][r - <span class="number">1</span>][i][j] , f[l][r][<span class="number">0</span>][<span class="number">2</span>] %= HA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dfs(l , dy[l]);</span><br><span class="line">        dfs(dy[l] + <span class="number">1</span> , r);</span><br><span class="line">        rep(i , <span class="number">0</span> , <span class="number">2</span>)&#123;</span><br><span class="line">            rep(j , <span class="number">0</span> , <span class="number">2</span>)&#123;</span><br><span class="line">                rep(k , <span class="number">0</span> , <span class="number">2</span>)&#123;</span><br><span class="line">                    rep(d , <span class="number">0</span> , <span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>((j == <span class="number">0</span> &amp;&amp; k == <span class="number">0</span>) || (j != k))&#123;</span><br><span class="line">                            f[l][r][i][d] += f[l][dy[l]][i][j] * f[dy[l] + <span class="number">1</span>][r][k][d] % HA;</span><br><span class="line">                            f[l][r][i][d] %= HA;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span> , a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    rep(i , <span class="number">1</span> , len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="string">&#x27;(&#x27;</span>) s.push(i);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dy[s.top()] = i;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span> , len);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    rep(i , <span class="number">0</span> , <span class="number">2</span>)&#123;</span><br><span class="line">        rep(j , <span class="number">0</span> , <span class="number">2</span>)&#123;</span><br><span class="line">            res += f[<span class="number">1</span>][len][i][j] , res %= HA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Codeforces </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SCOI2009】迷路-题解</title>
      <link href="2020/08/19/luoguP4159/"/>
      <url>2020/08/19/luoguP4159/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>给出一个有 $n$ 个节点的带权有向图，节点从 $1$ 至 $n$ 编号。</p><p>$\text{windy}$ 从节点 $1$ 出发，他必须恰好在 $t$ 时刻到达节点 $n$。</p><p>请告诉 $\text{windy}$ 总共有多少种不同的路径。</p><p>答案对 $2009$ 取模。</p><p>注意：$\text{windy}$ 不能在某个节点逗留，且通过某有向边的时间严格为给定的时间。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数，分别代表 $n$ 和 $t$。</p><p>第 $2$ 到第 $(n + 1)$ 行，每行一个长度为 $n$ 的字符串。</p><p>其中，第 $(i + 1)$ 行的第 $j$ 个字符 $c_{i, j}$ 是一个数字字符，若为 $0$，则代表节点 $i$ 到节点 $j$ 无边。</p><p>否则代表节点 $i$ 到节点 $j$ 的边的长度为 $c_{i, j}$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数代表答案对 $2009$ 取模的结果。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">11</span><br><span class="line">00</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 30</span><br><span class="line">12045</span><br><span class="line">07105</span><br><span class="line">47805</span><br><span class="line">12024</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">852</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $30\%$ 的数据，保证 $2 \leq n \leq 5$，$1 \leq t \leq 30$。</p><p>对于 $100\%$ 的数据，保证 $2 \leq n \leq 10$，$1 \leq t \leq 10^9$。</p><p><strong>保证边权</strong>$∈ \lbrack 0,9 \rbrack$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>这题 + <a href="https://payphone-x.top/2020/06/19/luoguP6569/">【NOI Online3】魔法值</a> = <a href="https://www.luogu.com.cn/problem/P6772">【NOI2020】美食家</a></del></p><p>拆点的套路题。</p><p>题目数据里的 $n$ <strong>很小</strong>，<strong>强烈暗示邻接矩阵</strong>。</p><p>考虑边权全部为 $1$ 时怎么做。若边权全部为 $1$ 则直接求出邻接矩阵的$k$ 次方即可。</p><p>之后考虑如何拓展到本题上。</p><p>仔细读一下题，可以发现本题的边权范围均在 $\lbrack 0 , 9 \rbrack$ 之内。则我们考虑将一个点拆为 $9$ 个点。对于点 $i$，我们将其拆为</p><script type="math/tex; mode=display">\{ (i - 1) \times 9 + x , x∈\lbrack 1 , 9 \rbrack \}</script><p>其中点 $(i - 1) \times 9 + 1$ 为点 $i$ 的主点，然后对 $(i - 1) \times 9 + x$ 与 $(i - 1)\times 9 + x + 1$ 之间连接一条边长为 $1$ 的边。</p><p>这样连边权不为 $1$ 的边就很简单了。对于一条从 $u$ 到 $v$，边权为 $d$ 的边，我们只需要连接 $(u - 1) \times 9 + d$ 与 $(v - 1) \times 9 + 1$ 即可。</p><p>最后的答案就是 $1$ 的主点与 $n$ 的主点间的距离，即 $1$ 与 $(n - 1) \times 9 + 1$ 之间的距离。矩阵快速幂即可求解。</p><p>时间复杂度 $O(l^3 \log t)$，其中 $l = 9 \times n$，足以通过本题。</p><p>剩下的细节见代码即可。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">2009</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    ll data[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;A , <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">    Matrix C; clean(C.data , <span class="number">0</span>);</span><br><span class="line">    rep(i , <span class="number">0</span> , <span class="number">100</span>)&#123;</span><br><span class="line">        rep(j , <span class="number">0</span> , <span class="number">100</span>)&#123;</span><br><span class="line">            rep(k , <span class="number">0</span> , <span class="number">100</span>)&#123;</span><br><span class="line">                C.data[i][j] += A.data[i][k] * B.data[k][j];</span><br><span class="line">                C.data[i][j] %= HA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">Pow</span><span class="params">(Matrix A , ll k)</span></span>&#123;</span><br><span class="line">    Matrix B; clean(B.data , <span class="number">0</span>);</span><br><span class="line">    rep(i , <span class="number">1</span> , <span class="number">100</span>) B.data[i][i] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            B = B * A;</span><br><span class="line">        &#125;</span><br><span class="line">        A = A * A;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[M];</span><br><span class="line"></span><br><span class="line">Matrix A , ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ll n , t; </span><br><span class="line">    read(n) , read(t);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="keyword">int</span> now = (i - <span class="number">1</span>) * <span class="number">9</span>;</span><br><span class="line">        rep(j , <span class="number">1</span> , <span class="number">8</span>)&#123;</span><br><span class="line">            A.data[now + j][now + j + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span> , s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> now = (i - <span class="number">1</span>) * <span class="number">9</span>;</span><br><span class="line">        rep(j , <span class="number">1</span> , n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> dis = (<span class="keyword">int</span>)(s[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                A.data[now + dis][(j - <span class="number">1</span>) * <span class="number">9</span> + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clean(ans.data , <span class="number">0</span>);</span><br><span class="line">    rep(i , <span class="number">1</span> , <span class="number">10</span> * n) ans.data[i][i] = <span class="number">1</span>;</span><br><span class="line">    ans = Pow(A , t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans.data[<span class="number">1</span>][(n - <span class="number">1</span>) * <span class="number">9</span> + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 矩阵运算 </tag>
            
            <tag> Luogu </tag>
            
            <tag> 拆点&amp;拆边 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【IOI1998】Polygon-题解</title>
      <link href="2020/08/16/luoguP4342/"/>
      <url>2020/08/16/luoguP4342/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>多边形是一个玩家在一个有 $n$个顶点的多边形上的游戏，</p><p>如图所示，其中$n＝4$。每个顶点有点权，每个边有一个运算符，是 $+$ 或 $\times$ 的其中一种。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.luogu.com.cn/upload/pic/16086.png" alt=""></p><p>这个游戏的过程如下：</p><ol><li>删除其中任意一条边。</li><li>选择一条边连接的两个顶点，并用边上的运算符计算两个点权得到的结果来替换这两个顶点的点权</li><li>重复过程 $2$ ，直到只有一个点为止。</li></ol><p>举个例子，对于上面的图，我们可以先移除编号为 $3$ 的边。之后选择计算编号为 $1$ 的边，然后计算编号为 $4$ 的边，最后，计算编号为 $2$ 的边。</p><p>最后得到的结果为 $0$。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.luogu.org/upload/pic/16088.png" alt=""></p><p>现在问题来了，给定一个多边形，请计算最高可以得到的分数。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行给出数字 $n$，为多边形的总边数。</p><p>第二行描述这个多边形，一共有 $2 \times n$ 个读入，每两个读入中第一个是字符，第二个是数字。</p><p>第一个字符为第一条边的计算符号( $t$ 代表 $+$，$x$ 代表 $\times$)，第二个代表顶点上的数字。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共有两行，第一行，输出最高的分数。</p><p>在第二行，输出所有可能的被清除后的边仍能得到最高得分的列表。请按照递增的顺序给出。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">t -7 t 4 x 2 x 5</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">33</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于 $100\%$ 的数据，满足 $1 \leq n \leq 50$，所有输入数据均在$\lbrack -2^{16} , 2^{16} \rbrack$ 范围内。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>上古时期的 $\text{IOI}$ 签到题……</p><p>题目中要求求出所有可能情况中的最大值，无疑是区间$\text{dp}$。</p><p>又因为题目中给出的是一个环，考虑断环成链，即$a_{i + n} = a_i$。</p><p>之后考虑如何 $\text{dp}$，设 $f[i][j]$ 表示从 $i$ 到 $j$ 的最大得分。初始时，有 $f[i][i] = a[i]$</p><p>对于加法操作，则有：</p><script type="math/tex; mode=display">f[i][j] = \max(f[i][j] , f[i][k] + f[k + 1][j])</script><p>但<strong>乘法操作会出现负负得正</strong>的情况，因此我们还需要记录最小值。设 $g[i][j]$ 表示从 $i$ 到 $j$ 的最小得分，则有：</p><script type="math/tex; mode=display">g[i][j] = \min(g[i][k] , g[i][k] + g[k + 1][j])</script><p>对于乘法操作，则有：</p><script type="math/tex; mode=display">f[i][j] = \max \{f[i][j] , f[i][k] \times f[k + 1][j] , f[i][k] \times g[k + 1][j] , g[i][k] \times f[k + 1][j] , g[i][k] \times g[k + 1][j] \};</script><script type="math/tex; mode=display">g[i][j] = \min \{g[i][j] , f[i][k] \times f[k + 1][j] , f[i][k] \times g[k + 1][j] , g[i][k] \times f[k + 1][j] , g[i][k] \times g[k + 1][j] \};</script><p>最后统计 <script type="math/tex">\max \{f[i][i + n - 1] , i∈ \lbrack 1 , n \rbrack \}</script>，并记录答案输出即可。</p><p>时间复杂度为 $O(n^3)$ ，足以跑过全部数据。</p><p>剩下的细节见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(), f = <span class="number">0</span>; x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) f = (c == <span class="string">&#x27;-&#x27;</span>), c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">105</span>][<span class="number">105</span>] , g[<span class="number">105</span>][<span class="number">105</span>]; <span class="comment">//f[i][j] i -&gt; j的最大得分 , g[i][j] i -&gt; j的最小得分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    f[i][j] = max(f[i][j] , f[i][k] + f[k+1][j]);</span></span><br><span class="line"><span class="comment">    g[i][j] = min(g[i][j] , g[i][k] + g[k+1][j]);</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[M]; </span><br><span class="line"><span class="keyword">char</span> c[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c[i] &gt;&gt; a[i];    <span class="comment">//用 cin 避免读入空格</span></span><br><span class="line">        c[i + n] = c[i] , a[i + n] = a[i];  <span class="comment">//断环成链</span></span><br><span class="line">    &#125;</span><br><span class="line">    clean(f , <span class="number">-0x3f3f3f3f</span>) , clean(g , <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    rep(i , <span class="number">1</span> , <span class="number">2</span> * n) f[i][i] = g[i][i] = a[i];    <span class="comment">//初始化dp状态</span></span><br><span class="line">    rep(l , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + l &lt;= <span class="number">2</span> * n; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + l;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; j; k ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c[k + <span class="number">1</span>] == <span class="string">&#x27;t&#x27;</span>)&#123;    <span class="comment">//加法操作</span></span><br><span class="line">                    f[i][j] = max(f[i][j] , f[i][k] + f[k + <span class="number">1</span>][j]);</span><br><span class="line">                    g[i][j] = min(g[i][j] , g[i][k] + g[k + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(c[k + <span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span>)&#123;   <span class="comment">//乘法操作</span></span><br><span class="line">                    f[i][j] = max(f[i][j] , max(f[i][k] * f[k + <span class="number">1</span>][j] , max(f[i][k] * g[k + <span class="number">1</span>][j] , max(g[i][k] * f[k + <span class="number">1</span>][j] , g[i][k] * g[k + <span class="number">1</span>][j]))));</span><br><span class="line">                    g[i][j] = min(g[i][j] , min(g[i][k] * g[k + <span class="number">1</span>][j] , min(g[i][k] * f[k + <span class="number">1</span>][j] , min(f[i][k] * f[k + <span class="number">1</span>][j] , f[i][k] * g[k + <span class="number">1</span>][j]))));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = -INT_MAX;  <span class="comment">//统计最后答案</span></span><br><span class="line">    rep(i , <span class="number">1</span> , n) res = max(res , f[i][i + n - <span class="number">1</span>]); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , res);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i][i + n - <span class="number">1</span>] == res) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span> , i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 区间dp </tag>
            
            <tag> Luogu </tag>
            
            <tag> IOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TJOI2017】可乐-题解</title>
      <link href="2020/08/10/luoguP3758/"/>
      <url>2020/08/10/luoguP3758/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>加里敦星球的人们特别喜欢喝可乐。</p><p>因而，他们的敌对星球研发出了一个可乐机器人，并且放在了加里敦星球的 $1$ 号城市上。</p><p>这个可乐机器人有三种行为，分别是：</p><ul><li>停在原地</li><li>去下一个相邻的城市</li><li>自爆</li></ul><p>它每一秒都会随机触发一种行为。现在给加里敦星球城市图，在第 $0$ 秒时可乐机器人在 $1$ 号城市。</p><p>问经过了 $t$ 秒，可乐机器人的行为方案数是多少？</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入两个正整数 $n , m$，分别表示城市个数与道路个数。</p><p>接下来 $m$ 行每行两个整数 $u,v$，表示 $u,v$ 之间有一条道路。</p><p>最后一行是一个整数 $t$，表示经过的时间。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出可乐机器人的行为方案数。</p><p>答案可能很大，请输出对 $2017$ 取模后的结果。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于 $20\%$ 的数据，保证 $1 \leq t \leq 1000$。</p><p>对于 $100\%$ 的数据，保证 $1 \leq t \leq 10^6$ ，$1 \leq n \leq 30$，$0 &lt; m &lt; 100$，$1 \leq u, v \leq n$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>矩阵乘法的简单应用。</p><p>读完题发现 $n$ 很小，可以使用邻接矩阵存图。</p><p>考虑邻接矩阵幂的意义。</p><p>设该邻接矩阵为 $A$ ，则 $A^k$ 中，第 $i$ 行第 $j$ 列表示从点 $i$ 到点 $j$ 经过恰好 $k$ 步的方案数。</p><p>这样的话，我们只需要将邻接矩阵 $A$ 建出来，之后用矩阵快速幂计算 $A^k$ ，最后统计 $\sum_{i = 1}^n A[1][i]$ 即可。</p><p>但问题来了，原地停留和自爆如何处理？</p><p>原地停留的话，我们只需要将每个点向自己连一条边即可。</p><p>而自爆的话，我们可以将每个点向一个超级汇点连一条边，而这个超级汇点本身没有任何出边。这样的话就满足了一个点随时可以自爆同时无法回到之前的状态</p><p>时间复杂度为 $O(l^3 \log t)$，其中 $l$ 为邻接矩阵的边长。在本题中 $l = n$，足以通过 $100\%$ 的数据。</p><p>细节部分见代码即可。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ldb long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">2017</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2047483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9023372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    ll data[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix A;</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;A , <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">    Matrix C; clean(C.data , <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    rep(i , <span class="number">0</span> , <span class="number">30</span>)&#123;</span><br><span class="line">        rep(j , <span class="number">0</span> , <span class="number">30</span>)&#123;</span><br><span class="line">        rep(k , <span class="number">0</span> , <span class="number">30</span>)&#123;</span><br><span class="line">                C.data[i][j] += A.data[i][k] * B.data[k][j];</span><br><span class="line">            C.data[i][j] %= HA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">Pow</span><span class="params">(Matrix A , ll k)</span></span>&#123;</span><br><span class="line">    Matrix B; clean(B.data , <span class="number">0</span>);</span><br><span class="line">    rep(i , <span class="number">0</span> , <span class="number">30</span>) B.data[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &amp; <span class="number">1</span>)&#123;</span><br><span class="line">        B = B * A;</span><br><span class="line">    &#125;</span><br><span class="line">    A = A * A;</span><br><span class="line">    k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n , m , u , v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;n , &amp;m);</span><br><span class="line">    rep(i , <span class="number">1</span> , m)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;u , &amp;v);</span><br><span class="line">    A.data[u][v] = A.data[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    A.data[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">    A.data[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    A.data[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tim; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;tim);</span><br><span class="line">    Matrix ans = Pow(A , tim);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    rep(i , <span class="number">0</span> , n)&#123;</span><br><span class="line">    res += ans.data[<span class="number">1</span>][i];</span><br><span class="line">    res %= HA;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 各省省选 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 矩阵运算 </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法笔记】Dsu On Tree</title>
      <link href="2020/08/07/dsu-on-tree/"/>
      <url>2020/08/07/dsu-on-tree/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>$\text{Dsu On Tree}$，即树上启发式合并。可用来解决<strong>不带修的子树查询问题</strong></p><p>其核心思想在于<strong>运用重链剖分中重儿子的性质进行优化</strong>，以达到简便计算的效果。</p><hr><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>为方便讲述，我们先引入一道例题：<a href="https://www.luogu.com.cn/problem/CF600E">Codeforces 600E Lomsat gelral</a>。</p><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵 $n(0 \leq n \leq 10^5)$ 个节点的树，每个节点有一个编号 $d$ 和颜色 $v$。</p><p>请求出以每个节点为根的子树中最多的颜色的节点编号和。</p><p>形象化的说，设子树 $S$ 中最多的颜色的节点集合为 $V$，即求出：</p><script type="math/tex; mode=display">\sum_{i \in S , i \in V} d[i]</script><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先考虑如何写 $O(n^2)$ 的暴力。</p><p>显然，我们可以遍历每个节点并统计其子树中的答案，然后消除其贡献以保证不对下一次统计产生影响。时间复杂度为 $O(n^2)$，无法通过本题。</p><p>这时，$\text{Dsu On Tree}$ 就可以派上用场了。</p><p>我们先进行一次 $\text{dfs}$ ，求出每个点的子树大小，并选出其重儿子。</p><p>之后对于每个节点，进行如下操作：</p><ul><li>统计出所有轻儿子的 $ans$，并消除贡献。</li><li>统计其重儿子的 $ans$，不消除贡献。</li><li>暴力将所有轻儿子的 $ans$ 加入到该节点的 $ans$ 中</li><li>消除所有轻儿子对于该节点的影响。</li></ul><p>用代码写出来是这个样子的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> fa , <span class="keyword">int</span> opt)</span></span>&#123;    <span class="comment">//opt 指是否需要删除的标记，为0表示需要，1表示不需要</span></span><br><span class="line">    PE(i , x)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to == fa || to == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            calc(to , x , <span class="number">0</span>);   <span class="comment">//计算轻儿子的答案，并消除影响</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) calc(son[x] , x , <span class="number">1</span>);    <span class="comment">//计算重儿子的答案，并不消除影响</span></span><br><span class="line">    </span><br><span class="line">    add(x , fa , <span class="number">1</span>);    <span class="comment">//加入所有轻儿子的答案</span></span><br><span class="line">    ans[x] = Now_ans;   <span class="comment">//更新答案</span></span><br><span class="line">    <span class="keyword">if</span>(opt == <span class="number">0</span>) add(x , fa , <span class="number">-1</span>);  <span class="comment">//如果需要删除贡献就删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来是 $O(n^2)$ 的，但实际上它是 $O(n \log n)$ 的。</p><hr><h2 id="复杂度证明"><a href="#复杂度证明" class="headerlink" title="复杂度证明"></a>复杂度证明</h2><p>也许你要问了：这都是暴力统计，为什么是 $O(n \log n)$ 的呐？</p><p>下面我们就来证明这个问题。</p><p>首先，我们需要知道一个性质：<strong>在一棵树上，一个节点到根节点的路径上的边数不会超过</strong> $\log n$ <strong>条</strong></p><p>然而这个性质并不能直接解决问题。我们<strong>考虑一个点会在什么时候被访问到</strong>。</p><p>显然，这有两种情况，分别是：</p><ol><li>在暴力统计轻儿子时候被访问到，次数为 $\log n$。</li><li>在统计重儿子时候被访问到，次数为 $1$。</li></ol><p>综上所述，时间复杂度为 $O(n \log n)$。</p><hr><h2 id="Code-Codeforces-600E"><a href="#Code-Codeforces-600E" class="headerlink" title="Code[Codeforces 600E]"></a>Code[Codeforces 600E]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ldb long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2047483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9023372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , last;</span><br><span class="line">&#125;edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;to , head[from]&#125;; head[from] = edge_num;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;from , head[to]&#125;; head[to] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size[M] , son[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> fa)</span></span>&#123;   <span class="comment">//统计重儿子与子树大小</span></span><br><span class="line">    size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">-1</span>;</span><br><span class="line">    PE(i , x)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        size[x] += dfs1(to , x);</span><br><span class="line">        <span class="keyword">if</span>(size[to] &gt; maxn)&#123;</span><br><span class="line">            maxn = size[x];</span><br><span class="line">            son[x] = to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll maxn , sum , SON , col[M] , cnt[M];  <span class="comment">//SON 指代当前点的重儿子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> fa , <span class="keyword">int</span> val)</span></span>&#123;     <span class="comment">//将轻儿子的答案加入贡献中</span></span><br><span class="line">    cnt[col[x]] += val;</span><br><span class="line">    <span class="keyword">if</span>(cnt[col[x]] &gt; maxn) maxn = cnt[col[x]] , sum = col[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt[col[x]] == maxn) sum += col[x];</span><br><span class="line">    PE(i , x)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to == fa || to == SON) <span class="keyword">continue</span>;</span><br><span class="line">        add(to , x , val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> fa , <span class="keyword">int</span> opt)</span></span>&#123;    </span><br><span class="line">    PE(i , x)&#123;  <span class="comment">//统计所有轻儿子的答案，并消除影响</span></span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(to != son[x])&#123;</span><br><span class="line">            calc(to , x , <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) calc(son[x] , x , <span class="number">1</span>) , SON = son[x]; <span class="comment">//统计重儿子的答案，不消除影响</span></span><br><span class="line"></span><br><span class="line">    add(x , fa , <span class="number">1</span>); SON = <span class="number">0</span>;   <span class="comment">//将所有轻儿子的答案加入到子树中</span></span><br><span class="line">    ans[x] = sum;</span><br><span class="line">    <span class="keyword">if</span>(opt == <span class="number">0</span>) add(x , fa , <span class="number">-1</span>) , maxn = <span class="number">0</span>;   <span class="comment">//如果需要则消除所有轻儿子影响</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;n);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;col[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u , v;</span><br><span class="line">    rep(i , <span class="number">1</span> , n - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;u , &amp;v);</span><br><span class="line">        add_edge(u , v);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">    calc(<span class="number">1</span> , <span class="number">0</span> , <span class="number">1</span>);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span> , ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树上启发式合并 </tag>
            
            <tag> 启发式合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LYOI】LYOI2020 Summer Competition1题解&amp;命题总结</title>
      <link href="2020/07/30/LYOI2020SummerCompetition1/"/>
      <url>2020/07/30/LYOI2020SummerCompetition1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>AK这场比赛？真的有手就行！</p><hr><h2 id="烦人的二元组"><a href="#烦人的二元组" class="headerlink" title="烦人的二元组"></a>烦人的二元组</h2><p>题目链接：<a href="https://lyoi.cc/problem/686">Link</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目大意即给你一个只由 <code>pair</code> 与 <code>int</code> 组成的字符串，问是否可以组成类似于 <code>pair&lt;__ , __&gt;</code> 的形式。其中 <code>__</code> 可以是 <code>int</code> 或合法的 <code>pair&lt;__ , __&gt;</code>。</p><p>因为需要在原字符串的基础上进行拼接，使用 <code>string</code> 存储答案串。</p><p>将原串分为一个个由空格隔开的字符串，依次读入。</p><p>如果读入的是<code>pair</code>，则在答案串基础上拼接<code>pair&lt;</code>，并再次递归读入后面的两个元素。</p><p>若为<code>int</code>，则直接拼接<code>int</code>。</p><p>最后多进行一次读入，确保最后没有多余字符即可。</p><p><strong>注意：单独一个</strong> <code>int</code> <strong>也是可以通过编译的</strong></p><p>剩下的就是代码实现的问题了。</p><h3 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9223372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">string</span> s , ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cin</span> &gt;&gt; s)&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="string">&quot;pair&quot;</span>)&#123;</span><br><span class="line">ans += <span class="string">&quot;pair&lt;&quot;</span>;</span><br><span class="line">input();</span><br><span class="line">ans += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">input();</span><br><span class="line">ans += <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;int&quot;</span>) ans += <span class="string">&quot;int&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;pair.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;pair.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">input();</span><br><span class="line"><span class="keyword">if</span> (!flag) ans = <span class="string">&quot;Compile Error&quot;</span>; </span><br><span class="line">getline(<span class="built_in">cin</span>, s);</span><br><span class="line"><span class="keyword">if</span> (s.size()) ans = <span class="string">&quot;Compile Error&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="不确定的括号序列"><a href="#不确定的括号序列" class="headerlink" title="不确定的括号序列"></a>不确定的括号序列</h2><p>题目链接：<a href="https://lyoi.cc/problem/684">Link</a></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>题目大意即给你由 <code>(</code>  , <code>)</code> , <code>?</code> 组成的字符串，每一个 <code>?</code> 被换成左右括号分别要花费不同价值，问最少花费多少使得所有 <code>?</code> 均被换掉且该括号序列匹配。</p><h3 id="70pts"><a href="#70pts" class="headerlink" title="70pts"></a>70pts</h3><p>考虑$\text{dp}$。</p><p>设 $f[i][j]$ 表示考虑字符串的前 $i$ 位，前面有 $j$ 个左括号未经匹配的最小花费。显然，答案就是 $f[len][0]$。</p><p>之后考虑转移，转移时可以枚举每个 <code>?</code> 是被替换成左括号还是右括号，即</p><script type="math/tex; mode=display">f[i][j] = \min\{f[i - 1][j - 1] + a_i , f[i - 1][j + 1] + b_i\}</script><p>时间复杂度为 $O(n^2)$，可以得到 $70$ 分的好成绩。 </p><hr><h3 id="100pts"><a href="#100pts" class="headerlink" title="100pts"></a>100pts</h3><p>满分做法是个不太好想的贪心。</p><p>考虑判断一个括号序列是否合法的方法：对于一个只含有 <code>(</code> , <code>)</code>  的括号序列，判断其是否合法的方式是将<code>(</code>全部换成$1$，<code>)</code>全部换成$−1$，对其做一遍前缀和。</p><p>若前缀和数组的每一个元素均大于等于$0$且最后一个元素为$0$，则该序列合法。</p><p>可以看出，如果不考虑最后一个元素为 $0$ 的条件，则这个括号序列可以全为<code>(</code>。</p><p>换句话说，中间的<code>)</code>是不合法的关键。</p><p>因此我们先将所有的<code>?</code>均换为<code>)</code>。之后对其进行修正。</p><p>对于一个没有匹配的<code>)</code>，考虑将其本身或其之前没有被换掉的位置换为<code>(</code>。对此，我们贪心的选择花费最小的一个换掉，使用优先队列维护即可。</p><p>若无法找到能够替换的位置或最后左右括号数目不等则无解，输出<code>-1</code>即可。</p><p>时间复杂度为 $O(n \log n)$，足以通过本题</p><h3 id="Code-Accepted-1"><a href="#Code-Accepted-1" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9223372036854775807</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val , pla;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[M];</span><br><span class="line"> </span><br><span class="line">ll cnt , ans;</span><br><span class="line"><span class="keyword">char</span> s[M &lt;&lt; <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Node&gt; Q;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;bracket.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;bracket.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span> , s);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span> , r = <span class="number">0</span>;</span><br><span class="line">    rep(i , <span class="number">0</span> , <span class="built_in">strlen</span>(s) - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) l ++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r ++;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> a , b;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;a , &amp;b);</span><br><span class="line">                ans += b;</span><br><span class="line">                node[++ cnt].val = b - a;</span><br><span class="line">                node[cnt].pla = i;</span><br><span class="line">                Q.push(node[cnt]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r &gt; l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Q.empty()) <span class="keyword">break</span>;</span><br><span class="line">            Node fro = Q.top(); Q.pop();</span><br><span class="line">            ans -= fro.val;</span><br><span class="line">            l ++; r --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="动人的小情歌"><a href="#动人的小情歌" class="headerlink" title="动人的小情歌"></a>动人的小情歌</h2><p>题目链接：<a href="https://lyoi.cc/problem/692">Link</a></p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>题目大意即定义一个字符串是好的，当且仅当该字符串仅由 <code>A</code>,<code>B</code>,<code>C</code> 三种字符构成，且没有连续的 $3$ 个 <code>A</code> 或 $2$ 个 <code>B</code>。</p><p>多次询问长度为 $n$ 的好的字符串个数。</p><h3 id="70pts-1"><a href="#70pts-1" class="headerlink" title="70pts"></a>70pts</h3><p>考虑一个个的把字母加到字符串的最后的过程。</p><p>设 $f[i][0/1/2][0/1]$ 表示字符串前 $i$ 位，末尾有连续 $0/1/2$ 个 <code>A</code>，有 $0/1$ 个 <code>B</code> 的方案数。</p><p>显然，答案为：</p><script type="math/tex; mode=display">f[n][0][0] + f[i][1][0] + f[i][2][0] + f[i][0][1]</script><p>之后考虑转移，可以推出以下式子：</p><script type="math/tex; mode=display">f[i][0][0]= f[i−1][0][0]+ f[i−1][1][0]+ f[i−1][2][0]+f[i−1][0][1]</script><script type="math/tex; mode=display">f[i][0][1] = f[i−1][0][0] + f[i−1][1][0] + f[i−1][2][0]</script><script type="math/tex; mode=display">f[i][1][0] = f[i−1][0][0] + f[i−1][0][1]</script><script type="math/tex; mode=display">f[i][2][0] = f[i−1][1][0]</script><p>大力转移即可。</p><p>时间复杂度$O(n)$，面对$10^{18}$的数据显得无能为力，但还是能拿到 $n \leq 10^5$ 的 $70$ 分</p><hr><h3 id="100pts-1"><a href="#100pts-1" class="headerlink" title="100pts"></a>100pts</h3><p>考虑如何优化上面的$\text{dp}$。</p><p>矩阵乘法！</p><p>将定义的状态化为矩阵，即</p><script type="math/tex; mode=display">\begin{matrix}f_{i , 0 , 0} & f_{i , 1 , 0} & f_{i , 2 ,  0} & f_{i , 0 , 1} \end{matrix}</script><p>该矩阵由以下矩阵转移而来</p><script type="math/tex; mode=display">\begin{matrix}f_{i-1 , 0 , 0} & f_{i-1 , 1 , 0} & f_{i-1 , 2 ,  0} & f_{i-1 , 0 , 1} \end{matrix}</script><p>即</p><script type="math/tex; mode=display">\begin{matrix}    f_{i , 0 , 0} & f_{i , 1 , 0} & f_{i , 2 ,  0} & f_{i , 0 , 1} \\\end{matrix}=\begin{matrix}    f_{i-1 , 0 , 0} & f_{i-1 , 1 , 0} & f_{i-1 , 2 ,  0} & f_{i-1 , 0 , 1} \\\end{matrix}\times Base</script><p>其中 $Base$ 为转移矩阵。</p><p>根据上面推出的式子，可得出</p><script type="math/tex; mode=display">Base = \begin{matrix}    1 & 1 & 0 & 1\\    1 & 0 & 1 & 1\\    1 & 0 & 0 & 1\\    1 & 1 & 0 & 0\\\end{matrix}</script><p>写一个矩阵快速幂即可</p><p>单次询问时间复杂度为$𝑂(𝑙^3  \log ⁡𝑛)$，其中 $𝑙$ 为转移矩阵的边长，本题中$𝑙 = 4$，足以通过 $10^{18}$ 的大数据。</p><h3 id="Code-Accepted-2"><a href="#Code-Accepted-2" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ldb long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2047483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9023372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">ll data[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;A , <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">    Matrix C; clean(C.data , <span class="number">0</span>);</span><br><span class="line">    rep(i , <span class="number">1</span> , <span class="number">4</span>)&#123;</span><br><span class="line">        rep(j , <span class="number">1</span> , <span class="number">4</span>)&#123;</span><br><span class="line">            rep(k , <span class="number">1</span> , <span class="number">4</span>)&#123;</span><br><span class="line">                C.data[i][j] += A.data[i][k] * B.data[k][j] % HA;</span><br><span class="line">                C.data[i][j] %= HA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">Pow</span><span class="params">(Matrix A , Matrix B , ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            A = A * B;</span><br><span class="line">        &#125;</span><br><span class="line">        B = B * B;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;music.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;music.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">ll t , n; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span> , &amp;n);</span><br><span class="line">Matrix A , B; clean(A.data , <span class="number">0</span>); clean(B.data , <span class="number">0</span>);</span><br><span class="line">B.data[<span class="number">1</span>][<span class="number">1</span>] = B.data[<span class="number">1</span>][<span class="number">2</span>] = B.data[<span class="number">1</span>][<span class="number">4</span>] = B.data[<span class="number">2</span>][<span class="number">1</span>] = B.data[<span class="number">2</span>][<span class="number">3</span>] = B.data[<span class="number">2</span>][<span class="number">4</span>] = B.data[<span class="number">3</span>][<span class="number">1</span>] = B.data[<span class="number">3</span>][<span class="number">4</span>] = B.data[<span class="number">4</span>][<span class="number">1</span>] = B.data[<span class="number">4</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">A.data[<span class="number">1</span>][<span class="number">1</span>] = A.data[<span class="number">1</span>][<span class="number">2</span>] = A.data[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">A = Pow(A , B , n - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , (A.data[<span class="number">1</span>][<span class="number">1</span>] + A.data[<span class="number">1</span>][<span class="number">2</span>] + A.data[<span class="number">1</span>][<span class="number">3</span>] + A.data[<span class="number">1</span>][<span class="number">4</span>]) % HA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="命题总结"><a href="#命题总结" class="headerlink" title="命题总结"></a>命题总结</h2><p>这次的题目的满分做法分别是模拟，贪心，数学。且后两题对同学们的思维要求较大。</p><p>但与之相对的是非完美的 $\text{dp}$ 也能拿到不错的分数，且第三题的正解是在 $\text{dp}$ 的基础上进行优化，对正解有极强的启发作用。</p><p>因此，这次的题目在提高组的要求难度之内。</p><p>想要备战明年省选的同学们需要拿到 $240$ 分以上，以省一为目标的同学也需要拿到至少 $180$ 分。</p><p>同时，有同学因为理解错题意而导致错误。在这里作者要强调：<strong>理解与简化题意也是很重要的一项技能，需要多加练习</strong>。</p><p>请各位同学认真订正并仔细反思。</p><hr><h2 id="Easter-Egg"><a href="#Easter-Egg" class="headerlink" title="Easter Egg"></a>Easter Egg</h2><ol><li><del>题目中的名字是真实存在的</del></li><li>第三题稍微玩了一下白学梗，但没那么明显(打过WA2的同学应该能看出来)</li></ol><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 命题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> LYOI </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 矩阵运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOI Online 3】魔法值-题解</title>
      <link href="2020/06/19/luoguP6569/"/>
      <url>2020/06/19/luoguP6569/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>H 国的交通由 $n$ 座城市与 $m$ 条道路构成，城市与道路都从 $1$ 开始编号，其中 $1$ 号城市是 H 国的首都。</p><p>H 国中一条道路将把两个不同城市直接相连，且任意两个城市间至多有一条道路。</p><p>H 国是一个信奉魔法的国家，在第 $j$ 天，$i$ 号城市的魔法值为 $f_{i,j}$。</p><p>H 国的魔法师已观测到第 $0$ 天时所有城市的魔法值 $f_{i,0}$ ，且他们还发现，之后的每一天每个城市的魔法值，都将会变为所有与该城市直接相连的城市的前一天魔法值的异或值，即</p><script type="math/tex; mode=display">f_{x,j}=f_{v_1,j-1}\oplus f_{v_2,j-1}\oplus \cdots\oplus f_{v_k,j-1}</script><p>其中 $j\ge 1$，$v_1,v_2,\cdots,v_k$是所有与 $x$ 号城市直接相连的城市，$\oplus$ 为异或运算。</p><p>现在 H 国的国王问了你 $q$ 个问题，对于第 $i$ 个问题你需要回答：第 $a_i$ 天时首都的魔法值是多少。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行三个用空格分隔的整数 $n,m,q$，表示城市数、道路数与问题数。</p><p>第二行 $n$ 个用空格分隔的整数，第 $i$ 个整数表示 $f_{i, 0}$。</p><p>接下来 $m$ 行，每行两个用空格分隔的正整数 $u,v$，表示一条连接 $u$ 号城市与 $v$ 号城市的道路。</p><p>接下来 $q$ 行每行一个整数，第 $i$ 行的整数表示 $a_i$ 。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>按顺序输出 $q$ 行，每行一个整数，表示对应问题的答案。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 3 1</span><br><span class="line">0 0 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $20\%$ 的数据，满足 $a_i \leq 100$。<br>对于 $40\%$ 的数据，满足 $n \leq 20$。<br>另有 $30\%$ 的数据，满足 $m=\frac{n(n-1)}{2}$。<br>对于 $100\%$ 的数据，满足 $1 \leq n,q \leq 1001≤n,q≤100，1 \leq m \leq \frac{n(n-1)}{2}$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>倍增预处理 + 矩阵加速。</p><p>认真读一遍题，发现 $n$ 很小，可以使用邻接矩阵存图。</p><p>再看一下题目中给出的式子</p><script type="math/tex; mode=display">f_{x,j}=f_{v_1,j-1}\oplus f_{v_2,j-1}\oplus \cdots\oplus f_{v_k,j-1}</script><p>设$i , j$两点之间连边为 $e_{i , j}$，两点间有边为$1$，否则为$0$，则原式子可以化为</p><script type="math/tex; mode=display">f_{x , j} = f_{1 , j - 1} \times e_{1 , x} \oplus f_{2 , j - 1} \times e_{2 , x} \oplus \cdots \oplus f_{n , j - 1} \times e_{n , x}</script><p>不难看出，这与矩阵乘法的定义式长的很像，只是把$+$改成了$\oplus$而已。</p><p>这样的话，根据矩阵乘法的定义，图中每个城市第$i$天的魔法值就可以通过其$i - 1$天的魔法值与其邻接矩阵进行异或得到。</p><p>然后我们就有了一个很无脑的做法：对于每次询问均进行矩阵快速幂，时间复杂度为$O(q \times n^3 \log a)$，可以拿到$40$分的好成绩。</p><p>考虑如何优化这个过程，不难看出，我们在进行矩阵快速幂的时候每一次都会乘一次初始邻接矩阵，这个过程是很浪费时间的。</p><p>对此，我们进行<strong>二进制拆分</strong>，倍增预处理出$2^i$天时的初始邻接矩阵，需要时候直接乘上即可。</p><p>优化后，预处理时间复杂度为$O(n^3 \log a)$，单次询问为$O(n^2 \log a)$，足以通过本题。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ldb long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2047483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9023372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    ll data[<span class="number">105</span>][<span class="number">105</span>] , h , l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix A , B;</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;A , <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">    Matrix C; clean(C.data , <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    C.h = A.h , C.l = B.l;</span><br><span class="line">    rep(i , <span class="number">1</span> , A.h)&#123;</span><br><span class="line">        rep(j , <span class="number">1</span> , B.l)&#123;</span><br><span class="line">            rep(k , <span class="number">1</span> , A.l)&#123;</span><br><span class="line">                C.data[i][j] ^= A.data[i][k] * B.data[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix twop[<span class="number">50</span>];  <span class="comment">//twop[i] 初始邻接矩阵第2^i天时的值</span></span><br><span class="line">ll f[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span> , &amp;n , &amp;m , &amp;q);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span> , &amp;f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    twop[<span class="number">0</span>].h = twop[<span class="number">0</span>].l = n;</span><br><span class="line">    <span class="keyword">int</span> u , v;</span><br><span class="line">    rep(i , <span class="number">1</span> , m)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;u , &amp;v);</span><br><span class="line">        twop[<span class="number">0</span>].data[u][v] = twop[<span class="number">0</span>].data[v][u] = <span class="number">1</span>;    <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    &#125;</span><br><span class="line">    rep(i , <span class="number">1</span> , <span class="number">31</span>)&#123;</span><br><span class="line">        twop[i] = twop[i - <span class="number">1</span>] * twop[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//预处理第2^i天的邻接矩阵</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll day;</span><br><span class="line">    <span class="keyword">while</span>(q --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span> , &amp;day);</span><br><span class="line">        Matrix ans;</span><br><span class="line">        rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">            ans.data[<span class="number">1</span>][i] = f[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans.h = <span class="number">1</span> , ans.l = n;</span><br><span class="line">        rep(i , <span class="number">0</span> , <span class="number">31</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((day &gt;&gt; i) &amp; <span class="number">1</span>)&#123; <span class="comment">//若这一天需要用上，则直接相乘</span></span><br><span class="line">                ans = ans * twop[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans.data[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 倍增 </tag>
            
            <tag> 矩阵运算 </tag>
            
            <tag> Luogu </tag>
            
            <tag> NOI Online </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOI2016】区间-题解</title>
      <link href="2020/06/04/luoguP1712/"/>
      <url>2020/06/04/luoguP1712/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>在数轴上有 $n$ 个闭区间 $[l_1,r_1],[l_2,r_2],…,[l_n,r_n]$。</p><p>现在要从中选出 $m$ 个区间，使得这 $m$ 个区间共同包含至少一个位置。</p><p>换句话说，就是使得存在一个  $x$，使得对于每一个被选中的区间 $[l_i,r_i]$，都有 $l_i\leq x\leq r_i$。</p><p>对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。区间 $[l_i,r_i]$ 的长度定义为 $r_i−l_i$，即等于它的右端点的值减去左端点的值。</p><p>求所有合法方案中最小的花费。如果不存在合法的方案，输出 $−1$。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数 $n,m$ 用空格隔开，意义如上文所述。保证 $1\leq m\leq n$。</p><p>接下来 $n$ 行，每行表示一个区间，包含用空格隔开的两个整数 $l_i$ 和 $r_i$ 为该区间的左右端点。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有一行，包含一个正整数，即最小花费。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">3 5</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">2 2</span><br><span class="line">1 5</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><hr><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p><img src= "/img/loading.gif" data-lazy-src="http://img.uoj.ac/problem/222/seg.png" alt=""></p><p>如图，当 $n=6,m=3$ 时，花费最小的方案是选取 $[3,5]$、$[3,4]$、$[1,4]$ 这三个区间，他们共同包含了 $4$ 这个位置，所以是合法的。其中最长的区间是 $[1,4]$，最短的区间是 $[3,4]$，所以它的花费是 $(4−1)−(4−3)=2$。</p><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><!-- BEGIN: Migrated markdown table --><div class="table-container"><table><thead><tr><th style="text-align:center">测试点编号</th><th style="text-align:center">$ n $</th><th style="text-align:center">$ m $</th><th style="text-align:center">$ l_i,r_i $</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$ 20 $</td><td style="text-align:center">$ 9 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 100 $</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$ 20 $</td><td style="text-align:center">$ 10 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 100 $</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$ 199 $</td><td style="text-align:center">$ 3 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 100000 $</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$ 200 $</td><td style="text-align:center">$ 3 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 100000 $</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">$ 1000 $</td><td style="text-align:center">$ 2 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 100000 $</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">$ 2000 $</td><td style="text-align:center">$ 2 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 100000 $</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">$ 199 $</td><td style="text-align:center">$ 60 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 5000 $</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">$ 200 $</td><td style="text-align:center">$ 50 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 5000 $</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">$ 200 $</td><td style="text-align:center">$ 50 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 10^9 $</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">$ 1999 $</td><td style="text-align:center">$ 500 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 5000 $</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">$ 2000 $</td><td style="text-align:center">$ 400 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 5000 $</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">$ 2000 $</td><td style="text-align:center">$ 500 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 10^9 $</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">$ 30000 $</td><td style="text-align:center">$ 2000 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 100000 $</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">$ 40000 $</td><td style="text-align:center">$ 1000 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 100000 $</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">$ 50000 $</td><td style="text-align:center">$ 15000 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 100000 $</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">$ 100000 $</td><td style="text-align:center">$ 20000 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 100000 $</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">$ 200000 $</td><td style="text-align:center">$ 20000 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 10^9 $</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">$ 300000 $</td><td style="text-align:center">$ 50000 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 10^9 $</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">$ 400000 $</td><td style="text-align:center">$ 90000 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 10^9 $</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">$ 500000 $</td><td style="text-align:center">$ 200000 $</td><td style="text-align:center">$ 0 \le l_i \le r_i \le 10^9 $</td></tr></tbody></table></div><!-- Migrated from original HTML table:<table class="ui center aligned table"><thead><tr><th>测试点编号</th><th> $ n $ </th><th> $ m $ </th><th> $ l_i,r_i $ </th></tr></thead><tbody><tr><td>1</td><td rowspan="2"> $ 20 $ </td><td> $ 9 $ </td><td rowspan="2"> $ 0 \le l_i \le r_i \le 100 $ </td></tr><tr><td>2</td><td> $ 10 $ </td></tr><tr><td>3</td><td> $ 199 $ </td><td rowspan="2"> $ 3 $ </td><td rowspan="4"> $ 0 \le l_i \le r_i \le 100000 $ </td></tr><tr><td>4</td><td> $ 200 $ </td></tr><tr><td>5</td><td> $ 1000 $ </td><td rowspan="2"> $ 2 $ </td></tr><tr><td>6</td><td> $ 2000 $ </td></tr><tr><td>7</td><td> $ 199 $ </td><td> $ 60 $ </td><td rowspan="2"> $ 0 \le l_i \le r_i \le 5000 $ </td></tr><tr><td>8</td><td rowspan="2"> $ 200 $ </td><td rowspan="2"> $ 50 $ </td></tr><tr><td>9</td><td> $ 0 \le l_i \le r_i \le 10^9 $ </td></tr><tr><td>10</td><td> $ 1999 $ </td><td> $ 500 $ </td><td rowspan="2"> $ 0 \le l_i \le r_i \le 5000 $ </td></tr><tr><td>11</td><td rowspan="2"> $ 2000 $ </td><td> $ 400 $ </td></tr><tr><td>12</td><td> $ 500 $ </td><td> $ 0 \le l_i \le r_i \le 10^9 $ </td></tr><tr><td>13</td><td> $ 30000 $ </td><td> $ 2000 $ </td><td rowspan="4"> $ 0 \le l_i \le r_i \le 100000 $ </td></tr><tr><td>14</td><td> $ 40000 $ </td><td> $ 1000 $ </td></tr><tr><td>15</td><td> $ 50000 $ </td><td> $ 15000 $ </td></tr><tr><td>16</td><td> $ 100000 $ </td><td rowspan="2"> $ 20000 $ </td></tr><tr><td>17</td><td> $ 200000 $ </td><td rowspan="4"> $ 0 \le l_i \le r_i \le 10^9 $ </td></tr><tr><td>18</td><td> $ 300000 $ </td><td> $ 50000 $ </td></tr><tr><td>19</td><td> $ 400000 $ </td><td> $ 90000 $ </td></tr><tr><td>20</td><td> $ 500000 $ </td><td> $ 200000 $ </td></tr></tbody></table>--><!-- END: Migrated markdown table --><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>$\text{NOI}$ 签到题无疑了……</p><p>考虑朴素做法：先将区间从小到大排序，然后按照排序后的顺序依次加入。</p><p>若有一个点的覆盖次数大于$m$，则记录答案并依次将前面插入的区间删除，直到小于$m$为止。</p><p>不难看出，这<strong>利用了尺取法的思想</strong>。</p><p>但这种做法的<strong>瓶颈在于如何快速查询是否有一个点的覆盖次数大于</strong>$m$。很明显，这可以使用线段树维护区间最大值解决。</p><p>然后就做完了。</p><p>顺便提一句，$l , r$的范围很大，需要离散化一下。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500011</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2047483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9023372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l , r , len;</span><br><span class="line">&#125;line[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Line a , Line b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.len &lt; b.len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[M &lt;&lt; <span class="number">1</span>] , cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;   </span><br><span class="line">    <span class="comment">//离散化，返回值为所有线段中最右边的端点。因为建树时需要用到</span></span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">-1</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;line[i].l , &amp;line[i].r);</span><br><span class="line">        line[i].len = line[i].r - line[i].l;</span><br><span class="line">        a[++ cnt] = line[i].l;</span><br><span class="line">        a[++ cnt] = line[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span> , a + <span class="number">1</span> + cnt);</span><br><span class="line">    cnt = unique(a + <span class="number">1</span> , a + <span class="number">1</span> + cnt) - a - <span class="number">1</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        line[i].l = lower_bound(a + <span class="number">1</span> , a + <span class="number">1</span> + cnt , line[i].l) - a;</span><br><span class="line">        line[i].r = lower_bound(a + <span class="number">1</span> , a + <span class="number">1</span> + cnt , line[i].r) - a;</span><br><span class="line">        maxn = max(maxn , line[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Segment_tree&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lson(x) x &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rson(x) x &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> l , r , len;</span><br><span class="line">        <span class="keyword">int</span> num , add , maxn;</span><br><span class="line">    &#125;node[M &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">I <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        node[x].num = node[lson(x)].num + node[rson(x)].num;</span><br><span class="line">        node[x].maxn = max(node[lson(x)].maxn , node[rson(x)].maxn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">I <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node[x].add) <span class="keyword">return</span> ;</span><br><span class="line">        node[lson(x)].add += node[x].add;</span><br><span class="line">        node[lson(x)].num += node[x].add * node[lson(x)].len;</span><br><span class="line">        node[lson(x)].maxn += node[x].add;</span><br><span class="line">        node[rson(x)].add += node[x].add;</span><br><span class="line">        node[rson(x)].num += node[x].add * node[rson(x)].len;</span><br><span class="line">        node[rson(x)].maxn += node[x].add;</span><br><span class="line">        node[x].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        node[x].l = l , node[x].r = r , node[x].len = (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            node[x].num = <span class="number">0</span>;</span><br><span class="line">            node[x].maxn = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(lson(x) , l , mid); </span><br><span class="line">        build(rson(x) , mid + <span class="number">1</span> , r);</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">range_add</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr , <span class="keyword">int</span> add)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= node[x].l &amp;&amp; node[x].r &lt;= qr)&#123;</span><br><span class="line">            node[x].add += add;</span><br><span class="line">            node[x].maxn += add;</span><br><span class="line">            node[x].num += add * (node[x].len);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(x);</span><br><span class="line">        <span class="keyword">int</span> mid = (node[x].l + node[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">            range_add(lson(x) , ql , qr , add);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= qr)&#123;</span><br><span class="line">            range_add(rson(x) , ql , qr , add);</span><br><span class="line">        &#125;</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lson</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rson</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n , m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;n , &amp;m);</span><br><span class="line">    <span class="keyword">int</span> maxn = input(n);</span><br><span class="line">    sort(line + <span class="number">1</span> , line + <span class="number">1</span> + n , cmp);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    Segment_tree :: build(<span class="number">1</span> , <span class="number">1</span> , maxn);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span> , r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(r = <span class="number">1</span>; r &lt;= n; r ++)&#123;   <span class="comment">//尺取模板</span></span><br><span class="line">        Segment_tree :: range_add(<span class="number">1</span> , line[r].l , line[r].r , <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(Segment_tree :: node[<span class="number">1</span>].maxn &gt;= m)&#123;   </span><br><span class="line">            <span class="comment">//node[1]代表整个区间，因此node[1]的max为整个区间的最大值。</span></span><br><span class="line">            ans = min(ans , line[r].len - line[l].len);</span><br><span class="line">            Segment_tree :: range_add(<span class="number">1</span> , line[l].l , line[l].r , <span class="number">-1</span>);</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> NOI </tag>
            
            <tag> 线段树 </tag>
            
            <tag> Luogu </tag>
            
            <tag> 尺取法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SDOI2016】排列计数-题解</title>
      <link href="2020/06/03/luoguP4071/"/>
      <url>2020/06/03/luoguP4071/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>给出两个正整数$n$ , $m$ , 求有多少种排列$A$满足以下条件：</p><ol><li>排列由$1$到$n$构成，即$1~n$各在这个排列中出现一次</li><li>正好有$m$个位置满足$A[i] = i$</li></ol><p>由于答案可能很大，因此你只需要给出答案对于$10^9 + 7$取模的结果即可。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行是一个整数 $t$，代表测试数据的组数</p><p>以下 $t$ 行，每行输入两个整数，依次代表 $n$ 和 $m$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共 $t$ 行。对于每组测试数据，输出一行一个整数代表答案。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 0</span><br><span class="line">1 1</span><br><span class="line">5 2</span><br><span class="line">100 50</span><br><span class="line">10000 5000</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">20</span><br><span class="line">578028887</span><br><span class="line">60695423</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>测试点 1 ~ 3：$ T = 1000 $，$ n \leq 8 $，$ m \leq 8 $；<br>测试点 4 ~ 6：$ T = 1000 $，$ n \leq 12 $，$ m \leq 12 $；<br>测试点 7 ~ 9：$ T = 1000 $，$ n \leq 100 $，$ m \leq 100 $；<br>测试点 10 ~ 12：$ T = 1000 $，$ n \leq 1000 $，$ m \leq 1000 $；<br>测试点 13 ~ 14：$ T = 500000 $，$ n \leq 1000 $，$ m \leq 1000 $；<br>测试点 15 ~ 20：$ T = 500000 $，$ n \leq 1000000 $，$ m \leq 1000000 $。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>组合数学 + 错位排列</p><p>先看第一个条件，不难看出，这是个全排列。</p><p>再看第二个条件，考虑如何设计这样的数列。显然，我们可以在$n$个数中选择$m$个，使得他们满足第二个条件，而对于剩下的$n - m$个数直接进行错位排列即可。</p><p>综上，答案就是</p><script type="math/tex; mode=display">C_{n}^{m} \times D(n - m)</script><p>顺便放出组合数公式与错排公式，没听说过的同学可以顺便补一下</p><script type="math/tex; mode=display">C_{n}^{m} = \frac{n!}{m!(n - m)!}</script><script type="math/tex; mode=display">D(0) = 1 , D(2) = 1 , D(i) = (i - 1) \times (D(i - 1) + D(i - 2))</script><p>剩下的见代码。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2047483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9023372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll a , ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    ll mid = Pow(a , b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(b % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid * mid % HA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (mid * mid % HA) * a % HA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll fac[M] , inv[M] , d[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , M)&#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % HA;   <span class="comment">//预处理阶乘</span></span><br><span class="line">    &#125;</span><br><span class="line">    inv[M] = Pow(fac[M] , HA - <span class="number">2</span>);</span><br><span class="line">    per(i , M , <span class="number">1</span>)&#123;</span><br><span class="line">        inv[i - <span class="number">1</span>] = inv[i] * i % HA;   <span class="comment">//预处理阶乘逆元</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">1</span> , d[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i , <span class="number">3</span> , M)&#123;</span><br><span class="line">        d[i] = (i - <span class="number">1</span>) * (d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>]) % HA;    <span class="comment">//预处理错排</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">int</span> m)</span></span>&#123;    <span class="comment">//根据定义求组合数</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; m || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1l</span>l * fac[n] % HA * inv[m] % HA * inv[n - m] % HA;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n , m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span> , &amp;n , &amp;m);</span><br><span class="line">    <span class="keyword">if</span>(m &gt; n) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , C(n , m) * d[n - m] % HA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    prepare();</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t --) solve();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 各省省选 </tag>
            
            <tag> 数学 </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces】Decreasing Heights-题解</title>
      <link href="2020/05/26/CF1353F/"/>
      <url>2020/05/26/CF1353F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>给出一个 $n \times m$ 的矩阵，每个矩阵的权值代表该点的初始高度。</p><p>现在需要从点 $( 1 , 1 )$ 走到点 $( n , m )$ ，每一步需要满足以下条件：</p><ul><li>只能向右或向下</li><li>设当前格子的高度为 $x$ ，只能移动到高度为 $x + 1$ 的格子上去</li></ul><p>初始时可以进行操作，使得某个格子的高度减少一个单位。</p><p>问最少需要进行多少次操作，可以存在至少一条从点 $( 1 , 1 )$ 到点 $( n , m )$ 的路线</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数$t$，表示数据组数</p><p>其中，每一组数据的第一行包含两个整数$n , m$，表示矩阵的行数与列数</p><p>之后是一个$n \times m$的矩阵，表示初始状态下矩阵中每个点的高度</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组数据，输出一行一个整数，表示最少的操作次数</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4</span><br><span class="line">1 2 3 4</span><br><span class="line">5 6 7 8</span><br><span class="line">9 10 11 12</span><br><span class="line">5 5</span><br><span class="line">2 5 4 8 3</span><br><span class="line">9 10 11 5 1</span><br><span class="line">12 8 4 2 5</span><br><span class="line">2 2 5 4 1</span><br><span class="line">6 8 2 4 2</span><br><span class="line">2 2</span><br><span class="line">100 10</span><br><span class="line">10 1</span><br><span class="line">1 2</span><br><span class="line">123456789876543 987654321234567</span><br><span class="line">1 1</span><br><span class="line">42</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">49</span><br><span class="line">111</span><br><span class="line">864197531358023</span><br><span class="line">0</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $100\%$ 的数据，保证$1 \leq t \leq 100$ , $1 \leq n , m \leq 100$ , $1 \leq a_{i , j} \leq 10^15$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>很套路的$\text{dp}$题，但也有一定难度，放在$\text{Div 3}$的$\text{F}$题完全可以接受</p><p>读完题后，很容易想到此题的一个<strong>弱化版本：给定一个矩阵，每次只可以向下或向右移动，如何行走才能使得经过点的点权之和最大</strong>？</p><p>思考如何把这个题转化过去。不难发现，如果知道了这个点的起点高度$h$，则走到坐标为$(i , j)$的点上高度应该为$h + i + j$。</p><p>所以就有了以下两点推论：</p><ol><li><p>设一个点坐标为$(i , j)$，若$a[i][j] &gt; h + i + j$，则该点不可能被经过。</p></li><li><p>若$a[i][j] \leq h + i + j$，则经过该点所需要的操作次数为$(h + i + j) - a[i][j]$。</p></li></ol><p>也就是说，我们只需要把$a[i][j] \leq h$的点的点权设为$(h + i + j) - a[i][j]$即可。</p><p>然后考虑如何解决上面的弱化版问题。</p><p>设$f[i][j]$表示从$(1 , 1)$走到$(i , j)$所需要的最少次数，则$f[1][1] = 0$。</p><p>之后考虑如何转移。首先，对于点$(i , j)$，有</p><script type="math/tex; mode=display">f[i][j] = f[i][j] + (h + i + j - a[i][j])</script><p>之后考虑向外拓展。若$i + 1 \leq n$，则</p><script type="math/tex; mode=display">f[i + 1][j] = min(f[i + 1][j] , f[i][j])</script><p>$j$也同理，若$j + 1 \leq m$，则</p><script type="math/tex; mode=display">f[i][j + 1] = min(f[i][j + 1] , f[i][j])</script><p>最后在外面套一层$O(n^2)$的枚举，枚举矩阵元素并倒推初始点的权值，即$h = a[i][j] - i - j$。</p><p>每一次$\text{dp}$的时间复杂度为$O(n^2)$，加上外层的枚举，时间复杂度为$O(n^4)$。足以跑过$100\%$的数据。</p><p>剩下的见代码即可。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9023372036854775801</span>;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">101</span>][<span class="number">101</span>] , f[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n , ll m , ll sta)</span></span>&#123;</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        rep(j , <span class="number">1</span> , m)&#123;</span><br><span class="line">            f[i][j] = INFL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        rep(j , <span class="number">1</span> , m)&#123;</span><br><span class="line">            ll val = i + j + sta;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; a[i][j])&#123;</span><br><span class="line">                f[i][j] = INFL;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][j] += a[i][j] - val;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt;= n)&#123;</span><br><span class="line">                f[i + <span class="number">1</span>][j] = min(f[i + <span class="number">1</span>][j] , f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= m)&#123;</span><br><span class="line">                f[i][j + <span class="number">1</span>] = min(f[i][j + <span class="number">1</span>] , f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ll t , n , m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        clean(a , <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span> , &amp;n , &amp;m);</span><br><span class="line">        rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">            rep(j , <span class="number">1</span> , m)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span> , &amp;a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = INFL;</span><br><span class="line">        rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">            rep(j , <span class="number">1</span> , m)&#123;</span><br><span class="line">                ans = min(ans , solve(n , m , a[i][j] - i - j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Codeforces </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HNOI2014】米特运输-题解</title>
      <link href="2020/05/22/luoguP3237/"/>
      <url>2020/05/22/luoguP3237/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>米特是 $\text{D}$ 星球上一种非常神秘的物质，蕴含着巨大的能量。在以米特为主要能源的 $\text{D}$ 星上，这种米特能源的运输和储存一直是一个大问题。</p><p>$\text{D}$星上有$n$个城市，我们将其顺序编号为$1$到$n$，$1$号城市为首都。这$n$个城市由$n-1$条单向高速通道连接起来，构成一棵以$1$号城市（首部）为根的树，高速通道的方向由树中的儿子指向父亲。树按深度分层：根结点深度为$0$，属于第$1$层；根结点的子节点深度为$1$，属于第$2$层；依此类推，深度为$i$的结点属于第$i+l$层。</p><p>建好高速通道之后，$\text{D}$星人开始考虑如何具体地储存和传输米特资源。由于发展程度不同，每个城市储存米特的能力不尽相同，其中第$i$个城市建有一个容量为$a_i$的米特储存器。这个米特储存器除了具有储存的功能，还具有自动收集米特的能力。</p><p>如果到了晚上六点，有某个储存器处于未满的状态，它就会自动收集大气中蕴含的米特能源，在早上六点之前就能收集满；但是，只有在储存器完全空的状态下启动自动收集程序才是安全的，未满而又非空时启动可能有安全隐患。</p><p>早上六点到七点间，根节点城市（$1$号城市）会将其储存器里的米特消耗殆尽。根节点不会自动搜集米特，它只接受子节点传输来的米特。</p><p>早上七点，城市之间启动米特传输过程，传输过程逐层递进：先是第$2$层节点城市向第$1$层（根节点城市，即$1$号城市）传输，直到第$1$层的储存器满或第$2$层的储存器全为空；然后是第$3$层向第$2$层传输，直到对于第$2$层的每个节点，其储存器满或其予节点（位于第$3$层）的储存器全为空；依此类推，直到最后一层传输完成。传输过程一定会在晚上六点前完成。</p><p>由于技术原因，运输方案需要满足以下条件：</p><p>不能让某个储存器到了晚上六点传输结束时还处于非空但又未满的状态，这个时候储存器仍然会启动自动收集米特的程序，而给已经储存有米特的储存器启动收集程序可能导致危险，也就是说要让储存器到了晚上六点时要么空要么满；</p><p>关于首都——即$1$号城市的特殊情况， 每天早上六点到七点间$1$号城市中的米特储存器里的米特会自动被消耗殆尽，即运输方案不需要考虑首都的米特怎么运走；</p><p>除了$1$号城市，每个节点必须在其子节点城市向它运输米特之前将这座城市的米特储存器中原本存有的米特全部运出去给父节点，不允许储存器中残存的米特与外来的米特发生混合；</p><p>运向某一个城市的若干个来源的米特数量必须完全相同，不然，这些来源不同的米特按不同比例混合之后可能发生危险。</p><p>现在$\text{D}$星人已经建立好高速通道，每个城市也有了一定储存容量的米特储存器。为了满足上面的限制条件，可能需要重建一些城市中的米特储存器。你可以，也只能，将某一座城市（包括首都）中原来存在的米特储存器摧毁，再新建一座任意容量的新的米特储存器，其容量可以是小数（在输入数据中，储存器原始容量是正整数，但重建后可以是小数），不能是负数或零，使得需要被重建的米特储存器的数目尽量少。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个正整数$n$，表示城市的数目。</p><p>接下来$n$行，每行一个正整数，其中的第$i$行表示第$i$个城市原来存在的米特储存器的容量。</p><p>再接下来是$n - 1$行，每行两个正整数$a$，$b$表示城市$b$到城市$a$有一条高速通道。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件仅包含一行，一个整数，表示最少的被重建（即修改储存器容量）的米特储存器的数目。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$100\%$的数据满足$1 \leq n \leq 5 \times 10^5$，$1 \leq a_i \leq 10^8$。</p><p>保证输入数据中的$a$与$b$不相同。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>真就tm阅读理解题呗</del></p><p>题意即给你一颗树，需要你改变一些点的点权，使其满足以下性质：</p><ol><li>每个点的子节点权值均相同</li><li>父节点权值为其各子节点的权值和。</li></ol><p>考虑如何计算。仔细观察，不难发现<strong>当一个点的点权确定后，整棵树的点权也将随之确定</strong>。</p><p>设$f[i]$表示$i$节点的权值为$val[i]$时，根节点的权值是$i$节点的几倍。即</p><script type="math/tex; mode=display">val[root] = f[i] \times val[i]</script><p>转移比较简单，为</p><script type="math/tex; mode=display">f[to] = f[x] \times (in[x] - 1)</script><p>其中，$in[x]$表示的是节点$x$的度数(即有多少边与节点$x$相连)。而$in[x] - 1$是因为<strong>每个点对答案产生贡献的边为该点与子节点的连边</strong>，因此，我们需要减去父节点产生的度数</p><p>特别地，对于根节点我们需要特殊处理，即$f[to] = f[1] \times in[x]$。因为根节点没有父亲。</p><p>最后对$f$数组进行排序，如果$f[i] = f[j]$则说明$i$与$j$可以同时满足条件，不需要更改。因此只需找出$f$数组中的最长相等序列，然后用总数减掉即可。</p><p>但还有最后一个问题：节点点权的范围是$10^8$，直接乘一定会溢出。</p><p>对此，我们可以<del>写个高精</del>采用<strong>整数哈希</strong>或者是<strong>利用公式</strong>$log(a) + log(b) = log(a \times b)$转换为加法(<strong>注意可能产生的精度误差</strong>)。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500101</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9223372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , num[M] , in[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , last;</span><br><span class="line">&#125;edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;to , head[from]&#125;; head[from] = edge_num;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;from , head[to]&#125;; head[to] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> fa , <span class="keyword">double</span> val)</span></span>&#123;</span><br><span class="line">    f[x] = val + <span class="built_in">log</span>(num[x]);</span><br><span class="line">    in[x] --;   </span><br><span class="line">    <span class="comment">//对于答案产生贡献的边为该节点与其子节点的连边，因此需要减去父节点的度数   </span></span><br><span class="line">    PE(i , x)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to , x , val + <span class="built_in">log</span>(in[x]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;n);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u , v;</span><br><span class="line">    rep(i , <span class="number">1</span> , n - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;u , &amp;v);</span><br><span class="line">        add_edge(u , v);</span><br><span class="line">        in[u] ++ , in[v] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    in[<span class="number">1</span>] ++;    <span class="comment">//1号节点没有父亲，需要单独加一个度数</span></span><br><span class="line">    dfs(<span class="number">1</span> , <span class="number">0</span> , <span class="built_in">log</span>(<span class="number">1</span>));</span><br><span class="line">    sort(f + <span class="number">1</span> , f + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span> , cnt = <span class="number">0</span>;</span><br><span class="line">    rep(i , <span class="number">2</span> , n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i] - f[i - <span class="number">1</span>] &lt; eps)&#123;  <span class="comment">//注意可能存在的精度误差</span></span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans = max(ans , cnt);</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , n - ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 乱搞 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形dp </tag>
            
            <tag> 各省省选 </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【国家集训队】旅游-题解</title>
      <link href="2020/05/14/luoguP1505/"/>
      <url>2020/05/14/luoguP1505/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>给定一棵 $n$ 个节点的树，边带权，编号 $0 \sim n-1$，需要支持以下五种操作：</p><ol><li><code>C i w</code> 将输入的第 $i$ 条边权值改为 $w$</li><li><code>N u v</code> 将 $u,v$ 节点之间的边权都变为相反数</li><li><code>SUM u v</code> 询问 $u,v$ 节点之间边权和</li><li><code>MAX u v</code> 询问 $u,v$ 节点之间边权最大值</li><li><code>MIN u v</code> 询问 $u,v$ 节点之间边权最小值</li></ol><p>保证任意时刻所有边的权值都在$[−10^3 , 10^3]$ 内。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数 $n$，表示节点个数。</p><p>接下来 $n-1$ 行，每行三个整数 $u,v,w$，表示 $u,v$ 之间有一条权值为 $w$ 的边，描述这棵树。</p><p>然后一行一个正整数 $m$，表示操作数。</p><p>接下来 $m$ 行，每行表示一个操作。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每一个询问操作，输出一行一个整数表示答案。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 1 1</span><br><span class="line">1 2 2</span><br><span class="line">8</span><br><span class="line">SUM 0 2</span><br><span class="line">MAX 0 2</span><br><span class="line">N 0 1</span><br><span class="line">SUM 0 2</span><br><span class="line">MIN 0 2</span><br><span class="line">C 1 3</span><br><span class="line">SUM 0 2</span><br><span class="line">MAX 0 2</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">-1</span><br><span class="line">5</span><br><span class="line">3</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$100\%$的数据：$1 ≤ n, m ≤ 2 \times 10^5$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>养 生 题 目 警 告</del>。</p><p>题目中要求我们维护一棵树上信息，且为区间操作，很容易想到树剖维护。</p><p>但问题在于树剖只能维护点权，但本题要求维护边权。</p><p>因此，我们考虑如何<strong>把边权转为点权</strong>。</p><p>容易发现，树上的一个点仅有一个父亲，且该点与其父亲之间仅有一条边相连。</p><p>因此我们可以<strong>将该点与其父亲相连边的边权转移至该点上</strong>。由于一个点只有一个父亲，因此这样的转移是唯一的。</p><p>但这样会出现一个问题：在查询时，我们会多算两节点的$\text{LCA}$到$\text{LCA}$父亲的一条边。</p><p>因此，<strong>当两节点在同一条重链上时，左端点需要右移一位</strong>以减去多算的边。</p><p>还有就是操作$2$的一点细节：<strong>取相反数后，原本的区间最大值会变成最小值，区间最小值会变成区间最大值</strong>。在做<code>pushdown</code>的时候需要特别注意。</p><p>然后是树剖版子题了……</p><p>至于代码的话，<del>也就大约10kb，往死里写就完事了</del></p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9223372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , last , dis;</span><br><span class="line">&#125;edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;to , head[from] , dis&#125;; head[from] = edge_num;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;from , head[to] , dis&#125;; head[to] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[M] , fa[M] , son[M] , size[M] , val[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> f , <span class="keyword">int</span> deep)</span></span>&#123;</span><br><span class="line">    dep[x] = deep;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">-1</span>;</span><br><span class="line">    PE(i , x)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to , dis = edge[i].dis;</span><br><span class="line">        <span class="keyword">if</span>(to == f) <span class="keyword">continue</span>;</span><br><span class="line">        val[to] = dis;</span><br><span class="line">        size[x] += dfs1(to , x , deep + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(size[to] &gt; maxn)&#123;</span><br><span class="line">            maxn = size[to];</span><br><span class="line">            son[x] = to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tp[M] , dfn[M] , a[M] , cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> topf)</span></span>&#123;</span><br><span class="line">    dfn[x] = ++ cnt;</span><br><span class="line">    a[cnt] = val[x];</span><br><span class="line">    tp[x] = topf;</span><br><span class="line">    <span class="keyword">if</span>(!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x] , topf);</span><br><span class="line">    PE(i , x)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[to])&#123;</span><br><span class="line">            dfs2(to , to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Segment_tree&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lson(x) x &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rson(x) x &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> l , r , len;</span><br><span class="line">        <span class="keyword">int</span> num , add , maxn , minn , opo;</span><br><span class="line">    &#125;node[M &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">I <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        node[x].num = (node[lson(x)].num + node[rson(x)].num);</span><br><span class="line">        node[x].maxn = max(node[lson(x)].maxn , node[rson(x)].maxn);</span><br><span class="line">        node[x].minn = min(node[lson(x)].minn , node[rson(x)].minn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">I <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node[x].opo != <span class="number">1</span>)&#123;</span><br><span class="line">            node[lson(x)].opo *= <span class="number">-1</span>; node[lson(x)].num *= <span class="number">-1</span>;</span><br><span class="line">            node[rson(x)].opo *= <span class="number">-1</span>; node[rson(x)].num *= <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> lmax = node[lson(x)].maxn , lmin = node[lson(x)].minn;</span><br><span class="line">            <span class="keyword">int</span> rmax = node[rson(x)].maxn , rmin = node[rson(x)].minn;</span><br><span class="line">            node[lson(x)].maxn = -lmin; node[lson(x)].minn = -lmax;</span><br><span class="line">            node[rson(x)].maxn = -rmin; node[rson(x)].minn = -rmax;</span><br><span class="line">            node[x].opo = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(node[x].add != <span class="number">0</span>)&#123;</span><br><span class="line">            node[lson(x)].add += node[x].add;</span><br><span class="line">            node[lson(x)].num += node[x].add * node[lson(x)].len;</span><br><span class="line">            node[rson(x)].add += node[x].add;</span><br><span class="line">            node[rson(x)].num += node[x].add * node[rson(x)].len;</span><br><span class="line">            node[x].add = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        node[x].l = l; node[x].r = r;</span><br><span class="line">        node[x].len = (r - l + <span class="number">1</span>);</span><br><span class="line">        node[x].opo = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            node[x].num = node[x].maxn = node[x].minn = a[l];</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (node[x].l + node[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(lson(x) , l , mid);</span><br><span class="line">        build(rson(x) , mid + <span class="number">1</span> , r);</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">point_change</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> q, <span class="keyword">int</span> change)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node[x].l == node[x].r)&#123;</span><br><span class="line">            node[x].num = change;</span><br><span class="line">            node[x].add = <span class="number">0</span>;</span><br><span class="line">            node[x].maxn = node[x].minn = change;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(x);</span><br><span class="line">        <span class="keyword">int</span> mid = (node[x].l + node[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(q &lt;= mid)&#123;</span><br><span class="line">            point_change(lson(x) , q , change);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            point_change(rson(x) , q , change);</span><br><span class="line">        &#125;</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">range_add</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr , <span class="keyword">int</span> add)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= node[x].l &amp;&amp; node[x].r &lt;= qr)&#123;</span><br><span class="line">            node[x].add += add;     </span><br><span class="line">            node[x].num += node[x].len * add;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(x);</span><br><span class="line">        <span class="keyword">int</span> mid = (node[x].l + node[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">            range_add(lson(x) , ql , qr , add);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= qr)&#123;</span><br><span class="line">            range_add(rson(x) , ql , qr , add);</span><br><span class="line">        &#125;</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">range_opposite</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= node[x].l &amp;&amp; node[x].r &lt;= qr)&#123;</span><br><span class="line">            node[x].opo *= <span class="number">-1</span>;</span><br><span class="line">            node[x].num *= <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> maxn = node[x].maxn , minn = node[x].minn;</span><br><span class="line">            node[x].maxn = -minn; node[x].minn = -maxn;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(x);</span><br><span class="line">        <span class="keyword">int</span> mid = (node[x].l + node[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">            range_opposite(lson(x) , ql , qr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= qr)&#123;</span><br><span class="line">            range_opposite(rson(x) , ql , qr);</span><br><span class="line">        &#125;</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">range_query</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= node[x].l &amp;&amp; node[x].r &lt;= qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> node[x].num;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(x);</span><br><span class="line">        <span class="keyword">int</span> mid = (node[x].l + node[x].r) &gt;&gt; <span class="number">1</span> , ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">            ans += range_query(lson(x) , ql , qr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= qr)&#123;</span><br><span class="line">            ans += range_query(rson(x) , ql , qr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">range_max</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= node[x].l &amp;&amp; node[x].r &lt;= qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> node[x].maxn;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(x);</span><br><span class="line">        <span class="keyword">int</span> mid = (node[x].l + node[x].r) &gt;&gt; <span class="number">1</span> , ans = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">            ans = max(ans , range_max(lson(x) , ql , qr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= qr)&#123;</span><br><span class="line">            ans = max(ans , range_max(rson(x) , ql , qr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">range_min</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= node[x].l &amp;&amp; node[x].r &lt;= qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> node[x].minn;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(x);</span><br><span class="line">        <span class="keyword">int</span> mid = (node[x].l + node[x].r) &gt;&gt; <span class="number">1</span> , ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">            ans = min(ans , range_min(lson(x) , ql , qr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= qr)&#123;</span><br><span class="line">            ans = min(ans , range_min(rson(x) , ql , qr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lson</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rson</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_opposite</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tp[x] != tp[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[tp[x]] &lt; dep[tp[y]])&#123;</span><br><span class="line">            swap(x , y);</span><br><span class="line">        &#125;</span><br><span class="line">        Segment_tree :: range_opposite(<span class="number">1</span> , dfn[tp[x]] , dfn[x]);</span><br><span class="line">        x = fa[tp[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[x] &gt; dep[y]) swap(x , y);</span><br><span class="line">        Segment_tree :: range_opposite(<span class="number">1</span> , dfn[x] + <span class="number">1</span> , dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tree_query</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tp[x] != tp[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[tp[x]] &lt; dep[tp[y]])&#123;</span><br><span class="line">            swap(x , y);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += Segment_tree :: range_query(<span class="number">1</span> , dfn[tp[x]] , dfn[x]);</span><br><span class="line">        x = fa[tp[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[x] &gt; dep[y]) swap(x , y);</span><br><span class="line">        ans += Segment_tree :: range_query(<span class="number">1</span> , dfn[x] + <span class="number">1</span> , dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tree_max</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">while</span>(tp[x] != tp[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[tp[x]] &lt; dep[tp[y]])&#123;</span><br><span class="line">            swap(x , y);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans , Segment_tree :: range_max(<span class="number">1</span> , dfn[tp[x]] , dfn[x]));</span><br><span class="line">        x = fa[tp[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[x] &gt; dep[y]) swap(x , y);</span><br><span class="line">        ans = max(ans , Segment_tree :: range_max(<span class="number">1</span> , dfn[x] + <span class="number">1</span> , dfn[y]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tree_min</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">while</span>(tp[x] != tp[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[tp[x]] &lt; dep[tp[y]])&#123;</span><br><span class="line">            swap(x , y);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = min(ans , Segment_tree :: range_min(<span class="number">1</span> , dfn[tp[x]] , dfn[x]));</span><br><span class="line">        x = fa[tp[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[x] &gt; dep[y]) swap(x , y);</span><br><span class="line">        ans = min(ans , Segment_tree :: range_min(<span class="number">1</span> , dfn[x] + <span class="number">1</span> , dfn[y]));    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> from1[M] , to1[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y , <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) swap(x , y);</span><br><span class="line">    Segment_tree :: point_change(<span class="number">1</span> , dfn[y] , val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;P1505_4.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;P1505_4.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;n);</span><br><span class="line">    <span class="keyword">int</span> u , v , d;</span><br><span class="line">    rep(i , <span class="number">1</span> , n - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span> , &amp;u , &amp;v , &amp;d);</span><br><span class="line">        u ++; v ++;</span><br><span class="line">        add_edge(u , v , d);</span><br><span class="line">        from1[i] = u; to1[i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span> , <span class="number">0</span> , <span class="number">1</span>);</span><br><span class="line">    dfs2(<span class="number">1</span> , <span class="number">1</span>);</span><br><span class="line">    Segment_tree :: build(<span class="number">1</span> , <span class="number">1</span> , n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;m);</span><br><span class="line">    <span class="keyword">char</span> opt[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span> , opt);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;x , &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(opt[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            change(from1[x] , to1[x] , y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>] == <span class="string">&#x27;N&#x27;</span>)&#123;</span><br><span class="line">            x ++; y ++;</span><br><span class="line">            tree_opposite(x , y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>] == <span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">            x ++; y ++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , tree_query(x , y));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(opt[<span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                x ++ , y ++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , tree_max(x , y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">1</span>] == <span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">                x ++ , y ++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , tree_min(x , y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> Luogu </tag>
            
            <tag> WC/CTSC/集训队 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【UVA1437】String painter</title>
      <link href="2020/05/03/UVA1437/"/>
      <url>2020/05/03/UVA1437/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>现在，有两个用小写英文字母组成的等长字符串，设其分别为$\text{A} , \text{B}$。</p><p>与此同时，你有一个强大的字符串刷子。在这把刷子的帮助下，你可以将一个字符串的一个字串中的字符全部刷成任何你想要的字符。</p><p>也就是说，用刷子刷过的字串就变成用同一个字母组成的了。</p><p>现在你想要用这一把刷子把字符串$\text{A}$刷成$\text{B}$，但这刷子比较重，你并不想很多次的拿起它。</p><p>所以你要写一个程序，求出拿起刷子的最少次数。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含多组数据，每一组数据包括两行，分别是两个字符串$\text{A}$与$\text{B}$;</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组数据，输出一行，一个整数，表示最小次数。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">hfcnndeziymohaewnrbmquyhigwm</span><br><span class="line">bcbysbjvxbzvmspshggrzaukbipm</span><br><span class="line">jmmeqimjobpxyavjneyvyuuhhwiqowmme</span><br><span class="line">kmpgpviubhzrjkezqqoilsuwgedctxkxl</span><br><span class="line">ikynfrlcsltkrbdkdqpirtdnajhzhbhipeqtyxvskhkti</span><br><span class="line">qmziwxbbjzjfymrzvflthsbaqgdoqmiduiudviqzztclb</span><br><span class="line">vwysgqniecydcycqk</span><br><span class="line">cqgudqbkgcsvimpdj</span><br><span class="line">mcrrqwfegpnukyuk</span><br><span class="line">vezrniuriscgtcth</span><br><span class="line">rdjtgk</span><br><span class="line">wzfycu</span><br><span class="line">nwxqfdtigwj</span><br><span class="line">rrhcndwcohx</span><br><span class="line">knjmrwlwxfroyppgxhrknntrvbcqjrranufutrginldqydsjsfyjqfyqq</span><br><span class="line">lghrdjsgvbffgfpclqmrzzoniyhlsoisgpbfdqpiblsbtirrbdjdjxsuy</span><br><span class="line">nujagihmgqvwiwvbmbe</span><br><span class="line">pnxicvskosnzneztzhd</span><br><span class="line">bzjvffvyv</span><br><span class="line">mnvjbgwdw</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">20</span><br><span class="line">26</span><br><span class="line">33</span><br><span class="line">15</span><br><span class="line">13</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">43</span><br><span class="line">15</span><br><span class="line">8</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>设$t$为数据组数，$|s|$为字符串$s$的长度。</p><p>对于$100\%$的数据，保证$1 \leq t \leq 100 , 1 \leq |\text{A}|, |\text{B}| \leq 100$，且保证$|\text{A}| = |\text{B}|$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目的大体思路并不难想，就是一个区间$\text{dp}$</p><p>但状态的设计比较困难。由于$\text{A}$与$\text{B}$中字符的不确定性，我们难以定义状态并写出转移方程。</p><p>因此，我们可以换个角度，先考虑其弱化版本，<strong>即</strong>$\text{A}$<strong>为空串时的情况</strong>。</p><p>设$f[i][j]$表示将空串$\text{A}$的第$i$到$j$位刷的与$\text{B}$相同所需要的最少次数。显然，当$i = j$时，$f[i][j] = 1$。</p><p>当$i ≠ j$时，则看$B$的第$i$位与第$j$位是否相同。若相同的话，则有：</p><script type="math/tex; mode=display">f[i][j] = min(f[i + 1][j] , f[i][j - 1])</script><p>否则的话，我们采用类似于$\text{floyd}$的套路，枚举中间点$k$，则有：</p><script type="math/tex; mode=display">f[i][j] = min(f[i][j] , f[i][k] + f[k + 1][j])</script><p>现在我们已经解决了$\text{A}$为空串时的情况。若$\text{A}$不为空串，则$A$的第$i$位与$B$的第$i$位可能相同，此时$f[i][i] = 0$。</p><p>则我们设$g[i]$表示$\text{A}$从第$1$到$i$位与$\text{B}$从$1$到$i$位相同所需要的最少次数。初始状态下，有$g[i] = f[1][i]$。</p><p>显然，$\text{A}$的第$i$位与$\text{B}$的第$i$位相同时，有$g[i] = g[i - 1]$。</p><p>若不同的话，和上面的套路一致，枚举中间点$k$，则有：</p><script type="math/tex; mode=display">g[i] = min(g[i] , g[k] + f[k + 1][i])</script><p>最后别忘了<strong>多组数据，每次计算之前都需要清空</strong></p><p>时间复杂度为$O(t \times n^2)$，足以通过本题。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9223372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">155</span>] , s2[<span class="number">155</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">155</span>][<span class="number">155</span>] , g[<span class="number">155</span>];   </span><br><span class="line"></span><br><span class="line"><span class="comment">//f[i][j] 将空串A的 i 到 j 位刷的与B相同所需要的最少次数</span></span><br><span class="line"><span class="comment">//g[i]    A从 1 到 i 位与B从 1 到 i 位相同所需要的最少次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> solve&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line">        clean(f , <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        rep(i , <span class="number">0</span> , len)&#123;</span><br><span class="line">            f[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(k , <span class="number">1</span> , len)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + k &lt;= len; i ++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + k;</span><br><span class="line">                <span class="keyword">if</span>(s2[i] == s2[j])&#123;</span><br><span class="line">                    f[i][j] = min(f[i + <span class="number">1</span>][j] , f[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    rep(l , i , j)&#123;</span><br><span class="line">                        f[i][j] = min(f[i][j] , f[i][l] + f[l + <span class="number">1</span>][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clean(g , <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        rep(i , <span class="number">1</span> , len)&#123;</span><br><span class="line">            g[i] = f[<span class="number">1</span>][i];</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == s2[i])&#123;</span><br><span class="line">                g[i] = min(g[i] , g[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                rep(l , <span class="number">1</span> , i)&#123;</span><br><span class="line">                    g[i] = min(g[i] , g[l] + f[l + <span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            g[i] = min(g[i] , f[<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span> , s1 + <span class="number">1</span> , s2 + <span class="number">1</span>) == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , solve :: main());</span><br><span class="line">    <span class="comment">//多组数据时建议写为函数或namespace , 便于调试。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 区间dp </tag>
            
            <tag> UVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷题库】消失之物-题解</title>
      <link href="2020/04/17/luoguP4141/"/>
      <url>2020/04/17/luoguP4141/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>$\text{ftiasch}$ 有 $n$ 个物品, 体积分别是 $w_1,w_2,\dots,w_n$。</p><p>由于她的疏忽，第 $i$ 个物品丢失了。</p><p>“要使用剩下的 $n-1$ 物品装满容积为 $x$ 的背包，有几种方法呢？”——这是经典的问题了。</p><p>她把答案记为 $cnt(i,x)$ ，想要得到所有$i \in [1,n]$ , $x \in [1,m]$的 $cnt(i,x)$表格。</p><p>然而她不会做，所以这个问题扔给了你</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数 $n,m$，表示物品的数量和最大的容积。<br>第二行 $n$ 个整数 $w_1,w_2,\dots,w_n$ ，表示每个物品的体积。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个 $n \times m$ 的矩阵，表示 $cnt(i,x)$ 的末位数字</p><p>即$cnt(i , x)$对$10$取模的结果</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 1 2</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">11</span><br><span class="line">21</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $100\%$ 的数据，$1\leq n,m \leq 2000$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>$01$背包计数 + 简单容斥。</p><p>先考虑一下暴力怎么做：可以依次枚举丢失的物品跑$01$背包，时间复杂度为$O(n^2m)$，跑不过本题。</p><p>考虑一下刚刚暴力的瓶颈在哪，显然，瓶颈在于<strong>枚举丢失的物品</strong>。则我们考虑不采用枚举来算出结果。然而这并不好做。</p><p>正难则补，考虑容斥。设$f[i][j][0]$表示前$i$个物品，<strong>不算消失的物品</strong>，组成价值为$j$的方案数。则：</p><script type="math/tex; mode=display">f[i][j][0] = f[i][j][0] + f[i - 1][j - v[i]][0]</script><p>设$f[i][j][1]$表示前$i$个物品，<strong>算上消失的物品</strong>，组成价值为$j$的方案数。显然，这可以由$f[i][j][0]$<strong>减去需要加上v[i]才能组成大小为j的方案数</strong>得来。即：</p><script type="math/tex; mode=display">f[i][j][1] = f[i][j][0] - f[i - 1][j - v[i]][1]</script><p>最后别忘了取模，输出即可。</p><p>顺便提一个小细节，如果你像作者一样采用了滚动数组的写法，请一边处理一边输出。</p><p>这是因为滚动数组压掉了子状态，而本题又要求输出所有状态所致。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9223372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[M][<span class="number">2</span>] , v[M]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//f[j][0] 不考虑丢失物品，组成体积为j的背包的方案数</span></span><br><span class="line"><span class="comment">//f[j][1] 考虑丢失物品，组成体积为j的背包的方案数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n , m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;n , &amp;m);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;     <span class="comment">//dp求01背包方案数</span></span><br><span class="line">        per(j , m , v[i])&#123;</span><br><span class="line">            f[j][<span class="number">0</span>] += f[j - v[i]][<span class="number">0</span>];</span><br><span class="line">            f[j][<span class="number">0</span>] %= HA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;     </span><br><span class="line">        rep(j , <span class="number">1</span> , m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j - v[i] &gt;= <span class="number">0</span>)&#123;  <span class="comment">//避免访问负下标导致RE  </span></span><br><span class="line">                <span class="comment">//容斥，减去需要加上v[i]才能组成j的方案数</span></span><br><span class="line">                f[j][<span class="number">1</span>] = f[j][<span class="number">0</span>] - f[j - v[i]][<span class="number">1</span>];</span><br><span class="line">                f[j][<span class="number">1</span>] %= HA;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[j][<span class="number">1</span>] = f[j][<span class="number">0</span>] % HA;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , f[j][<span class="number">1</span>]); <span class="comment">//边处理变输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
            <tag> Luogu </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷题库】最长括号匹配-题解</title>
      <link href="2020/04/10/luoguP1944/"/>
      <url>2020/04/10/luoguP1944/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>对一个由<code>(</code>,<code>)</code>,<code>[</code>,<code>]</code>括号组成的字符串，求出其中最长的括号匹配子串。具体来说，满足如下条件的字符串成为括号匹配的字符串：</p><p>1.<code>()</code>,<code>[]</code>是括号匹配的字符串。</p><p>2.若<code>A</code>是括号匹配的串，则<code>(A)</code> , <code>[A]</code>是括号匹配的字符串。</p><p>3.若<code>A</code>,<code>B</code>是括号匹配的字符串，则<code>AB</code>也是括号匹配的字符串。</p><p>例如：<code>()</code>,<code>[]</code>,<code>([])</code>,<code>()()</code>都是括号匹配的字符串，而<code>][</code>,<code>[(])</code>则不是。</p><p>字符串<code>A</code>的子串是指由<code>A</code>中若干个连续字符组成的字符串。</p><p>例如，<code>A</code>,<code>B</code>,<code>C</code>,<code>ABC</code>,<code>CAB</code>,<code>ABCABC</code>都是<code>ABCABC</code>的子串。</p><p>规定空串是任何字符串的子串。</p><p>现在问题来了，给你一个字符串，请求出它的最长匹配子串。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含一行，为一个仅由<code>(</code> , <code>)</code> , <code>[</code> , <code>]</code>组成的非空字符串$s$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出也仅有一行，为$s$的最长的括号匹配子串。</p><p>若有相同长度的子串，则请输出位置靠前的子串。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">([<span class="string">(</span>][<span class="symbol">()</span>]](<span class="link"></span>)</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[()]</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>设$|s|$为字符串$s$的长度</p><p>对于$20\%$的数据，$1 \leq |s| \leq 100$。</p><p>对于$50\%$的数据，$1 \leq |s| \leq 10^4$。</p><p>对于$100\%$的数据，$1 \leq |s| \leq 10^6$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道比较套路化的$\text{dp}$模型。</p><p>设$f[i]$表示以$s[i]$为结尾的最长匹配子串的长度，则每一个状态可以由其上一位转移而来。</p><p>之后考虑如何进行转移。</p><p>如果第$i$位为左括号，则不可能构成一个以$s[i]$为结尾的匹配串。此时$f[i] = 0$</p><p>如果第$i$位为右括号，则考虑寻找其左边第一个没有匹配的左括号。显然，这之间是不可能有单独的右括号存在的。</p><p>也就是说，我们只需要确认当前位置减去前一个位置的最长匹配长度，即$s[i - 1 - f[i - 1]]$是不是左括号即可。是的话，则</p><script type="math/tex; mode=display">f[i] = f[i - 1] + 2 + f[i - 1 - f[i - 1] - 1]</script><p>最后循环一遍，找到最大长度，之后输出子串。</p><p>时间复杂度为$O(n)$，足以通过$10^6$的数据。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9223372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span> * M];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10</span> * M] , ans;    <span class="comment">//f[i] 以i为结尾的最长匹配子串长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span> , s + <span class="number">1</span>);    <span class="comment">//将字符串统一右移一位以避免负下标</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    rep(i , <span class="number">1</span> , len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span>) <span class="keyword">continue</span>;    <span class="comment">//左括号则跳过</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span> || s[i] == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; s[i - <span class="number">1</span> - f[i - <span class="number">1</span>]] == <span class="string">&#x27;(&#x27;</span>) || (s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; s[i - <span class="number">1</span> - f[i - <span class="number">1</span>]] == <span class="string">&#x27;[&#x27;</span>))&#123;</span><br><span class="line">                f[i] = f[i - <span class="number">1</span>] + <span class="number">2</span> + f[i - <span class="number">2</span> - f[i - <span class="number">1</span>]];  </span><br><span class="line">                <span class="comment">//右括号的话则等于其上一位长度 + 2 + 之前可以连接的子串长度</span></span><br><span class="line">                ans = max(ans , f[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i , <span class="number">1</span> , len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i] == ans)&#123;</span><br><span class="line">            rep(j , i - ans + <span class="number">1</span> , i)&#123;   </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span> , s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 线性dp </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TJOI2013】拯救小矮人-题解</title>
      <link href="2020/04/06/luoguP4823/"/>
      <url>2020/04/06/luoguP4823/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>一群小矮人掉进了一个很深的陷阱里，由于太矮爬不上来，于是他们决定搭一个人梯。</p><p>即：一个小矮人站在另一小矮人的肩膀上，直到最顶端的小矮人伸直胳膊可以碰到陷阱口。</p><p>对于每一个小矮人，我们知道他从脚到肩膀的高度$a_i$，并且他的胳膊长度为$b_i$。陷阱深度为$h$。</p><p>如果我们利用矮人$1$，矮人$2$，矮人$3$…矮人$k$搭一个梯子，满足$a_1+a_2+a_3+….+a_k+b_k \geq h$,那么矮人$k$就可以离开陷阱逃跑了。</p><p>一旦一个矮人逃跑了，他就不能再搭人梯了。</p><p>我们希望尽可能多的小矮人逃跑，那么问题来了，最多可以使多少个小矮人逃跑呐。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$n$，表示矮人的个数，接下来$n$行每一行两个整数$a_i$和$b_i$，最后一行是$h$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅一行，包含一个整数表示答案。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">20 10</span><br><span class="line">5 5</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">20 10</span><br><span class="line">5 5</span><br><span class="line">35</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></h2><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$30\%$的数据，有$0 \leq n \leq 200$。</p><p>对于$100\%$的数据，有$0 \leq n \leq 2000$，$0 \leq a_i , b_i , h \leq 10^5$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>简单贪心 + 简单dp = 一道紫题<br>                  ——我瞎编的</p></blockquote><p>首先考虑每个小矮人对于答案的贡献，显然，让长的矮的先逃出去一定更优，让手短的先出去一定更优。</p><p>因此我们按照$a_i + b_i$进行排序，选出来长的矮手还短的，让他们先出去。</p><p>但现在问题来了，如果前面的人长得高但是手短，则对答案来说把他放在下面是更优的。</p><p>考虑$\text{dp}$。</p><p>设$f[i]$表示逃出去$i$个人后所能组成的人塔的最大高度。</p><p>显然，如果第$i$个人能逃出去，则$f[i] = max(f[i] , f[i - 1] - a[i])$。</p><p>套个背包模板就过去了，时间复杂度为$O(n^2)$，通过本题还是绰绰有余的。</p><p>剩下的见代码。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9223372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pre</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a , b;</span><br><span class="line">&#125;p[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Pre a , Pre b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a + a.b &lt; b.a + b.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n , h; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;n);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;p[i].a , &amp;p[i].b);</span><br><span class="line">        f[<span class="number">0</span>] += p[i].a;</span><br><span class="line">        f[i] = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;h);</span><br><span class="line">    sort(p + <span class="number">1</span> , p + <span class="number">1</span> + n , cmp);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j --)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[j - <span class="number">1</span>] + p[i].b &gt;= h)&#123;</span><br><span class="line">                f[j] = max(f[j] , f[j - <span class="number">1</span>] - p[i].a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    per(i , n , <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 各省省选 </tag>
            
            <tag> 背包问题 </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSP-S2019】括号树-题解</title>
      <link href="2020/04/05/luoguP5658/"/>
      <url>2020/04/05/luoguP5658/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>本题中合法括号串的定义如下：</p><ol><li>$\text{()}$ 是合法括号串。</li><li>如果 $\text{A}$ 是合法括号串，则 $\text{(A)}$ 是合法括号串。</li><li>如果 $\text{A , B}$ 是合法括号串，则 $\text{AB}$ 是合法括号串。</li></ol><p>本题中子串与不同的子串的定义如下：</p><p>字符串 $\text{S}$ 的子串是 $\text{S}$ 中连续的任意个字符组成的字符串。</p><p>$\text{S}$ 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S (l , r)$，($1 \leq l \leq r \leq |S|$，$|S|$ 表示 $S$ 的长度)。</p><p>$S$ 的两个子串视作不同当且仅当它们在 $S$ 中的位置不同，即 $l$ 不同或 $r$ 不同。</p><hr><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>一个大小为 $n$ 的树包含 $n$ 个结点和 $n - 1$ 条边，每条边连接两个结点，且任意两个结点间<strong>有且仅有</strong>一条简单路径互相可达。</p><p>小 Q 是一个充满好奇心的小朋友，有一天他在上学的路上碰见了一个大小为 $n$ 的树，树上结点从 $1 \sim n$ 编号，$1$ 号结点为树的根。除 $1$ 号结点外，每个结点有一个父亲结点，$u$（$2 \le u \le n$）号结点的父亲为 $f_u$（$1 \le f_u &lt; u$）号结点。</p><p>小 Q 发现这个树的每个结点上<strong>恰有</strong>一个括号，可能是 <code>(</code> 或 <code>)</code>。小 Q 定义 $s_i$ 为：将根结点到 $i$ 号结点的简单路径上的括号，按结点经过顺序依次排列组成的字符串。</p><p>显然 $s_i$ 是个括号串，但不一定是合法括号串，因此现在小 Q 想对所有的 $i$（$1 \le i \le n$）求出，$s_i$ 中有多少个<strong>互不相同的子串</strong>是<strong>合法括号串</strong>。</p><p>这个问题难倒了小 Q，他只好向你求助。设 $s_i$ 共有 $k_i$ 个不同子串是合法括号串，你只需要告诉小 Q 所有 $i \times k_i$ 的异或和，即：</p><script type="math/tex; mode=display">(1\times k_1)\ \text{xor}\ (2\times k_2)\ \text{xor}\ (3\times k_3)\ \text{xor}\ \cdots \ \text{xor}\ (n\times k_n)</script><p>其中 $\text{xor}$ 是位异或运算。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$，表示树的大小。</p><p>第二行一个长为 $n$ 的由$\text{(}$ 与$\text{)}$ 组成的括号串，第 $i$ 个括号表示 $i$ 号结点上的括号。</p><p>第三行包含 $n − 1$ 个整数，第 $i$ 个整数表示 $i + 1$ 号结点的父亲编号 $f_{i+1}$</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅一行，包含一个整数表示答案。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">(()()</span><br><span class="line">1 1 2 2</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><hr><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>树的形态如下图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.luogu.com.cn/upload/image_hosting/10z2scex.png" alt="tree"></p><p>将根到 $1$ 号结点的简单路径上的括号，按经过顺序排列所组成的字符串为 $\text{(}$，子串是合法括号串的个数为 $0$。</p><p>将根到 $2$ 号结点的字符串为 $\text{((}$子串是合法括号串的个数为 $0$。</p><p>将根到 $3$ 号结点的字符串为 $\text{()}$子串是合法括号串的个数为 $1$。</p><p>将根到 $4$ 号结点的字符串为 $\text{(((}$，子串是合法括号串的个数为 $0$。</p><p>将根到 $5$ 号结点的字符串为 $\text{(()}$，子串是合法括号串的个数为 $1$。</p><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><div class="table-container"><table><thead><tr><th style="text-align:center">测试点编号</th><th style="text-align:center">$n\le $</th><th style="text-align:center">特殊性质</th></tr></thead><tbody><tr><td style="text-align:center">$1\sim 2$</td><td style="text-align:center">$8$</td><td style="text-align:center">$f_i=i-1$</td></tr><tr><td style="text-align:center">$3\sim 4$</td><td style="text-align:center">$200$</td><td style="text-align:center">$f_i=i-1$</td></tr><tr><td style="text-align:center">$5\sim 7$</td><td style="text-align:center">$2\times 10^3$</td><td style="text-align:center">$f_i=i-1$</td></tr><tr><td style="text-align:center">$8\sim 10$</td><td style="text-align:center">$2\times 10^3$</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">$11\sim 14$</td><td style="text-align:center">$10^5$</td><td style="text-align:center">$f_i=i-1$</td></tr><tr><td style="text-align:center">$15\sim 16$</td><td style="text-align:center">$10^5$</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">$17\sim 20$</td><td style="text-align:center">$5\times 10^5$</td><td style="text-align:center">无</td></tr></tbody></table></div><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>md考场上没调出来这题真的血亏</del></p><p>可以先考虑一下$50$分的部分分，即对于一条链的情况是怎么做的。</p><p>显然，对于一条链，可以设$fin[i]$表示以$i$结尾的子串中合法括号串的数目，$last[i]$表示以$i$结尾的子串中上一个没有匹配的左括号的位置。</p><p>则对于一个新的位置$i$，如果它是<code>(</code>，则$last[i] = i$。</p><p>若是<code>)</code>的话，则$fin[i] = 1 + fin[last[i]]$，$last[i] = last[last[i]]$</p><p>现在思考如何搬到树上。</p><p>树上和链上最大的区别在于<strong>树上转移时并不是从上一个节点转移，而是从父节点转移</strong>。</p><p>因此，我们只需要将转移时的上一个节点全部改为父节点，即$fin[i] = 1 + fin[fa[last[i]]]$，$last[i] = last[fa[last[i]]]$，然后套上一个$\text{dfs}$。</p><p>最后别忘了按照题目要求全部$\text{xor}$一遍。</p><p>剩下的细节详见代码。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFL = <span class="number">9223372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , last;</span><br><span class="line">&#125;edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;to , head[from]&#125;; </span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> s[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">ll fin[M &lt;&lt; <span class="number">1</span>] , last[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    last[x] = last[fa[x]];</span><br><span class="line">    <span class="keyword">if</span>(s[x] == <span class="string">&#x27;(&#x27;</span>) last[x] = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(last[x] != <span class="number">0</span>)&#123;</span><br><span class="line">        fin[x] = fin[fa[last[x]]] + <span class="number">1</span>;</span><br><span class="line">        last[x] = last[fa[last[x]]];</span><br><span class="line">    &#125;</span><br><span class="line">    PE(i , x)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        dfs(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span> , s + <span class="number">1</span>);</span><br><span class="line">    rep(i , <span class="number">2</span> , n)&#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;x);</span><br><span class="line">        fa[i] = x;</span><br><span class="line">        add_edge(x , i);   </span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    ll ans = fin[<span class="number">1</span>];</span><br><span class="line">    rep(i , <span class="number">2</span> , n)&#123;</span><br><span class="line">        fin[i] += fin[fa[i]];</span><br><span class="line">        ans ^= (i * fin[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形dp </tag>
            
            <tag> Luogu </tag>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【USACO】伟大的奶牛聚集-题解</title>
      <link href="2020/02/25/luoguP2986/"/>
      <url>2020/02/25/luoguP2986/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>$\text{Bessie}$ 正在计划一年一度的奶牛大集会，来自全国各地的奶牛将来参加这一次集会。当然，她会选择最方便的地点来举办这次集会。</p><p>奶牛分布在 $n$ 个农场中的一个，这些农场由 $n - 1$ 条道路连接，并且从任意一个农场都能够到达另外一个农场。</p><p>道路$i$连接农场 $a_i$ 和 $b_i$。长度为 $len_i$。集会可以在 $n$ 个农场中的任意一个举行。每个牛棚中居住着 $c_i$只奶牛。</p><p>在选择集会的地点的时候，$\text{Bessie}$ 希望最大化方便程度(也就是最小化不方便程度)。比如选择第 $x$ 个农场作为集会地点，它的不方便程度是其它牛棚中每只奶牛去参加集会所走的路程之和。</p><p>请帮 $\text{Bessi}$ 找出最方便的地点来举行大集会。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：一个整数 $n$</p><p>第二到 $n + 1$ 行 , 第 $i+1$ 行有一个整数 $c_i$</p><p>第 $n+2$ 行到 $2n$ 行：第 $i+n+1$ 行为 3 个整数，$a_i$ , $b_i$ , $len_i$</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，包含一个值，表示最小的不方便值。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 </span><br><span class="line">1 </span><br><span class="line">1 </span><br><span class="line">0 </span><br><span class="line">0 </span><br><span class="line">2 </span><br><span class="line">1 3 1 </span><br><span class="line">2 3 2 </span><br><span class="line">3 4 3 </span><br><span class="line">4 5 3 </span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">15 </span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$100\%$的数据，保证$1 \leq n \leq 10^5$，$1 \leq c_i , len_i \leq 1000$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>比较经典的换根法模型。</p><p>题目中已经告诉我们，$m = n - 1$，很明显，这是一棵树。</p><p>考虑树形$dp$，设$f[i]$表示节点$i$的不方便值。</p><p>之后考虑单独的一个节点$p$。若选择该节点的一个子节点举办聚会，则在<strong>该子节点的子树中的点将少走一条边</strong>，而<strong>不在该子节点子树中的点将多走一条边</strong>。</p><p>而对于一个点，它要么在该子节点的子树中，要么不在。</p><p>因此，我们可以先进行一次$\text{dfs}$，处理出<strong>每个节点的子树大小</strong>和<strong>子树中每个节点到根的路径之和</strong>，之后进行$dp$，转移方程为</p><script type="math/tex; mode=display">f[to] = f[u] - (size[to] \times dis[i]) + (cnt - size[to]) \times dis[i]</script><p>其中，$size[i]$表示以$i$为根的子树大小，$cnt$表示每个节点的权值之和，$dis[i]$表示$i$这条边的边权。</p><p>如果还有什么的话，就是<strong>开</strong>$\text{long long}$</p><p>剩下的细节见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , node[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , last , dis;</span><br><span class="line">&#125;edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;to , head[from] , dis&#125;; </span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;from , head[to] , dis&#125;; </span><br><span class="line">    head[to] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll size[M &lt;&lt; <span class="number">1</span>] , road[M &lt;&lt; <span class="number">1</span>] , f[M &lt;&lt; <span class="number">1</span>] , cnt;</span><br><span class="line"><span class="comment">//size[i] 表示以i为根的子树大小，road[i] 表示以i为根的子树每个节点到i的路径之和</span></span><br><span class="line"><span class="comment">//cnt 表示每个节点上的权值之和。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> fa)</span></span>&#123;   <span class="comment">//预处理子树大小和子树到其根节点的路径之和</span></span><br><span class="line">    size[u] = node[u];</span><br><span class="line">    PE(i , u)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to , u);</span><br><span class="line">        size[u] += size[to];</span><br><span class="line">        road[u] += road[to] + size[to] * edge[i].dis; </span><br><span class="line">        <span class="comment">//处理时需要乘上该点的权值（一个点上可能有多头牛）</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    PE(i , u)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        f[to] = f[u] - (size[to] * edge[i].dis) + (cnt - size[to]) * edge[i].dis;</span><br><span class="line">        dp(to , u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;n);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;node[i]);</span><br><span class="line">        cnt += node[i];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> u , v , d;</span><br><span class="line">    rep(i , <span class="number">1</span> , n - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span> , &amp;u , &amp;v , &amp;d);</span><br><span class="line">        add_edge(u , v , d);    </span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">    f[<span class="number">1</span>] = road[<span class="number">1</span>];</span><br><span class="line">    dp(<span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">    ll ans = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">    rep(i , <span class="number">1</span> , n) ans = min(ans , f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> USACO </tag>
            
            <tag> 树形dp </tag>
            
            <tag> Luogu </tag>
            
            <tag> 换根法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Violet】樱花-题解</title>
      <link href="2020/02/12/luoguP1445/"/>
      <url>2020/02/12/luoguP1445/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>求方程:</p><script type="math/tex; mode=display">\frac{1}{x} + \frac{1}{y} = \frac{1}{n!}</script><p>的正整数解的组数。</p><p>为防止输出过大，请输出答案对$10^9 + 7$取模的结果。</p><p>（ps.原题还是很有意思的，感兴趣的读者可以点击<a href="https://www.luogu.com.cn/problem/P1445">这里</a>）</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>仅有一行，包含一个正整数$n$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个正整数，表示最终答案对$10^9 + 7$取模的值。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1439</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">102426508</span><br></pre></td></tr></table></figure><hr><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>共有三个数对$(x , y)$满足条件，分别是 $(3,6)$，$(4,4)$和$(6,3)$。</p><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$30\%$的数据，保证$0 \leq n \leq 100$。</p><p>对于$100\%$的数据，保证$0 \leq n \leq 10^7$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>又是一道比较麻烦的数论……</p><p>将原式通分，得<script type="math/tex">\frac{x + y}{xy} = \frac{1}{n!}</script></p><p>交叉相乘，就成了：<script type="math/tex">xy - n!(x + y) = 0</script></p><p>在两边加上$(n!)^2$，就成了<script type="math/tex">(n!)^2 + xy - n!(x + y) = (n!)^2</script></p><p>之后对左边因式分解，可得<script type="math/tex">(x - n!)(y - n!) = (n!)^2</script></p><p>我们设$a = (x - n!)$，$b = (y - n!)$，则$ab = (n!)^2$</p><p>根据唯一分解定理，可知<script type="math/tex">n! = \prod_{i = 1}^k p_i^{c_i}</script></p><p>则<script type="math/tex">ab = (n!)^2 = \prod_{i = 1}^k p_i^{2c^i}</script></p><p>$n!$是一个确定的数，因此我们只需要确定$a , b$ ， 就确定了$x , y$。</p><p>又因为$b = \frac{(n!)^2}{a}$，则我们确定了$a$，同时也就确定了$b$。</p><p>因此我们只需要统计$a$的数目即可。</p><p>又因为$a$是$(n!)^2$的因式，因此$a$的数目为<script type="math/tex">\prod_{i = 1}^k 2c_i + 1</script></p><p>先用欧拉筛筛一遍，之后利用唯一分解定理算出所有$c_i$，最后乘起来即可。</p><p>时间复杂度$O(n \log n)$，足以通过本题。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a , b) memcpy(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std :: cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[M] , flag[M] , num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[M];</span><br><span class="line">ll ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IS_Prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;   <span class="comment">//这是一个魔改之后的欧拉筛，其中flag[i]表示i的最小质因子。</span></span><br><span class="line">    rep(i , <span class="number">2</span> , n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i])flag[i] = i , prime[++ num] = i;</span><br><span class="line">        rep(j , <span class="number">1</span> , num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prime[j] &gt; flag[i] || prime[j] &gt; n / i) <span class="keyword">break</span>;</span><br><span class="line">            flag[i * prime[j]] = prime[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;n);</span><br><span class="line">    IS_Prime(n);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;     <span class="comment">//利用最小质因子进行唯一分解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j != <span class="number">1</span>; j /= flag[j])&#123;</span><br><span class="line">            cnt[flag[j]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i , <span class="number">1</span> , n) ans *= (cnt[i] * <span class="number">2</span> + <span class="number">1</span>) , ans %= HA;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Luogu </tag>
            
            <tag> 数论 </tag>
            
            <tag> 欧拉筛 </tag>
            
            <tag> 唯一分解定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOI2010】能量采集-题解</title>
      <link href="2020/02/09/luoguP1447/"/>
      <url>2020/02/09/luoguP1447/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>栋栋有一块长方形的地，他在地上种了一种能量植物，这种植物可以采集太阳光的能量。在这些植物采集能量后，栋栋再使用一个能量汇集机器把这些植物采集到的能量汇集到一起。</p><p>栋栋的植物种得非常整齐，一共有$n$列，每列有$m$棵，植物的横竖间距都一样，因此对于每一棵植物，栋栋可以用一个坐标$(x , y)$来表示，其中$x$的范围是$1$至$n$，表示是在第$x$列，$y$的范围是$1$至$m$，表示是在第$x$列的第$y$棵。</p><p>由于能量汇集机器较大，不便移动，栋栋将它放在了一个角上，坐标正好是$(0, 0)$。</p><p>能量汇集机器在汇集的过程中有一定的能量损失。如果一棵植物与能量汇集机器连接而成的线段上有$k$棵植物，则能量的损失为$2k + 1$。例如，当能量汇集机器收集坐标为$(2, 4)$的植物时，由于连接线段上存在一棵植物$(1, 2)$，会产生$3$的能量损失。注意，如果一棵植物与能量汇集机器连接的线段上没有植物，则能量损失为$1$。现在要计算总的能量损失。</p><p>下面给出了一个能量采集的例子，其中$n = 5$，$m = 4$，一共有$20$棵植物，在每棵植物上标明了能量汇集机器收集它的能量时产生的能量损失。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/02/10/SjR4q7JaKieNQLA.png" alt="2608.png"></p><p>在这个例子中，总共产生了$36$的能量损失。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入仅包含一行，为两个整数$n$和$m$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅包含一个整数，表示总共产生的能量损失。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 4</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">36</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$10\%$的数据：$1 ≤ n, m ≤ 10$；<br>对于$50\%$的数据：$1 ≤ n, m ≤ 100$；<br>对于$80\%$的数据：$1 ≤ n, m ≤ 1000$；<br>对于$90\%$的数据：$1 ≤ n, m ≤ 10^4$；<br>对于$100\%$的数据：$1 ≤ n, m ≤ 10^5$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道比较麻烦的数论题，但应该还没有$\text{NOI}$的难度。</p><p>在做这题之前，我们首先要了解一个前置知识：对于平面直角坐标系中的任意一点$(x , y)$，其与原点连线后经过的点的数量为<script type="math/tex">gcd(x , y) - 1</script></p><p>因此，题目可以转化为求出<script type="math/tex">\sum_{i = 1} ^ {n} \sum_{j = 1} ^ {m} 2 \times gcd(i , j) - 1</script></p><p>化简一下，也就是求出<script type="math/tex">2 \times [\sum_{i = 1} ^ {n} \sum_{j = 1} ^ {m} gcd(i , j)] - n \times m</script></p><p><del>之后采用$O(n^2)$复杂度的暴力求解，可以得到$80$分的好成绩……</del></p><p>考虑如何快速求出$\sum<em>{i = 1} ^ {n} \sum</em>{j = 1} ^ {m} gcd(i , j)$，显然，这并不好求。</p><p>正难则补，考虑容斥，设$cnt[i]$表示以$i$为公因数(注意不是最大公因数)的点对个数，则$cnt[i] = \lfloor \frac{n}{i} \rfloor \times \lfloor \frac{m}{i} \rfloor$</p><p>之后减去以$2i , 3i , 4i…j * i (j \leq \lfloor \frac{n}{i}\rfloor)$作为公约数的部分，最后留下的就是以$gcd(i , j)$为公因数的点对数目。</p><p>时间复杂度为$O(n \log n)$，比莫反稍慢一点，但也足以通过本题。</p><p>剩下的见代码即可。</p><hr><h2 id="Code-80pts"><a href="#Code-80pts" class="headerlink" title="Code[80pts]"></a>Code[80pts]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a , ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b , a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ll n , m; <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span> , &amp;n , &amp;m);</span><br><span class="line">    rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">        rep(j , <span class="number">1</span> , m)&#123;</span><br><span class="line">            ans += <span class="number">2</span> * gcd(i , j) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clean(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll cnt[M] , ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ll n , m; <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span> , &amp;n , &amp;m);</span><br><span class="line">    ll maxn = max(n , m);</span><br><span class="line">    rep(i , <span class="number">1</span> , maxn)&#123;</span><br><span class="line">        cnt[i] = (ll)(n / i) * (ll)(m / i);</span><br><span class="line">    &#125;</span><br><span class="line">    per(i , maxn , <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j = <span class="number">2</span> * i; j &lt;= maxn; j += i) cnt[i] -= cnt[j];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i , <span class="number">1</span> , maxn)&#123;</span><br><span class="line">        ans += (ll)i * cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans *= <span class="number">2</span>; ans -= n * m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> NOI </tag>
            
            <tag> Luogu </tag>
            
            <tag> Gcd </tag>
            
            <tag> 数论 </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷题库】摇钱树-题解</title>
      <link href="2020/02/05/luoguP1987/"/>
      <url>2020/02/05/luoguP1987/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>$\text{Cpg}$ 正在游览一个梦中之城，在这个城市中有$n$棵摇钱树。这下，可让$\text{Cpg}$看傻了。</p><p>$\text{Cpg}$只能在这个城市中呆$m$天，现在摇钱树已经成熟了，每天每棵都会掉下不同的金币。</p><p>$\text{Cpg}$每天可以砍掉其中一颗，并获得其树上所有的金币。</p><p>请你帮助$\text{Cpg}$算出他在这$m$天中最多能获得多少金币。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>每个文件中有不超过$10$组测试数据，对于每组测试数据，有：</p><p>第一行两个整数$n , m$</p><p>第二行$n$个整数$M_i$，表示$\text{Cpg}$刚看到这$n$棵树时树上的金币数。</p><p>第三行$n$个整数 $P_i$，表示每颗摇钱树每天将会掉落的金币。</p><p>以$n=m=0$结束。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对每组测试数据，输出仅一行，表示$\text{Cpg}$在$m$天中能获得的最大金币数。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">10 20 30</span><br><span class="line">4 5 6</span><br><span class="line">4 3</span><br><span class="line">20 30 40 50</span><br><span class="line">2 7 6 5</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">47</span><br><span class="line">104</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$100\%$的数据，有$1 &lt; n &lt; 1000$ ， $1 &lt; m &lt; 10^5$。</p><p>保证输入数据均在$\text{int}$范围内。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先说方法：将每一棵树按照$p[i]$排序之后$01$背包。</p><p>贪心证明如下：</p><p>对于第$i$颗与第$i + 1$颗树，若分别在第$j$个与第$j + 1$个时刻被砍掉，则收益为 <script type="math/tex">m[i] - j \times p[i] + m[i + 1] - (j + 1) \times p[i + 1]</script></p><p>如果交换一下砍树的顺序，则收益为 <script type="math/tex">m[i] - (j + 1) \times p[i] + m[i + 1] - j \times p[i + 1]</script></p><p>显然，只有当后者的收益大于前者时才会交换。即<script type="math/tex">m[i] - j \times p[i] + m[i + 1] - (j + 1) \times p[i + 1] < m[i] - (j + 1) \times p[i] + m[i + 1] - j \times p[i + 1]</script></p><p>移一下项，就变成了$p[i] - p[i + 1] &gt; 0$， 即$p[i] &gt; p[i + 1]$。</p><p>之后$01$背包即可，根据$01$背包的定义，可得状态转移方程<script type="math/tex">f[i][j] = max(f[i - 1][j] , f[i - 1][j - 1] + max(0 , m[i] - p[i] \times (j - 1)))</script></p><p>剩下的细节详见代码。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int , int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSL pair<span class="meta-string">&lt;string , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;long long , long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin() , (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i , l , r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i , r , l) for (int i = (r); i &gt;= (l); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(i , x) for(int i = head[x]; i; i = edge[i].last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">&#125;node[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a , Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">&quot;try.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;try1.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;n , &amp;m);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n) m = n;</span><br><span class="line">        rep(i , <span class="number">1</span> , n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;node[i].x);</span><br><span class="line">        rep(i , <span class="number">1</span> , n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;node[i].y);</span><br><span class="line">        sort(node + <span class="number">1</span> , node + <span class="number">1</span> + n , cmp);</span><br><span class="line">        rep(i , <span class="number">1</span> , n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j ; j --)&#123;</span><br><span class="line">                f[i][j] = max(f[i - <span class="number">1</span>][j] , f[i - <span class="number">1</span>][j - <span class="number">1</span>] + max(<span class="number">0</span> , node[i].x - (node[i].y * (j - <span class="number">1</span>))));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i , <span class="number">1</span> , m) ans = max(ans , f[n][i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷题库】OSU！-题解</title>
      <link href="2019/11/12/luoguP1654/"/>
      <url>2019/11/12/luoguP1654/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>$\text{OSU}$ 是一款群众喜闻乐见的休闲软件。</p><p>我们可以把$\text{OSU}$的规则简化与改编成以下的样子:</p><p>一共有$n$次操作，每次操作只有成功与失败之分。</p><p>成功对应$1$，失败对应$0$，$n$次操作对应为$1$个长度为$n$的$01$串。</p><p>在这个串中连续的$x$个 $1$ 可以贡献 $x^3$的分数，这$x$个$1$不能被其他连续的$1$所包含（也就是极长的一串$1$，具体见样例解释）</p><p>现在给出$n$，以及每个操作的成功率，请你输出期望分数。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有一个正整数$n$,表示操作个数。</p><p>接下来$n$行每行有一个实数$p_i$，表示每个操作的成功率。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，包含一个实数，表示答案。</p><p>输出时，请保留一位小数。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 </span><br><span class="line">0.5 </span><br><span class="line">0.5 </span><br><span class="line">0.5</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6.0</span><br></pre></td></tr></table></figure><hr><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>得分序列共有以下几种可能：</p><ol><li><code>000</code>分数为$0$</li><li><code>001</code>分数为$1$</li><li><code>010</code>分数为$1$</li><li><code>100</code>分数为$1$</li><li><code>101</code>分数为$2$</li><li><code>110</code>分数为$8$</li><li><code>011</code>分数为$8$</li><li><code>111</code>分数为$27$</li></ol><p>以上得分最后的总和为$48$，则其期望得分为$\frac{48}{8} = 6.0$</p><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$100\%$的数据，保证$0 \leq N \leq 10^5$，$0 \leq p_i \leq 1$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>简单的期望$\text{dp}$入门题目。</p><p>设$E(x_i)$表示前$i$个位置的期望得分，$E(l1_i)$表示打到第$i$个点的期望长度，$E(l2_i)$表示打到第$i$个点的期望长度的平方。</p><p>考虑单个位置对于答案的贡献。设之前的长度为$x$，若打中，则长度变为$x + 1$，对得分的贡献就是$(x + 1)^3 - x^3 = 3x^2 + 3x + 1$</p><p>综上，可得状态转移方程</p><script type="math/tex; mode=display">E(x_i) = E(x_{i - 1}) + p_i(3 \times E(l2_{i - 1}) + 3 \times E(l1_{i - 1}) + 1)</script><p>考虑如何维护$E(l1_i)$ 与 $E(l2_i)$ 。显然，</p><script type="math/tex; mode=display">E(l1_i) = p_i(E(l1_{i - 1}) + 1)</script><p>对于$E(l2_i)$，则考虑当前位置是否打中，设之前长度为$x$，若打中，则有$(x + 1)^2 - x^2 = 2x + 1$。</p><p>将其带到 $E(l2_i)$ 中，则有 </p><script type="math/tex; mode=display">E(l2_i) = p_i(E(l2_{i - 1}) + 2 \times E(l1_{i - 1}) + 1)</script><p>剩下的见代码即可。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> f[N] , len1[N] , len2[N] , p1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p1;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + p1 * (<span class="number">3</span> * len2[i - <span class="number">1</span>] + <span class="number">3</span> * len1[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        len1[i] = p1 * (len1[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        len2[i] = p1 * (len2[i - <span class="number">1</span>] + <span class="number">2</span> * len1[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; f[n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> Luogu </tag>
            
            <tag> 期望dp </tag>
            
            <tag> 概率期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces】Arthur and Brackets-题解</title>
      <link href="2019/11/09/CF508E/"/>
      <url>2019/11/09/CF508E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>现在有一个长度为$2 \times n$的括号序列，其中，左括号和右括号数量都为$n$。</p><p>对于从左到右的第$i$个左括号，与其配对的右括号和这个左括号之间的距离需要在 $[l_i , r_i]$ 之间。</p><p>请找出一种合法的匹配方案，使其可以满足所有左括号的要求。</p><p>若存在多种方案，则只输出其中一种即可。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件共有$n + 1$行，第一行给出$n$，表示左括号的数量</p><p>之后的$n$行，每行包含两个整数$l_i , r_i$。表示该左括号的距离要求。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，如果满足限制的括号序列存在，则输出任意一个。</p><p>否则请输出<code>IMPOSSIBLE</code>。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">()()()()</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5 5</span><br><span class="line">3 3</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">((()))</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-3"><a href="#Input-‘s-eg-3" class="headerlink" title="Input ‘s eg 3"></a>Input ‘s eg 3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5 5</span><br><span class="line">3 3</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-3"><a href="#Output-‘s-eg-3" class="headerlink" title="Output ‘s eg 3"></a>Output ‘s eg 3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">IMPOSSIBLE</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-4"><a href="#Input-‘s-eg-4" class="headerlink" title="Input ‘s eg 4"></a>Input ‘s eg 4</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-4"><a href="#Output-‘s-eg-4" class="headerlink" title="Output ‘s eg 4"></a>Output ‘s eg 4</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">(())()</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$100\%$的数据，保证$1 \leq n \leq 600$,$1 \leq l , r \leq 2 \times n$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道比较简单的贪心。</p><p>题面很明确地告诉我们，这是一道括号匹配问题。因此我们考虑使用栈模拟。</p><p>在模拟时不难发现，只有当栈顶的括号被匹配之后，后面的括号才有可能被匹配。</p><p>So，我们只需要优先匹配栈顶括号即可。</p><p>剩下的就是模拟了，直接看代码注释吧……</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1501</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll n , l[N] , r[N] , p[N];  <span class="comment">//p[i]表示左括号i之前有多少括号</span></span><br><span class="line"><span class="keyword">char</span> ans[N];</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span> &gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    ll cnt = <span class="number">0</span>; <span class="comment">//cnt为当前的括号总数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">        S.push(i);</span><br><span class="line">        p[i] = cnt;</span><br><span class="line">        ans[++ cnt] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!S.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> top = S.top();</span><br><span class="line">            <span class="keyword">if</span>(r[top] + p[top] &lt; cnt)&#123;  </span><br><span class="line">            <span class="comment">//如果当前括号的右端点 + 该括号之前的括号数量小于当前括号总数，则不可能满足</span></span><br><span class="line">                flag = <span class="literal">false</span>;   </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l[top] + p[top] &gt; cnt)&#123;</span><br><span class="line">            <span class="comment">//如果当前括号左端点 + 该括号之前的括号数量大于当前括号总数，则等待之后的左括号补位。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[++ cnt] = <span class="string">&#x27;)&#x27;</span>;  <span class="comment">//否则就进行匹配</span></span><br><span class="line">            S.pop();    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.empty() &amp;&amp; flag == <span class="literal">true</span>)&#123;  <span class="comment">//若最后没有未匹配的括号且都可以满足，则当前序列满足条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> Codeforces </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【USACO &amp; JZOI】挑剔的美食家-题解</title>
      <link href="2019/11/08/luoguP2869/"/>
      <url>2019/11/08/luoguP2869/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>与很多奶牛一样，<code>Farmer John</code>那群养尊处优的奶牛们对食物越来越挑剔，随便拿堆草就能打发她们午饭的日子自然是一去不返了。</p><p>现在，<code>Farmer John</code>不得不去牧草专供商那里购买大量美味多汁的牧草，来满足他那$n$头挑剔的奶牛。</p><p>所有奶牛都对<code>Farmer John</code>提出了她对牧草的要求：第$i$头奶牛要求她的食物每份的价钱不低于$a_i$，并且鲜嫩程度不能低于$B_i$。</p><p>商店里供应有$m$种不同的牧草，第$i$种牧草的定价为$c_i$，鲜嫩程度为$d_i$。</p><p>并且，奶牛们为了显示她们的与众不同，每头奶牛都要求她的食物是独一无二的，也就是说，没有哪两头奶牛会选择同一种食物。</p><p><code>Farmer John</code>想知道，为了让所有奶牛满意，他最少得在购买食物上花多少钱？</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数$n,m$，分别表示奶牛的数量与牧草数量。</p><p>第$2$行到第$n + 1$行每行包含$2$个用空格隔开的整数，分别为$a_i$与$b_i$。</p><p>第$n+2$行到第$n+m+1$行，每行包含$2$个用空格隔开的整数，分别为$c_i$与$d_i$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，包含一个整数，即最小花费。</p><p>若无法满足要求，则输出<code>-1</code>即可。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4 7</span><br><span class="line">1 1</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br><span class="line">4 2</span><br><span class="line">3 2</span><br><span class="line">2 1</span><br><span class="line">4 3</span><br><span class="line">5 2</span><br><span class="line">5 4</span><br><span class="line">2 6</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><hr><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>给奶牛$1$吃价钱为$2$的$2$号牧草，奶牛$2$吃价钱为$4$的$3$号牧草，奶牛$3$分到价钱为$2$的$6$号牧草，奶牛$4$选择价钱为$4$的$7$号牧草，这种分配方案的总花费是$12$。</p><p>可以证明，这是所有方案中花费最少的。</p><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$30\%$的数据，保证$1 \leq n,m \leq 1000$，</p><p>对于$100\%$的数据，保证$1 \leq n , m \leq 10^5$，$1 \leq a_i , b_i , c_i , d_i \leq 10^9$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>比较明显的一道贪心。</p><p>贪心的思路也比较简单，只要先满足美味度要求较高的奶牛，对于美味度要求相同的话，则先满足价格要求低的。</p><p>证明也很容易，不难看出，对于第$i$头奶牛，它可以吃的牧草第$i + 1$头奶牛也一定能吃，因为我们先满足了美味度要求较高的奶牛。</p><p>则我们在枚举每一头奶牛时记录一下现在记录到了哪一个牧草，然后只记录后面的牧草，把该奶牛能吃的牧草加入待选牧草中。选择时选择待选牧草中<strong>不低于当前奶牛价格要求</strong>的牧草中<strong>价值最小</strong>的牧草即可。</p><p>但是，上述做法直接实现的复杂度是$O(n^2)$的，而且很不好写。需要使用数据结构优化。</p><p>重新梳理一下上面的思路，发现我们需要写一种支持以下$3$种操作的数据结构，分别是</p><ol><li>插入一个元素</li><li>删除一个元素</li><li>查询不小于某元素的第一个数，即该元素的后继。</li></ol><p><code>Fhq_Treap</code>即可。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Treap&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lson(x) node[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rson(x) node[x].r</span></span><br><span class="line"></span><br><span class="line">    ll node_num , root;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        ll dis;</span><br><span class="line">        ll size;</span><br><span class="line">        ll rd;</span><br><span class="line">        ll l , r;</span><br><span class="line">        Node(ll dis = <span class="number">0</span>) : dis(dis) , size(<span class="number">1</span>) , rd(rand()) , l(<span class="number">0</span>) , r(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">    &#125;node[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">I <span class="keyword">void</span> <span class="title">update</span><span class="params">(ll x)</span></span>&#123;  </span><br><span class="line">        node[x].size = (lson(x) ? node[lson(x)].size : <span class="number">0</span>) + (rson(x) ? node[rson(x)].size : <span class="number">0</span>) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">spilt</span><span class="params">(ll n , ll k , ll &amp;x , ll &amp;y)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(!n) x = y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node[n].dis &gt; k)&#123;</span><br><span class="line">            spilt(lson(n) , k , x , y);</span><br><span class="line">            lson(n) = y;</span><br><span class="line">            update(y = n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            spilt(rson(n) , k , x , y);</span><br><span class="line">            rson(n) = x;</span><br><span class="line">            update(x = n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">merge</span><span class="params">(ll x , ll y)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">if</span>(node[x].rd &lt; node[y].rd)&#123;</span><br><span class="line">            rson(x) = merge(rson(x) , y);</span><br><span class="line">            update(x);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            lson(y) = merge(x , lson(y));</span><br><span class="line">            update(y);</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll k)</span></span>&#123;</span><br><span class="line">        ll x , y;</span><br><span class="line">        spilt(root , k , x , y);</span><br><span class="line">        node[++ node_num] = Node(k);</span><br><span class="line">        root = merge(merge(x , node_num) , y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(ll k)</span></span>&#123;</span><br><span class="line">        ll x , y , z;</span><br><span class="line">        spilt(root , k , x , z);</span><br><span class="line">        spilt(x , k - <span class="number">1</span> , x , y);</span><br><span class="line">        y = merge(lson(y) , rson(y));</span><br><span class="line">        root = merge(merge(x , y) , z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">I ll <span class="title">upper</span><span class="params">(ll k)</span></span>&#123;</span><br><span class="line">        ll x , y , t;</span><br><span class="line">        spilt(root , k - <span class="number">1</span>, x , y);</span><br><span class="line">        t = y;</span><br><span class="line">        <span class="keyword">while</span>(lson(t))&#123;</span><br><span class="line">            t = lson(t);</span><br><span class="line">        &#125;</span><br><span class="line">        root = merge(x , y);</span><br><span class="line">        <span class="keyword">return</span> node[t].dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n , m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cow</span>&#123;</span></span><br><span class="line">    ll val , del;</span><br><span class="line">&#125;cow[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(Cow a , Cow b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.del &gt; b.del;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cao</span>&#123;</span></span><br><span class="line">    ll val , del;</span><br><span class="line">&#125;cao[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Cao a , Cao b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.del &gt; b.del;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cow[i].val &gt;&gt; cow[i].del;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cao[i].val &gt;&gt; cao[i].del;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cow + <span class="number">1</span> , cow + <span class="number">1</span> + n , cmp1); <span class="comment">//先将奶牛与牧草分别按照美味度降序排序。</span></span><br><span class="line">    sort(cao + <span class="number">1</span> , cao + <span class="number">1</span> + m , cmp2);</span><br><span class="line">    ll tmp , num = <span class="number">1</span> , ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;  i ++)&#123;</span><br><span class="line">        tmp = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cao[num].del &gt;= cow[i].del &amp;&amp; num &lt;= m)&#123;  </span><br><span class="line">            Treap :: insert(cao[num].val);  <span class="comment">//将这头奶牛能吃的牧草全部加入待选牧草</span></span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = Treap :: upper(cow[i].val);   <span class="comment">//寻找该奶牛要求的后继</span></span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="number">-1</span>)&#123;  <span class="comment">//若找不到，则证明无解</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += tmp; <span class="comment">//记录答案</span></span><br><span class="line">        Treap :: remove(tmp);   <span class="comment">//删除该牧草</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> USACO </tag>
            
            <tag> Treap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HNOI2008】越狱-题解</title>
      <link href="2019/11/07/luoguP3197/"/>
      <url>2019/11/07/luoguP3197/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>监狱有连续编号为 $1…n$ 的 $n$ 个房间，每个房间关押一个犯人。</p><p>一共有 $m$ 种宗教，每个犯人可能信仰其中一种。</p><p>如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入仅有一行，包括两个整数 $m , n$，分别表示宗教数量与犯人数量。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，包含一个整数，表示可能越狱的状态数。</p><p>由于这个数可能比较大，因此，请输出该数模 $100003$ 取余的结果。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><hr><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>6种状态为$(000)$,$(001)$,$(011)$,$(100)$,$(110)$,$(111)$</p><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$30\%$的数据，保证$1 \leq m , n \leq 1000$</p><p>对于$100\%$的数据，保证$1 \leq m \leq 10^8$，$1 \leq n \leq 10^{12}$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>真正的组合数学入门题……</p><p>尝试直接做，发现直接统计多少人越狱会很麻烦。</p><p>考虑容斥。很容易看出，越狱的方案数等于总共的方案数减去不会越狱的方案数。</p><p>由于每一个房间信仰的宗教有$m$种可能，一共有$n$个房间，因此，总方案数为$m^n$。</p><p>现在考虑怎么样才不会越狱，显然，只有当两个房间信仰的宗教不同时才不会越狱。</p><p>也就是说，对于第一个房间，我们有$m$种选择，而剩下的房间要保证与之前的房间不同，每一间都有$(m - 1)$种可能。</p><p>综上，最终答案为$m^n - m * (m - 1)^{n - 1}$，直接快速幂计算即可。</p><p>剩下的见代码即可<del>(这题应该不用写注释了吧)</del></p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HA 100003</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n , m;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll a , ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    ll c = Pow(a , n &gt;&gt; <span class="number">1</span>) % HA;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> c * c % HA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((c * c) % HA * a) % HA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    ll ans =  Pow(m , n) - m * Pow(m - <span class="number">1</span> , n - <span class="number">1</span>) % HA;</span><br><span class="line">    ans += HA;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans % HA &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 各省省选 </tag>
            
            <tag> Luogu </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JZOI】统计损失-题解</title>
      <link href="2019/11/06/GmojP3844/"/>
      <url>2019/11/06/GmojP3844/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p><code>SJY</code>有一天被<code>LLT</code>紧急召去计算一些可能的损失。</p><p><code>LLT</code>元首管理的<code>SHB</code>国的交通形成了一棵树，现在将会出现一颗陨石砸在<code>SHB</code>国中，并且陨石砸毁的必定是<code>SHB</code>国构成的交通树上的一条路径。</p><p><code>SHB</code>国的损失可表示为被砸毁的路径上的所有城市价值之积。</p><p>现在还暂时无法确定陨石的掉落路线，所以<code>LLT</code>元首希望<code>SJY</code>能够告诉他<code>SHB</code>国在受到每一种砸毁方式后会受到的损失之和模$10086$之后的值。</p><p>注意：单独的一个节点也被认为是合法的路径。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第$1$行包含一个数$n$，表示城市数。</p><p>第$2$行包含$n$个数，第$i$个数表示第$i$个城市的价值。</p><p>第$3$行到$n+1$行，每行两个数$u,v$，表示城市$u,v$之间有一条道路。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，包含一个数，表示<code>SHB</code>国将受到的损失之和。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">7 6 6 1 1 </span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">778</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$20\%$的数据，保证$0 \leq n \leq 100$;</p><p>对于$50\%$的数据，保证$0 \leq n \leq 3000$;</p><p>对于$100\%$的数据，保证$0 \leq n \leq 10^4$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目中的题意并不明确，需要先理清题意。</p><p>题意即求出一颗树上所有路径的价值之和。路径的价值定义为路径经过的点的乘积。</p><p>考虑树形dp，设$f[i]$表示以$i$为根的子树的答案，转移时从下向上转移。</p><p>不难发现，每一条路径的状态有两种，分别是直链与折链。</p><p>若路径为一条直链，则$f[u] = \sum f[to] * val[u]$，最后的答案为$\sum_{i = 1}^n f[i]$。</p><p>若路径为一条折链，则相当于是两条直链，需要分开处理。</p><p>假设处理到了$u$的子树$v$，则让$to$这颗子树负责其中一条直链，另一条让其他子树负责，即$\sum f[to] * f[son[u]]$，$(son[u] \neq to)$。</p><p>但要注意，由于我们将折链拆成了两条直链，计算时需要使用到$f$数组的元素，因此对于折链的计算是不能加入$f$数组的。直接加入答案即可。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">10086</span>;</span><br><span class="line"><span class="keyword">int</span> n , a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from , to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;edge[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;from , to , head[from]&#125;;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans , f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    f[u] = a[u];    <span class="comment">//由于单独的一个点也是合法路径，所以我们需要加上单独一个点的答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i ; i = edge[i].last)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        search(to , u);</span><br><span class="line">        f[u] += f[to] * a[u] , f[u] %= HA; <span class="comment">//计算直链的答案</span></span><br><span class="line">        ans += sum * f[to] , ans %= HA; <span class="comment">//单独加入折链的答案。</span></span><br><span class="line">        sum += f[to] * a[u] , sum %= HA; </span><br><span class="line">        <span class="comment">//重新计算折链的贡献，这一句必须放于上句之后，因为必定会有一条直链。</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans += f[u] , ans %= HA;    <span class="comment">//最后加入直链的答案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u , v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        add_edge(u , v);</span><br><span class="line">        add_edge(v , u); </span><br><span class="line">    &#125;</span><br><span class="line">    search(<span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans % HA &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JZOI】寻找羔羊-题解</title>
      <link href="2019/11/06/GmojP3843/"/>
      <url>2019/11/06/GmojP3843/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>给定一个仅有小写字母组成的字符串，寻找包含$\text{agnus}$（羔羊）的子串的个数。</p><p>注意：当且仅当两个子串的起始位置和终点不同时，这两个子串属于不同的子串。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行，包含一个字符串，表示题中所述的字符串。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出只有一行，仅一个数字，表示满足题意的子串个数。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">agnusbgnus</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><hr><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>6个子串分别是：$\text{agnus}$、$\text{agnusb}$、$\text{agnusbg}$、$\text{agnusbgn}$、$\text{agnusbgnu}$、$\text{agnusbgnus}$。</p><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于 $40\%$的数据，保证$|s| \leq 10^3$<br>对于 $100\%$的数据，保证$|s| \leq 3 \times 10^4$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道递推好题。</p><p>从样例解释里可以看出，每出现$\text{agnus}$之后，其后边的每个字符均能够形成一个子串。</p><p>同理，每个$\text{agnus}$之前的每个字符也能够形成一个子串。</p><p>这样的话，答案为每个$\text{agnus}$前后字符的数量之积。</p><p>然而，若有两个$\text{agnus}$相连，则会出现重复计算。因此需要注意去重。</p><p>设$l<em>i$表示第$i$个<script type="math/tex">\text{agnus}</script>左边的字符，则去重的方式为$l_i = l_i - l</em>{i - 1}$。因为$l<em>i$与$l</em>{i - 1}$的公共部分已经在计算$l_{i - 1}$时计算过。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 30010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">ll l[N] , r[N] , cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(s.length() &lt; <span class="number">5</span>)&#123; <span class="comment">//特判，当字符串长度小于5时根本不会出现agnus。</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="string">&#x27;0&#x27;</span> + s;    <span class="comment">//将字符串与0拼接，即若原字符串为agnus,则拼接后为0agnus，以便于之后的操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">&#x27;g&#x27;</span> &amp;&amp; s[i + <span class="number">2</span>] == <span class="string">&#x27;n&#x27;</span> &amp;&amp; s[i + <span class="number">3</span>] == <span class="string">&#x27;u&#x27;</span> &amp;&amp; s[i + <span class="number">4</span>] == <span class="string">&#x27;s&#x27;</span>)&#123;</span><br><span class="line">            ++ cnt; <span class="comment">//若找到agnus，则记录</span></span><br><span class="line">            l[cnt] = i; <span class="comment">//记录其左边的字符数</span></span><br><span class="line">            r[cnt] = s.length() - (i + <span class="number">4</span>);  <span class="comment">//记录右边的字符数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++)&#123;</span><br><span class="line">        ans += (l[i] - l[i - <span class="number">1</span>]) * r[i];    <span class="comment">//去重并统计答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> 递推 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JZOI】Alice与Bob的游戏-题解</title>
      <link href="2019/11/04/GmojP1350/"/>
      <url>2019/11/04/GmojP1350/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p><code>Bob</code>经常与<code>Alice</code>一起玩游戏。</p><p>今天，他们在一棵树上玩游戏。<code>Alice</code>有$M_1$块石子，<code>Bob</code>有$M_2$块石子.</p><p>游戏一开始，所有石头放在树的节点处，除了树根。</p><p><code>Alice</code>先移然后两人轮流移动，每次移动只能选择自己的一个石子，而且只能从当前位置移到父亲节点处，游戏过程中允许一个节点处放多个石子。</p><p>谁先把自己所有的石子移到树根处谁就失败了。</p><p>现在假设两人都是非常聪明，游戏过程中都使用最优策略，给定石子起始位置，要你计算出谁是赢家。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含多组测试数据。</p><p>第一行输入$t$，表示测试数据组数。</p><p>接下来每组测试数据第一行输入$3$个整数$N$，$M_1$，$M_2$，其中$N$表示树的节点数。</p><p>接下来$N-1$行描述树，每行包含两个整数$A$和$B$,表示树中有一条边连接$A,B$两点，注意$0$是树根。</p><p>接下来一行$M_1$个数，表示<code>Alice</code>的$M_1$个石子的位置。</p><p>接下来一行$M_2$个数，表示<code>Bob</code>的$M_2$个石子的位置。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包括$t$行，对于每组测试数据，输出赢家的名字。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 1 1</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3 2 1</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Bob</span><br><span class="line">Alice</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$30\%$的数据，保证$1 \leq N \leq 10$ , $1 \leq M1,M2 \leq 3$</p><p>对于$100\%$的数据，保证$1 \leq t \leq 10$，$1 \leq N \leq 10^4$ ，$1 \leq M1,M2 \leq 10^4$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>考场上第一眼以为是道神仙博弈论，结果发现是道结论题……</p><p>不难发现，玩家将其所有石子移向根节点所需的次数决定了其胜负。而这个次数就是其所有石子的深度之和。</p><p>因此我们只要大力搜索一遍，预处理出每个石子在树上的深度，然后比较两人各自的石子深度之和即可。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m1 , m2 , deep[N];</span><br><span class="line"><span class="keyword">int</span> Alice[N] , Bob[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;edge[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;from , to , head[from]&#125;;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> root , <span class="keyword">int</span> fa , <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">deep[root] = dep;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[root]; i ; i = edge[i].last)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to == fa)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        search(to , root , dep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solve&#123;    <span class="comment">//方便处理多组数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;   <span class="comment">//多测不清空，爆零两行泪</span></span><br><span class="line">            Alice[i] = Bob[i] = <span class="number">0</span>;</span><br><span class="line">vis[i] = <span class="literal">false</span>;</span><br><span class="line">            edge[i].to = edge[i].last = edge[i].from = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(head , <span class="number">0</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line">        edge_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u , v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            u ++ , v ++;    <span class="comment">//由于题目中将0作为根节点，因此读入时需要+1以方便处理</span></span><br><span class="line">            add_edge(u , v);</span><br><span class="line">            add_edge(v , u);</span><br><span class="line">        &#125;</span><br><span class="line">        search(<span class="number">1</span> , <span class="number">0</span> , <span class="number">0</span>);  <span class="comment">//预处理各个点的深度</span></span><br><span class="line">        ll A = <span class="number">0</span> , B = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m1; i ++)&#123;  <span class="comment">//计算两个人的权值</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; Alice[i];</span><br><span class="line">            Alice[i] += <span class="number">1</span>;</span><br><span class="line">            A += deep[Alice[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m2; i ++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; Bob[i];</span><br><span class="line">            Bob[i] += <span class="number">1</span>;</span><br><span class="line">            B += deep[Bob[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(A &gt; B) <span class="built_in">puts</span>(<span class="string">&quot;Alice&quot;</span>);    <span class="comment">//若先手的次数大于后手，则先手必胜</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Bob&quot;</span>);   <span class="comment">//否则，后手必胜。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        Solve :: main();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 纪中集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【文章转载】复赛时要记住的30句话</title>
      <link href="2019/11/04/csp-s30sentences/"/>
      <url>2019/11/04/csp-s30sentences/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>请记住：CSP 不怕暴力，怕瞎算，不怕不会，怕不敢。</p></blockquote><p>本文转载于<a href="https://www.luogu.org/blog/zyf2004/fu-sai-shi-yao-ji-zhu-di-30-gou-hua">zhangyifan’s Blog</a>。</p><p>CSP-S2019，RP++</p><hr><ol><li><p><strong>比赛前一天晚上请准备好你的各种证件，事先查好去往考场的路线</strong></p></li><li><p><strong>比赛之前请先调整你的屏幕分辨率到你喜欢的大小</strong></p></li><li><p><strong>比赛之前请把编译器的字体调为你平时惯用的字体，尤其是注意这种字体中的逗号，点，</strong>$1$，$l$<strong>这种易混淆的字是不是区分明显</strong></p></li><li><p><strong>在不影响视野的情况下，请将字号尽可能调大，方便查错</strong></p></li><li><p><strong>请将题目通读完以后，再开始深入思考你认为最容易的一道题</strong></p></li><li><p><strong>即使这道题再容易，即使你做过原题或类似题目，也不要着急写代码。请先明确自己每一步要干什么后，再开始写，轻敌会是你最大的错误</strong></p></li><li><p><strong>即使这道题看起来再没法做，也不要提早放弃，这个时候纸和笔会是你最好的朋友，自己尝试几个例子，也许你就会找到答案</strong></p></li><li><p><strong>请一定先明确自己要干什么之后再写程序，千万不要走一步想一步</strong></p></li><li><p><strong>如果这是一道动态规划题，请先把转移方程写在纸上再编程</strong></p></li><li><p><strong>涉及到边界处理、加一减一之类的问题，请在纸上举个例子，标上下标以后，在编程时参照纸上的下标写</strong> </p></li><li><p><strong>如果思考</strong>$30$<strong>分钟仍一头雾水，没有可以实现的算法，请你果断屏蔽掉</strong>$100\%$<strong>的那一栏数据，开始写</strong>$60\%$，$50\%$<strong>乃至</strong>$30\%$<strong>的算法——在 <del>NOIP</del> CSP里面，</strong>$30$<strong>分绝不是小数目</strong></p></li><li><p><strong>几个常用的复杂度参考</strong>：</p><ul><li>$20-30$，<strong>大概率状压DP</strong>，</li><li>$100$ <strong>以下，可能是搜索</strong>；</li><li>$100$ <strong>到</strong> $500$，$O(n^3)$，<strong>可能是Floyd，高斯消元或一些高维DP</strong></li><li>$1000$ <strong>到</strong> $5000$，$O(n^2)$，<strong>可能是需要优化的DP以及一些组合问题</strong></li><li>$10^5$ <strong>到</strong> $5\times 10^5$，$O(n \log n)$，<strong>排序，线段树等树形数据结构，一些图上算法</strong></li><li>$5 \times 10^5$<strong>到</strong>$5 \times 10^8$，$O(n)$，<strong>线性DP，素数筛法</strong></li><li>$10^9$<strong>以上</strong>，$O(\log n)或O(1)$，<strong>数学，打表找规律</strong></li></ul></li><li><p><strong>如果你发现你旁边的人写得很快，请你放心，他的算法十有八九是错的</strong></p></li><li><p><strong>虽然</strong>$1s+128MB$<strong>内存 (这是以前的了，现在应该是</strong> $1s + 256MB$<strong>) 是标准配置，不过也不是每道题都是这样的，还是请认真阅读试卷首页的试题说明</strong></p></li><li><p><strong>计算内存的方法：数组大小</strong>$\times$<strong>类型长度</strong>$/1000 / 1000=$<strong>所占内存</strong>$MB$<strong>数</strong>，$int$<strong>类型长度是</strong>$4$, $long long$<strong>为</strong>8</p></li><li><p><strong>记不住的话，记住</strong>$int$ <strong>型数组在</strong> $128MB$ <strong>内存下最大开到</strong> $2.5 \times 10^7$<strong>是比较保险的</strong>（占$100MB$内存）</p></li><li><p><strong>写完程序之后，请一定不要忙着编译，请一定要将你的代码从头到尾通读一遍，也就是静态查错，这是整个编程过程中最重要的步骤，有的变量重复调用问题调试的话，一个小时也看不出来，静态查错可以一下指出错误</strong></p></li><li><p><strong>静态查错请注意以下方面</strong>：</p><ul><li><strong>是否写上了<code>using namespace std</code>或<code>std ::</code>？</strong></li><li><strong>数组开得是否够大？</strong></li><li><strong>变量类型是否正确？</strong></li><li><strong><code>memset</code>时，所填的<code>sizeof（XX）</code>的<code>XX</code>是不是匹配？大小是不是正确？</strong></li><li><strong>外层循环与内层循环的<code>i，j</code>是不是混用了？</strong></li><li><strong>循环之前，<code>i，j</code>是否定义了？</strong></li><li><strong>输入数据都输入了吗？</strong></li><li><strong>这个程序是在执行你想让它执行的步骤吗？</strong></li></ul></li><li><p><strong>通过样例后，请你一定不要放松警惕，因为样例并不能覆盖所有的情况，请自己设计几组数据，争取卡死你的程序</strong></p></li><li><p><strong>如果出现问题，请你调试你的程序，请一定要分模块调试，不要从头跟到尾</strong></p></li><li><p><strong>如果你已经设计不出能卡住你的程序的数据，恭喜你可以做下一题了</strong></p></li><li><p><strong>一定先打暴力，再写正解！！！一是一些部分分对于正解有启发作用，二是即使你最后什么都没写出来也不至于空手而归，而且你写的暴力还可以用于对拍来检验正确性，千万不要因为一时偷懒而后悔一年</strong></p></li><li><p><strong>如果你用的是<code>windows</code>，请你注意把<code>system（“pause”）</code>或<code>while(1)</code>注释掉</strong></p></li><li><p><strong>为了万无一失，请你用<code>return 0</code>结束你的程序，千万不要为了偷一点懒而丢一道题</strong></p></li><li><p><strong>在内存允许的情况下，能开普通队列就不要用循环队列，能开下普通数组就不要用滚动数组</strong></p></li><li><p><strong>在时间允许的情况下，能暴力就暴力，高精度能不压位就不压位，优化不需要的就不要</strong></p></li><li><p><strong>总之，在不超限制的前提下，能不优化就不优化，以减少代码量和出错概率为第一原则</strong></p></li><li><p><strong>当比赛还剩下</strong>$5$<strong>到</strong>$15$<strong>分钟的时候</strong>，<strong>除非你有十足的把握，否则请不要再改动你的程序，因为你最后</strong>$15$<strong>分钟一般是改不完的。即使改完，十有八九也是错的。</strong></p></li><li><p><strong>这个时候请你检查是否注释掉了该注释掉的东西，文件名是否写对，文件夹是否建对，请一定反复检查</strong></p></li><li><p><strong>今年赛制更改，没有人知道究竟会变成什么样，所以，与其瞻前顾后，不如集中精力做出你眼前的题目来的实际</strong></p></li><li><p><strong>请记住，<del>NOIP</del> CSP 不怕暴力，怕瞎算，不怕不会，怕不敢</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 转载区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 灌水区 </tag>
            
            <tag> 文章转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论算法】差分约束</title>
      <link href="2019/11/03/difference-constraints/"/>
      <url>2019/11/03/difference-constraints/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近比较颓，把很多原本计划要干的事情咕掉了……</p><p>而今天，我终于找到了一个上午来补各种咕掉的东西。</p><p>于是乎，就有了这篇文章……</p><hr><h2 id="何为差分约束？"><a href="#何为差分约束？" class="headerlink" title="何为差分约束？"></a>何为差分约束？</h2><p>差分约束系统，即给出一组形如$x_u - x_v \geq d$或$x_u - x_v \leq d$的不等式，要求出该组不等式的一组解的问题。</p><hr><h2 id="差分约束的原理"><a href="#差分约束的原理" class="headerlink" title="差分约束的原理"></a>差分约束的原理</h2><p>回忆一下，我们在做图论算法中的单元最短路时，每一次松弛操作都是基于三角不等式的，即$dis_to &lt; dis_from + w$</p><p>如果用代码表示的话，则是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(dis[to] &gt; dis[from] + w)&#123;</span><br><span class="line">    dis[to] = dis[from] + w;</span><br><span class="line">    <span class="comment">//即每时每刻dis[to] &lt;= dis[from] + w</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移一下项，就变成了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dis[to] - dis[from] &lt; w;</span><br></pre></td></tr></table></figure><p>可以看出，这就是上面不等式的形式。</p><p>因此，我们可以把差分约束问题中的变量看做<strong>有向图中的点</strong>，将其不等关系看做<strong>有向图中的边</strong>，之后在图上跑一边单元最短路算法，即可求出该不等式组的一组解。</p><p>而如果图中存在<strong>负权环</strong>，则该不等式组无解。</p><hr><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>对于每个形如$x_u - x_v \leq w$的不等式，我们先对其移项，得到三角不等式的一般形式，即$x_u \leq x_v + w$。</p><p>之后我们连一条从$v$到$u$，权值为$w$的边，跑最短路即可。</p><p>如果是形如$x_u - x_v \geq w$的不等式，则我们可以选择将其化为$x_u \geq x_v + w$来跑最长路，或者将两边同时乘以$-1$，变为$x_v - x_u \leq w$来跑最短路。</p><p>每一次跑最短路时，需要先将起始点的<code>dis</code>设为<code>0</code>，其他点的<code>dis</code>初始化为一个极大值。</p><p>如果图中有负边权，则必须使用<code>Bellman-Ford</code>或<code>SPFA</code>来求解最短路。</p><p>若使用<code>Bellman-Ford</code>，则需要记录其松弛操作的次数。若当其在$n - 1$次松弛操作之后还可以松弛，则证明图中含有<strong>负权环</strong>，原不等式组无解。</p><p>若使用<code>SPFA</code>，则需要记录每个节点的入队次数。若有一个节点入队超过$n$次，则证明图中含有<strong>负权环</strong>，原不等式组无解。</p><p>若最后的跑出来的<code>dis</code>值为刚开始的极大值，则证明两点直接没有任何约束关系。这时的解是无限多的。</p><hr><h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><p>在跑单元最短路之前，我们需要建立一个连接了所有点的超级原点跑一遍最短路，以保证图的联通性。</p><p>若题目中要求求出两个变量之差的最大值，则必须将不等式转换为$x_u - x_v \leq w$的形式来跑最短路。</p><p>反之，则必须转换为$x_u - x_v \geq w$的形式来求最长路。</p><hr><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.org/problem/P4878">LuoguP4878</a>-【USACO】布局</p><p>给出 $n$ 个形如$x_u - x_v \geq d$或$x_u - x_v \leq d$，求一组使$x_1$与$x_n$差最大的解，输出最大差值。</p><p>若无解，请输出 <code>-1</code>，若 $x_1$ 与 $x_n$ 的差为无限大则输出 <code>-2</code>。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 150001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , ml , md;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    ll dis;</span><br><span class="line">&#125;edge[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , ll dis)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;to , head[from] , dis&#125;;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dis[N] , cnt[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N] , flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        dis[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        first = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        vis[first] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[first]; i ; i = edge[i].last)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[edge[i].to] &gt; dis[first] + edge[i].dis)&#123;</span><br><span class="line">            dis[edge[i].to] = dis[first] + edge[i].dis;</span><br><span class="line">                <span class="keyword">if</span> (++ cnt[edge[i].to] &gt;= n)&#123;   <span class="comment">//如果形成负权回路，证明不存在可行路径。</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(vis[edge[i].to] == <span class="literal">false</span>)&#123;</span><br><span class="line">                    vis[edge[i].to] = <span class="literal">true</span>;</span><br><span class="line">                    Q.push(edge[i].to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n] == <span class="number">0x3f3f3f3f</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u , v , d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span> , &amp;n , &amp;ml , &amp;md);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ml; i ++)&#123; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span> , &amp;u , &amp;v , &amp;d);</span><br><span class="line">        add_edge(u , v , d);   <span class="comment">//dis[u] &lt;= dis[v] + d</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= md; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span> , &amp;u , &amp;v , &amp;d);</span><br><span class="line">        add_edge(v , u , -d);   <span class="comment">//dis[v] &lt;= dis[u] - d</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        add_edge(<span class="number">0</span> , i , <span class="number">0</span>);    <span class="comment">//建立超级原点，判断图的联通性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sb = SPFA(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sb &lt;= <span class="number">-1</span>)&#123;   </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sb &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; SPFA(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 差分约束 </tag>
            
            <tag> SPFA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【POI2008 &amp; JZOI】PLA-Postering-题解</title>
      <link href="2019/11/02/luoguP3467/"/>
      <url>2019/11/02/luoguP3467/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p><code>Byteburg</code>市东边的建筑都是以旧结构形式建造的。</p><p>建筑互相紧挨着,之间没有空间。</p><p>它们共同形成了一条长长的,从东向西延伸的建筑物链(建筑物的高度不一)。</p><p><code>Byteburg</code>市的市长<code>Byteasar</code>,决定将这个建筑物链的一侧用海报覆盖住.并且想用最少的海报数量。</p><p>海报是矩形的。海报与海报之间不能重叠,但是可以相互挨着(即它们具有公共边)。</p><p>每一个海报都必须贴近墙并且建筑物链的整个一侧必须被覆盖，即海报需要将一侧全部覆盖,并且不能超出建筑物链)</p><p>现在，请您编写程序帮助计算，并输出最少需要用的海报数量。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为一个整数$n$,表示有$n$个建筑。</p><p>接下来$n$行中,第$i$行表示第$i$个建筑物的宽$d_i$与高$w_i$，中间由一个空格隔开。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，为一个整数,表示最少需要的海报数量.</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 2</span><br><span class="line">2 5</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$100\%$的数据，保证有$1≤n≤2.5 \times 10^5 , 1≤d_i,w_i≤10^9$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>单调栈入门经典必做题。</p><p>考虑所有建筑都一样高时的做法。很显然，当所有建筑高度一致时，我们仅需要一张海报即可覆盖所有的建筑。</p><p>再考虑最坏情况的答案。最坏的做法也就是每一个建筑上都挂一张海报，这时的答案为$n$。也就是说，我们的答案一定不会超过$n$。</p><p>考虑如何减少海报数量。</p><p>不难发现，若有两个不等高的建筑物，则我们所需的海报数量至少为$2$张。</p><p>而如果有一个建筑物，它左右的建筑物都比他低，则可以省下一张海报</p><p>因此我们可以维护一个单调栈，若栈顶高度大于当前入栈的元素，则弹栈，若等于，则将需要的海报数$-1$。直到小于为止。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll n , k , l;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="built_in">stack</span>&lt;ll &gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    ans = n;</span><br><span class="line">    S.push(<span class="number">-0x3f3f3f3f</span>);    <span class="comment">//防止非法访问</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; l;</span><br><span class="line">    S.push(l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; l;</span><br><span class="line">        <span class="keyword">while</span>(S.top() &gt;= l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S.top() == l)&#123;</span><br><span class="line">                ans --;</span><br><span class="line">            &#125;</span><br><span class="line">            S.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        S.push(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> 栈 </tag>
            
            <tag> Luogu </tag>
            
            <tag> POI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【USACO &amp; JZOI】布局-题解</title>
      <link href="2019/10/31/GmojP1295/"/>
      <url>2019/10/31/GmojP1295/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>正如其他物种一样，奶牛们也喜欢在排队打饭时与它们的朋友挨在一起。</p><p>FJ 有编号为 $1\dots N$ 的 $N$ 头奶牛 ($2\le N\le 1000$)。开始时，奶牛们按照编号顺序来排队。奶牛们很笨拙，因此可能有多头奶牛在同一位置上。</p><p>有些奶牛是好基友，它们希望彼此之间的距离小于等于某个数。有些奶牛是情敌，它们希望彼此之间的距离大于等于某个数。</p><p>给出 $M_L$对好基友的编号，以及它们希望彼此之间的距离小于等于多少；</p><p>又给出 $M_D$对情敌的编号，以及它们希望彼此之间的距离大于等于多少 </p><p>请计算：如果满足上述所有条件，$1$ 号奶牛和$N$ 号奶牛之间的距离最大为多少。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：三个整数 $N$, $M_L$, $M_D$，用空格分隔。</p><p>第$2\dots M_L+1$ 行：每行三个整数 $A$, $B$, $D$，用空格分隔，表示 $A$ 号奶牛与 $B$ 号奶牛之间的距离须 $\le D≤D$。</p><p>第 $M_L+2\dots M_L+M_D+1$行：每行三个整数 $A, B, D$，用空格分隔，表示 $A$ 号奶牛与 $B$ 号奶牛之间的距离须 $\ge D$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，一个整数。如果没有合法方案，输出 <code>-1</code>. 如果有合法方案，但 $1$ 号奶牛可以与 $N$ 号奶牛相距无穷远，输出 <code>-2</code>. 否则，输出 $1$ 号奶牛与 $N$ 号奶牛间的最大距离。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4 2 1</span><br><span class="line">1 3 10</span><br><span class="line">2 4 20</span><br><span class="line">2 3 3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">27</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于 $100\%$ 的数据，保证 $1\le A&lt;B\le N,1\le D\le 10^6$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>差分约束系统的经典题目。</p><p>题目可以转换为对于一对基友，他们的距离需要满足 $x_v - x_u \leq d$。</p><p>而对于一对情敌，他们之间的距离需要满足 $x_v - x_u \geq d$。</p><p>既然这样，我们就得到了一对二元一次不等式组，即$x_v - x_u \leq d$且$x_v - x_u \geq d$</p><p>转变一下，也就成了$x_v - x_u \leq d$且$x_u - x_v \leq -d$</p><p>转变成有向图跑最短路即可。</p><p>还有就是</p><p><strong>跑最短路时请使用SPFA，因为有负边权</strong>。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 150001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , ml , md;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    ll dis;</span><br><span class="line">&#125;edge[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , ll dis)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;to , head[from] , dis&#125;;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dis[N] , cnt[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N] , flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        dis[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        first = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        vis[first] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[first]; i ; i = edge[i].last)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[edge[i].to] &gt; dis[first] + edge[i].dis)&#123;</span><br><span class="line">            dis[edge[i].to] = dis[first] + edge[i].dis;</span><br><span class="line">                <span class="keyword">if</span> (++ cnt[edge[i].to] &gt;= n)&#123;   <span class="comment">//如果形成负权回路，证明不存在可行路径。</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(vis[edge[i].to] == <span class="literal">false</span>)&#123;</span><br><span class="line">                    vis[edge[i].to] = <span class="literal">true</span>;</span><br><span class="line">                    Q.push(edge[i].to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n] == <span class="number">0x3f3f3f3f</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u , v , d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span> , &amp;n , &amp;ml , &amp;md);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ml; i ++)&#123; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span> , &amp;u , &amp;v , &amp;d);</span><br><span class="line">        add_edge(u , v , d);   <span class="comment">//dis[u] &lt;= dis[v] + d</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= md; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span> , &amp;u , &amp;v , &amp;d);</span><br><span class="line">        add_edge(v , u , -d);   <span class="comment">//dis[v] &lt;= dis[u] - d</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        add_edge(<span class="number">0</span> , i , <span class="number">0</span>);    <span class="comment">//建立超级原点，判断图的联通性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sb = SPFA(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sb &lt;= <span class="number">-1</span>)&#123;   </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sb &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; SPFA(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> 差分约束 </tag>
            
            <tag> SPFA </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STL】浅谈STL在OI中的应用</title>
      <link href="2019/10/30/STL-plus/"/>
      <url>2019/10/30/STL-plus/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>把STL放在心底，永远都有惊喜<br>                      ——《Tonight Forever》</p></blockquote><p>众所周知，C++语言有一个巨大的标准模板库，即STL。其内部包含了大量模板与容器。</p><p>正确的使用STL，可以极大提高代码编写的效率。</p><p>而<code>NOI</code>系列赛事在$2011$年起允许选手使用STL，这无疑为C++党带来了福音。</p><p>因此，学好STL是一件很重要的事情。</p><hr><h1 id="STL的分类"><a href="#STL的分类" class="headerlink" title="STL的分类"></a>STL的分类</h1><blockquote><p>STL可分为容器（containers）、迭代器（iterators）、空间配置器（allocator）、配接器（adapters）、算法（algorithms）、仿函数（functors）六个部分。</p></blockquote><p>由于文章篇幅限制，本文只会讲解容器，迭代器，算法三个部分，其他三部分一般很少在$OI$中用到。</p><hr><h1 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>命名空间(即<code>namespace</code>)是C++的一大特性，可以用来解决变量或函数重名问题。</p><p>举个栗子，比如<code>Payphone-X</code>在一次考试中采用了数据分治，需要写两个叫做<code>work</code>的函数。</p><p>如果直接写的话必定会导致编译失败。而分开写又很难分清到底是那一档部分分。</p><p>这时候就可以通过写两个<code>namespace</code>来解决问题。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Subtask1&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        …………</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Subtask2&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        …………</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">        Subtast1 :: work(a , b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Sbutask2 :: work(a , b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中每一个<code>namespace</code>之间都是相互独立的，调用之前需要添加<code>NAME :: name()</code>，表示调用<code>NAME</code>命名空间内的<code>name</code>函数。</p><p>当然，也可以选择写<code>using namespace NAME</code>，将<code>NAME</code>这个命名空间引入全局。这样就可以访问这个命名空间的全部内容，但更容易引起变量冲突。</p><p>而STL的所有内容都在<code>std</code>这个命名空间内，使用时需要加<code>std ::</code>或者<code>using namespace std</code></p><hr><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载可以在有歧义的情况下赋予运算符一个具体的比较参数。</p><p>举个栗子，在我们平时写邻接表时，我们很多时候需要根据边权大小进行排序。</p><p>直接排序肯定是不行的。这时，我们就可以选择重载运算符。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对m条边根据边权大小进行升序排序</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    <span class="keyword">int</span> dis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis &lt; other.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span> :: sort(edge + <span class="number">1</span> , edge + <span class="number">1</span> + m);</span><br></pre></td></tr></table></figure><p>上面的写法等价于</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    <span class="keyword">int</span> dis;</span><br><span class="line">&#125;edge[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a , Edge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dis &lt; b.dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span> :: sort(edge + <span class="number">1</span> , edge + <span class="number">1</span> + m , cmp);</span><br></pre></td></tr></table></figure><hr><h2 id="预编译指令"><a href="#预编译指令" class="headerlink" title="预编译指令"></a>预编译指令</h2><p>预处理命令就是我们程序开头以<code>#</code>字符开头的命令。叫他们预编译指令是因为这些命令是在编译时的第一步就执行，不会随编译转为汇编码。</p><p>最常用的预编译指令有三种，分别是<code>include</code>,<code>define</code>,<code>pragma</code>。</p><p>其中，<code>include</code>用来调用头文件，<code>define</code>用来进行文本替换，而<code>pragma</code>可以指定编译选项，或者让编译器完成一些命令。</p><p>但要注意，<strong>NOI系列赛事是禁止使用pragma系列的编译指令的</strong>，在这里就不多介绍了。</p><p>感兴趣的同学可以参考<a href="https://www.luogu.org/blog/ofnoname/yu-chu-li-ming-ling?tdsourcetag=s_pctim_aiomsg">这篇文章</a>自行了解一下。</p><hr><h1 id="算法系列"><a href="#算法系列" class="headerlink" title="算法系列"></a>算法系列</h1><p>STL的算法都包含在<code>algorithm</code>库中，使用之前需要<code>#include&lt;algorithm&gt;</code>。</p><p>提醒一句，<strong>这个文件名很重要，一定要背下来，每天一遍！</strong></p><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序(即<code>sort</code>与<code>stable_sort</code>)，是最常用的STL函数之一。可以对一段区间进行排序。</p><p>其中，<code>sort</code>为不稳定排序，采用的是类似于快速排序的算法实现，十分高效，期望时间复杂度为$O(n \log n)$，一般比较常用。</p><p>而<code>stable_sort</code>为稳定排序，采用的是类似于归并排序的算法实现，可以在稳定的情况下获得较高的效率，时间复杂度为$O(n \log n)$。</p><p>使用方法如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对数组a的n个元素升序排序(即从小到大排序)</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span> :: sort(a + <span class="number">1</span> , a + <span class="number">1</span> + n);</span><br></pre></td></tr></table></figure><p>如果要<strong>降序排序</strong>(即从大到小排序)的话需要手写<code>cmp</code>函数，即</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对数组a的n个元素降序排序(即从大到小排序)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span> :: sort(a + <span class="number">1</span> , a + <span class="number">1</span> + n , cmp);</span><br></pre></td></tr></table></figure><p>而如果<strong>对结构体进行排序</strong>的话需要重载运算符或手写<code>cmp</code>函数，具体使用方法如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将结构体Node按照y为关键字进行升序排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y &lt; other.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span> :: sort(node + <span class="number">1</span> , node + <span class="number">1</span> + n);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">&#125;node[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a , Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span> :: sort(node + <span class="number">1</span> , node + <span class="number">1</span> + n , cmp);</span><br></pre></td></tr></table></figure><p>下面的代码演示了对$n(n &lt; 10^5)$个整数进行<strong>降序</strong>排序后并输出。可以借助其理解<code>sort</code>函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span> , a + <span class="number">1</span> + n , cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>去重函数(即<code>unique</code>)函数可以对一段序列实现<strong>伪</strong>去重，并不会删除重复的元素，而是将重复元素放到序列末尾。</p><p><strong>使用<code>unique</code>函数之前必须保证序列是有序的</strong>（升序降序均可）。</p><p><code>unique</code>会返回去重后的数组的最后一个元素，一般通过用返回值减去首地址的方法获得不重复的元素数。即</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="built_in">std</span> :: unique(a + <span class="number">1</span> , a + <span class="number">1</span> + n) - a - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(n)$,一般用于离散化。</p><p>下面的代码演示了对$n(n &lt; 10^5)$个整数进行降序排序后去重并输出。可以借助其理解<code>unique</code>函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span> , a + <span class="number">1</span> + n , cmp);</span><br><span class="line">    <span class="keyword">int</span> number = unique(a + <span class="number">1</span> , a + <span class="number">1</span> + n) - <span class="number">1</span> - a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= number; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><p>交换函数(即<code>swap</code>)，可以交换任意两个<strong>同类型元素</strong>的值。</p><p>时间复杂度$O(1)$。</p><p>使用方法如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span> :: swap(a , b);</span><br></pre></td></tr></table></figure><hr><h2 id="最大值-amp-最小值"><a href="#最大值-amp-最小值" class="headerlink" title="最大值 &amp; 最小值"></a>最大值 &amp; 最小值</h2><p>即<code>max</code>与<code>min</code>函数。可以返回两个<strong>同类型元素</strong>的最大值或最小值。</p><p>时间复杂度$O(1)$。</p><p>使用方法如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a , b;</span><br><span class="line"><span class="built_in">std</span> :: max(a , b);</span><br><span class="line"><span class="built_in">std</span> :: min(a , b);</span><br></pre></td></tr></table></figure><p>如果要取出一组元素的最大或最小值，可以使用<code>max_element</code>或<code>min_element</code>，时间复杂度均为$O(n)$</p><p>使用方法如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxn = max_element(a + <span class="number">1</span> , a + <span class="number">1</span> + n);</span><br><span class="line"><span class="keyword">int</span> minn = min_element(a + <span class="number">1</span> , a + <span class="number">1</span> + n);</span><br></pre></td></tr></table></figure><hr><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>STL用于查找的函数有三个，分别是<code>lower_bound</code>,<code>upper_bound</code>与<code>binary_search</code>，最为常用的是<code>lower_bound</code>。</p><p><code>lower_bound</code>用于在一个升序序列中查找某个元素，并返回第一个<strong>不小于该元素</strong>的元素的迭代器，如果找不到，则返回指向序列中最后一个元素之后的迭代器。</p><p>而<code>upper_bound</code>用于在一个升序序列中查找某个元素，并返回第一个<strong>大于该元素</strong>的元素的迭代器，如果找不到，则返回指向序列中最后一个元素之后的迭代器。</p><p><code>binary_search</code>用于确定某个元素有没有在一个升序序列中出现过，返回<code>true</code>或<code>false</code>。</p><p>三个函数的时间复杂度均为$O(\log n)$。</p><p>使用方法如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[N] = &#123;<span class="number">0</span> , <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">6</span> , <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num1 = lower_bound(a + <span class="number">1</span> , a + <span class="number">8</span> , <span class="number">3</span>) - a - <span class="number">1</span>;  <span class="comment">//答案是2</span></span><br><span class="line"><span class="keyword">int</span> num2 = upper_bound(a + <span class="number">1</span> , a + <span class="number">8</span> , <span class="number">3</span>) - a - <span class="number">1</span>;  <span class="comment">//答案是3</span></span><br><span class="line"><span class="keyword">bool</span> num3 = binary_search(a + <span class="number">1</span> , a + <span class="number">8</span> , <span class="number">3</span>)    <span class="comment">//答案为1，即true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>即<code>next_permutation</code>函数，可以枚举一段序列的全排列。</p><p>由于全排列数量为$O(n!)$，因此它的时间复杂度也是$O(n!)$的。</p><p>使用方法如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(next_permutation(a, a + <span class="number">4</span>));</span><br></pre></td></tr></table></figure><hr><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是用于访问 STL 容器中元素的一种数据类型，一般迭代器的声明如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span> :: NAME&lt;TYPE &gt; :: iterator p;</span><br></pre></td></tr></table></figure><p>其中，<code>NAME</code>为该迭代器的名字，而<code>TYPE</code>为该迭代器存储的元素类型。</p><p>一般来说，一个容器的<code>begin()</code>返回的是该容器<strong>首个元素</strong>的迭代器，而<code>end()</code>返回的是该容器<strong>最后一个元素之后</strong>的迭代器。</p><p>也就是说，容器的<code>begin()</code>与<code>end()</code>表示的是一个<strong>左闭右开区间</strong>，其中，<strong><code>begin()</code>在这个区间内，而<code>end()</code>不在</strong></p><p>因此，不要试图去访问<code>end()</code>对应的元素。这是非法的。</p><p>在使用 STL 的容器或算法时，也可以使用<code>begin()</code>与<code>end()</code>来表示一段区间。如</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span> :: sort(V.begin() , V.end());</span><br></pre></td></tr></table></figure><p>有一部分容器的迭代器支持随机访问，比如<code>vector</code>，访问<code>vector[i]</code>相当于访问<code>vector.begin() + i</code>。但有些<code>set</code>这样的迭代器是不支持随机访问的。</p><p>一般的，使用迭代器遍历容器类似于以下代码，可以借其理解迭代器的具体实现。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span> :: NAME&lt;T &gt; :: iterator p = C.begin(); p != C.end(); p ++) &#123;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p><code>stack</code>即栈，是一种<strong>后入先出</strong>的数据结构，包含于<code>#include&lt;stack&gt;</code>中。</p><p>可以通过<code>stack&lt;int &gt; S</code>来定义一个内部元素为<code>int</code>的栈。</p><p>具体操作如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作名称</th><th style="text-align:center">实现方式</th><th style="text-align:center">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">插入一个元素</td><td style="text-align:center"><code>S.push()</code></td><td style="text-align:center">$O(1)$</td></tr><tr><td style="text-align:center">获得栈顶元素(不删除)</td><td style="text-align:center"><code>S.top()</code></td><td style="text-align:center">$O(1)$</td></tr><tr><td style="text-align:center">判断是否为空</td><td style="text-align:center"><code>S.empty()</code></td><td style="text-align:center">$O(1)$</td></tr><tr><td style="text-align:center">删除栈顶元素</td><td style="text-align:center"><code>S.pop()</code></td><td style="text-align:center">$O(1)$</td></tr></tbody></table></div><p>下面的代码对于这些操作进行了演示，可以借此理解栈的基本操作。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span> &gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = S.empty();  <span class="comment">//flag = true;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i ++)&#123;</span><br><span class="line">        S.push(<span class="number">20040921</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!S.empty())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S.top() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        S.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//依次输出20040924 ， 20040923 ，20040922</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><code>queue</code>即队列，是一种<strong>后入后出</strong>的数据结构，包含于<code>#include&lt;queue&gt;</code>中</p><p>可以通过<code>queue&lt;int &gt; Q</code>来定义一个内部元素为<code>int</code>型的队列。</p><p>具体操作如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作名称</th><th style="text-align:center">实现方式</th><th style="text-align:center">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">在队尾插入一个元素</td><td style="text-align:center"><code>Q.push()</code></td><td style="text-align:center">$O(1)$</td></tr><tr><td style="text-align:center">获得队首元素(不删除)</td><td style="text-align:center"><code>Q.front()</code></td><td style="text-align:center">$O(1)$</td></tr><tr><td style="text-align:center">获得队尾元素(不删除)</td><td style="text-align:center"><code>Q.back()</code></td><td style="text-align:center">$O(1)$</td></tr><tr><td style="text-align:center">判断是否为空</td><td style="text-align:center"><code>Q.empty()</code></td><td style="text-align:center">$O(1)$</td></tr><tr><td style="text-align:center">删除队首元素</td><td style="text-align:center"><code>Q.pop()</code></td><td style="text-align:center">$O(1)$</td></tr><tr><td style="text-align:center">获得队列中元素个数</td><td style="text-align:center"><code>Q.size()</code></td><td style="text-align:center">$O(1)$</td></tr></tbody></table></div><p>下面的代码对于这些操作进行了演示，可以借此理解队列的基本操作。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = Q.empty();  <span class="comment">//flag = true</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i ++)&#123;</span><br><span class="line">        Q.push(<span class="number">20040921</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = Q.front();  <span class="comment">//a = 20040922</span></span><br><span class="line">    <span class="keyword">int</span> b = Q.back();   <span class="comment">//b = 20040924</span></span><br><span class="line">    <span class="keyword">int</span> size = Q.size();    <span class="comment">//size = 3</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Q.front() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        Q.pop();        <span class="comment">//输出依次为20040924，20040923 ，20040922</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Priority-queue"><a href="#Priority-queue" class="headerlink" title="Priority_queue"></a>Priority_queue</h2><p><code>priority_queue</code>即优先队列，又称二叉堆。可以<strong>随时获取区间最值</strong></p><p>使用之前需要添加<code>#include&lt;queue&gt;</code>。</p><p>由于优先队列为树形结构，因此它的时间复杂度会带一个$\log$，具体复杂度详见下表。</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作名称</th><th style="text-align:center">实现方式</th><th style="text-align:center">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">插入一个元素</td><td style="text-align:center"><code>Q.push()</code></td><td style="text-align:center">$O(\log n)$</td></tr><tr><td style="text-align:center">获得堆顶元素(不删除)</td><td style="text-align:center"><code>Q.top()</code></td><td style="text-align:center">$O(1)$</td></tr><tr><td style="text-align:center">判断是否为空</td><td style="text-align:center"><code>Q.empty()</code></td><td style="text-align:center">$O(1)$</td></tr><tr><td style="text-align:center">删除堆顶元素</td><td style="text-align:center"><code>Q.pop()</code></td><td style="text-align:center">$O(\log n)$</td></tr></tbody></table></div><p>但要注意，<code>priority_queue</code><strong>默认提供</strong>的优先队列是<strong>最大优先队列，即大根堆</strong>，若需要使用最小优先队列，需要按照以下方法声明</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span> , <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; , greater&lt;<span class="keyword">int</span> &gt; &gt; Q;</span><br></pre></td></tr></table></figure><p>其中，<code>greater&lt;int &gt;</code>的后面需要多打一个空格，否则会被编译器识别为右移<code>&gt;&gt;</code>运算符而报错。</p><hr><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><code>vector</code>即动态数组，是一种<strong>可以根据放入元素的多少来自动扩充</strong>的数组。包含于<code>#include&lt;vector&gt;</code>中。</p><p>可以使用<code>vector&lt;int &gt; V</code>来定义一个内部元素为<code>int</code>型的动态数组。</p><p>具体操作如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作名称</th><th style="text-align:center">实现方式</th><th style="text-align:center">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">在尾部插入一个元素</td><td style="text-align:center"><code>V.push_back()</code></td><td style="text-align:center">$O(1)$</td></tr><tr><td style="text-align:center">删除尾部元素</td><td style="text-align:center"><code>V.pop_back()</code></td><td style="text-align:center">$O(1)$</td></tr><tr><td style="text-align:center">在特定位置插入元素</td><td style="text-align:center"><code>V.insert()</code></td><td style="text-align:center">$O(n)$</td></tr><tr><td style="text-align:center">删除特定位置的元素</td><td style="text-align:center"><code>V.erase()</code></td><td style="text-align:center">$O(n)$</td></tr><tr><td style="text-align:center">获得元素数量</td><td style="text-align:center"><code>V.size()</code></td><td style="text-align:center">$O(1)$</td></tr><tr><td style="text-align:center">对数组进行排序</td><td style="text-align:center"><code>sort(V.begin() , V.end())</code></td><td style="text-align:center">$O(n \log n)$</td></tr></tbody></table></div><p>需要注意的是，在加入元素时，如果 <code>vector</code> 拥有的内存空间不足以存放欲加入的元素，则 <code>vector</code> 会申请一块新的内存，并将旧数据拷贝过去。这个过程的时间复杂度是$O(n)$的。</p><hr><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>set</code>即集合，是STL提供的最良心容器之一，其内部利用红黑树实现。</p><p>说其良心是因为<code>set</code>中的元素会自动<strong>升序排列</strong>，且<strong>具有唯一性</strong>，很方便我们进行各项操作。</p><p>但可惜的是，<code>set</code>并不支持随机访问，即无法使用下标来访问集合中的元素，只能通过迭代器遍历。</p><p>在使用<code>set</code>之前，我们需要包含<code>#include&lt;set&gt;</code>这个头文件，并对其定义，格式如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span> &gt; S;    <span class="comment">//定义一个类型为int的set</span></span><br></pre></td></tr></table></figure><p>其具体操作如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作名称</th><th style="text-align:center">实现方式</th><th style="text-align:center">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">插入一个元素</td><td style="text-align:center"><code>S.insert()</code></td><td style="text-align:center">$O(\log n)$</td></tr><tr><td style="text-align:center">删除一个元素</td><td style="text-align:center"><code>S.erase()</code></td><td style="text-align:center">$O(\log n)$</td></tr></tbody></table></div><p>若需要遍历<code>set</code>则必须使用迭代器，其迭代器为<code>set&lt;T &gt; :: iterator</code>，其中<code>T</code>为其元素类型。</p><hr><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>map</code>是STL中的一个关联容器，可以提供一对一的数据对应。和<code>set</code>一样，其内部也是用红黑树实现的。</p><p>可以形象化的将<code>map</code>理解为一个可以使用任何元素作为下标的数组。</p><p>使用<code>map</code>之前，我们需要包含<code>#include&lt;map&gt;</code>这个头文件，并对其定义，格式如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span> , <span class="keyword">int</span> &gt; M;   <span class="comment">//定义一个以string为下标，映射为int的map</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个以字符串做下标，整数作为其映射的<code>map</code>。</p><p>使用时，我们可以</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">M[<span class="string">&quot;qwq&quot;</span>] = <span class="number">123456789</span>;</span><br></pre></td></tr></table></figure><p>值得注意的是，由于<code>map</code>本身为红黑树实现，是一种树形结构，它的复杂度为$O(\log n)$的，而不是$O(1)$。</p><p>因此，map只能对于一些特殊映射进行存储，而不能直接当做数组使用。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://oi.men.ci/">Menci’s Blog</a></li><li><a href="http://www.cplusplus.com/reference/map/">C++ Reference - map</a></li><li><a href="http://www.cplusplus.com/reference/set/">C++ Reference - set</a></li></ol><p>感谢<a href="https://oi.men.ci/">Menci</a>在STL学习中给我的帮助。</p><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> STL </tag>
            
            <tag> Algorithm </tag>
            
            <tag> 总结篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JZOI】休息-题解</title>
      <link href="2019/10/30/GmojP3462/"/>
      <url>2019/10/30/GmojP3462/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>休息的时候，可以放松放松浑身的肌肉，打扫打扫卫生，感觉很舒服。</p><p>在某一天，某<code>LMZ</code>开始整理他那书架。已知他的书有$n$本，从左到右按顺序排列。</p><p>他想把书从矮到高排好序，而每一本书都有一个独一无二的高度$h_i$。</p><p>他排序的方法是：每一次将所有的书划分为尽量少的连续部分，使得每一部分的书的高度都是单调下降，然后将其中所有不少于$2$本书的区间全部翻转。重复执行以上操作，最后使得书的高度全部单调上升。</p><p>可是毕竟是休息时间，<code>LMZ</code>不想花太多时间在给书排序这种事上面。</p><p>因此他划分并翻转完第一次书之后，他想计算，他一共执行了多少次翻转操作才能把所有的书排好序。</p><p><code>LMZ</code>惊奇地发现，第一次排序之前，他第一次划分出来的所有区间的长度都是偶数。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数$n$, 为书的总数。</p><p>接下来一行$n$个数，第$i$个正整数$h_i$，为第$i$本书的高度。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅一个整数，为<code>LMZ</code>需要做的翻转操作的次数。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5 3 2 1 6 4</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><hr><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>第一次划分之后，翻转$\lbrack 5,3,2,1 \rbrack$，$\lbrack 6,4 \rbrack$。之后，书的高度为$1 , 2 , 3 , 5 , 4 , 6$，然后便是翻转$\lbrack 5,4 \rbrack$即可。</p><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$10\%$的数据：$n&lt;=50$</p><p>对于$40\%$的数据：$n&lt;=3\times 10^3$</p><p>对于$100\%$的数据：$1&lt;=n&lt;=10^5, 1&lt;=h_i&lt;=n$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道比较显然的结论题。</p><p>先说解法。首先，找出所有的单调下降序列，然后把他们全部翻转过来，记录翻转的次数。</p><p>之后求出翻转后序列的逆序对数，答案就是逆序对数与翻转次数之和。</p><p>证明如下：</p><p>在找出所有的单调下降序列并翻转后，可以发现，刚刚找到的区间内的元素都已经变得有序。</p><p>也就是说，只有两个小区间之间的数可以进行交换。</p><p>显然，我们只会交换两个降序的数。即逆序对。</p><p>因此答案为逆序对数与翻转次数之和。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tree_array&#123;</span><br><span class="line">    ll tree[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (- x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">I <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x , ll val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))&#123;</span><br><span class="line">            tree[i] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">I ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i ; i -= lowbit(i))&#123;</span><br><span class="line">            ans += tree[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[N] , b[N] , ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;     <span class="comment">//离散化输入数据</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + <span class="number">1</span> , b + <span class="number">1</span> + n);</span><br><span class="line">    ll number = unique(b + <span class="number">1</span> , b + <span class="number">1</span> + n) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        a[i] = lower_bound(b + <span class="number">1</span> , b + <span class="number">1</span> + number , a[i]) - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    input();</span><br><span class="line">    ll l = <span class="number">1</span> , r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;   <span class="comment">//手动模拟，找出单调下降序列</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; n &amp;&amp; a[i] &gt; a[i + <span class="number">1</span>])&#123;</span><br><span class="line">            r ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                    swap(a[l] , a[r]);</span><br><span class="line">                    l ++ , r --;</span><br><span class="line">                &#125;</span><br><span class="line">                ans ++;</span><br><span class="line">            &#125;</span><br><span class="line">            l = r = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;   <span class="comment">//树状数组求逆序对数</span></span><br><span class="line">        Tree_array :: add(a[i] , <span class="number">1</span>);</span><br><span class="line">        ans += i - Tree_array :: query(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> 逆序对 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces】Smile House-题解</title>
      <link href="2019/10/29/CF147B/"/>
      <url>2019/10/29/CF147B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>给你$n$个点，$m$条边的无向图。但一条无向边的两个方向的边权不同，求图上最小正环的大小。</p><p>正环为从一个点出发再回到这个点经过所有边边权之和为正，定义最小正环的含义为这个正环经过的点数最少</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数$n$，$m$，表示点数和边数</p><p>接下来$m$行，一行四个整数$x,y,z,w$，表示$x$到$y$有一条边，$x$到$y$的边权为$z$，$y$到$x$的边权为$w$</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，包含一个整数，表示最小正环的大小（即这个正环上点的个数）。</p><p>如果没有正环请输出$0$</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 -10 3</span><br><span class="line">1 3 1 -10</span><br><span class="line">2 4 -10 -1</span><br><span class="line">3 4 0 -3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$30\%$的数据，保证$n&lt;=10$;</p><p>对于$60\%$的数据，保证$n&lt;=100$;</p><p>对于$100\%$的数据，保证$n&lt;=300$;</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道看起来很像搜索的动态规划。<del>(考场上爆搜打挂的我哭出声来)</del></p><p>不难看出，这题是在图上做的，且这题的数据范围极小。很容易就能想到$Floyd$。</p><p>而$Floyd$的本质是$DP$。考虑如何在$Floyd$的基础上$DP$。</p><p>设$f[l][i][j]$表示从$i$到$j$经过$l$条边的路径大小，可得状态转移方程<script type="math/tex">f[l][i][j] = max(f[l][i][j] , f[l - 1][i][k] + f[1][k][j])</script></p><p>其中，$l,i,j,k$均需要在转移时枚举，时间复杂度为$O(n^4)$，无法通过$100\%$的数据。<del>但您可以拿到80分</del></p><p>考虑如何优化这个$DP$。由于这个$DP$基于$Floyd$，因此$i , j , k$必须进行枚举，而$l$却可以使用倍增来优化。</p><p>则我们重新设计状态。设$f[l][i][j]$表示从$i$到$j$经过$2^l$条边的路径大小，可得状态转移方程<script type="math/tex">f[l][i][j] = max(f[l][i][j] , f[l - 1][i][k] + f[l - 1][k][j])</script></p><p>这个过程的时间复杂度是$O(n^3 \log n)$的。</p><p>之后我们采用类似于倍增爬树的方法来求解答案。首先，我们先尝试走$2^l$条边从$i$到$j$的路径大小。</p><p>若不存在正环(即$f[l][i][i] &lt; 0$)，则证明答案大于$2^l$。下一次转移时<strong>增加</strong>$2^{l - 1}$条边即可。</p><p>否则的话证明答案小等于$2^l$，下一次转移时仅<strong>尝试</strong>$2^{l - 1}$条边即可。</p><p>时间复杂度为$O(n^3 \log n)$，足以通过本题。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-80pts"><a href="#Code-80pts" class="headerlink" title="Code[80pts]"></a>Code[80pts]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 301</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> f[N][N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> u , v , d1 , d2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;       <span class="comment">//初始化数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)&#123;</span><br><span class="line">                f[i][j][k] = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; d1 &gt;&gt; d2;</span><br><span class="line">        f[<span class="number">1</span>][u][v] = d1;</span><br><span class="line">        f[<span class="number">1</span>][v][u] = d2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">                    f[l][i][j] = max(f[l][i][j] , f[l - <span class="number">1</span>][i][k] + f[<span class="number">1</span>][k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(f[l][i][i] &gt; <span class="number">0</span>)&#123; <span class="comment">//如果找到了一个正环，则输出环的长度即可。</span></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 301</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">int</span> u , v , d1 , d2;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">15</span>][N][N];</span><br><span class="line"><span class="keyword">int</span> tmp[N][N], last[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(last, <span class="number">-0x3f3f3f3f</span>, <span class="keyword">sizeof</span>(last));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f3f3f3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; d1 &gt;&gt; d2;</span><br><span class="line">        f[<span class="number">0</span>][u][v] = d1;</span><br><span class="line">        f[<span class="number">0</span>][v][u] = d2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        last[i][i] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">10</span>; l++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                    f[l][i][j] = max(f[l][i][j], f[l - <span class="number">1</span>][i][k] + f[l - <span class="number">1</span>][k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">10</span>; l &gt;= <span class="number">0</span>; l--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">-0x3f3f3f3f</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                    tmp[i][j] = max(tmp[i][j], last[i][k] + f[l][k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i][i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                    last[i][j] = tmp[i][j];</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            ans += <span class="number">1</span> &lt;&lt; l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans &gt;= n ? <span class="number">0</span> : ans + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 倍增 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> Floyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces &amp; JZOI】Porcelain-题解</title>
      <link href="2019/10/29/CF148E/"/>
      <url>2019/10/29/CF148E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>有一个公主一生气就喜欢摔东西。</p><p>现在有很多个柜子，每个柜子里面装着很多物品，公主每次摔东西只能随机的选择一个柜子，拿出最左边或者最右边的一个物品摔碎，</p><p>给出公主最多生气的次数$m$，求生完气之后，公主摔掉物品的价值的最大总和。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入$n$,$m$,$n$为柜子的层数，$m$为公主最多生气的次数。</p><p>接下来$n$行，每行第一个输入该层物品的数量$k$,接下来输入$k$个物品的价值$v_i$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一个整数$ans$，表示公主摔掉物品的价值的最大总和。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">3 3 7 2</span><br><span class="line">3 4 1 5</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1 3</span><br><span class="line">4 4 3 1 2</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$100\%$的数据，保证$1&lt;=n&lt;=100$,$1&lt;=m&lt;=10000$,$1&lt;=k&lt;=100$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道<del>毒瘤的</del>区间$DP$。</p><p>首先，题目中规定只能取边上的物品。因此每次取完之后剩下的必然也是一个区间。</p><p>考虑使用前缀和维护。设$sum[i][j]$表示第$i$行中前$j$个物品的价值总和，很容易得到后$k$个物品的价值为$sum[i][num[i] - j]$。其中$num[i]$为第$i$行的物品数量。</p><p>之后我们设$dp[i][j]$为在<strong>第</strong>$i$行中拿出$j$个物品的最大价值。易得状态转移方程<script type="math/tex">dp[i][j] = max(dp[i][j] , sum[i][k] + sum[i][num[i]] - sum[i][num[i] - (j - k)])</script></p><p>这样我们就可以解决一行了。但是对于多行我们又该怎么办呐？</p><p>很简单，我们设$f[i][j]$表示从<strong>前</strong>$i$行中拿出$j$个物品的最大价值。则我们可得状态转移方程<script type="math/tex">f[i][j] = max(f[i][j] , f[i - 1][j - k] + dp[i][k])</script></p><p>其中，$i , j , k$需要进行枚举，时间复杂度为$O(n^3)$，足以通过本题。</p><p>如果还有什么的话，那就是</p><p><strong>转移时请按照顺序转移，不要随意改变转移顺序</strong><del>(来自考场上随便改变转移顺序而只得了10分的作者)</del></p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , num[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][N];   <span class="comment">//dp[i][j] 从第i行物品中拿出j个的最大价值</span></span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">10001</span>];    <span class="comment">//f[i][j] 从前i行拿出j个物品的最大价值和</span></span><br><span class="line"><span class="keyword">int</span> sum[N][N];   <span class="comment">//sum[i][j] 第i行前j个物品的价值之和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp[i][j] = max_element(sum[i][k] + sum[i][n] - sum[i][n - (j - k)])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//f[i][j] = max(f[i][j] , f[i - 1][j - k] + dp[i][k])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;./porcelain1.in&quot; , &quot;r&quot; , stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;n , &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;num[i]);      </span><br><span class="line">        sum[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num[i]; j ++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;a[i][j]);</span><br><span class="line">            sum[i][j] = a[i][j] + sum[i][j - <span class="number">1</span>];    <span class="comment">//计算前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num[i]; j ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k ++)&#123;   <span class="comment">//进行第一遍dp，处理单排情况</span></span><br><span class="line">                dp[i][j] = max(dp[i][j] , sum[i][k] + sum[i][num[i]] - sum[i][num[i] - j + k]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;  i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(j , num[i]); k ++)&#123;     <span class="comment">//进行第二遍dp，处理多排情况。</span></span><br><span class="line">                f[i][j] = max(f[i][j] , f[i - <span class="number">1</span>][j - k] + dp[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , f[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JZOI】无聊的草稿-题解</title>
      <link href="2019/10/28/GmojP1752/"/>
      <url>2019/10/28/GmojP1752/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>图中有$n$个点，每两点间只有唯一的路径，对于这样一个给定的图，最大的“毛毛虫”会有多大。</p><p>毛毛虫包含一条主链，毛毛虫中的节点，要不在主链上，要么和主链上某节点相邻，如下图所示有两只合法的毛毛虫，点数越多，毛毛虫越大。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/28/uCibUqTgBWovehf.png" alt="合法的毛毛虫.png"></p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件第一行两个整数$n$，$m$。<br>　　<br>接下来M行，每行两个整数$a, b$，表示从$a$到$b$有一条边相连</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数$ans$,表示最大的毛毛虫的大小。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">4 1</span><br><span class="line">5 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$20\%$的数据，$n≤200$</p><p>对于$40\%$的数据，$n≤5 \times 10^3$</p><p>对于$100\%$的数据，$n≤10^6$</p><p>保证两点之间只有一条路径。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>第一眼看到这题我以为是个神仙$DP$，结果发现是个zz题目</del></p><p>咳咳，首先由两点之间只有一条路经可以看出，题目给出的是一棵树。</p><p>而题目要求我们求一条最长的”毛毛虫”，实质上就是求出一条树上最长链。</p><p>但在这题中，每个点对答案的贡献不是$1$，而是与其相连的点的个数。</p><p>因此，我们需要先进行一遍$dfs$，搜索出这棵树的根节点（即点权最大的节点），之后以根节点为起点寻找树上最长链。</p><p>两遍$dfs$即可。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;edge[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;to , head[from]&#125;;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="keyword">int</span> ans , root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> d , <span class="keyword">bool</span> flag)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i ; i = edge[i].last)&#123; <span class="comment">//枚举每一条出边</span></span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[to])&#123;      </span><br><span class="line">            vis[to] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">true</span>)&#123;   </span><br><span class="line">                search(to , d + dis[to] , <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//如果不是起始点，则从上一个点到达这个点的路径会被计算两次。因此要-1</span></span><br><span class="line">                search(to , d + dis[to] - <span class="number">1</span> , <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d &gt; ans)&#123;    <span class="comment">//若当前节点的权值大于根节点，则更新根节点。</span></span><br><span class="line">        ans = d;</span><br><span class="line">        root = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u , v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;n , &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;u , &amp;v);</span><br><span class="line">        add_edge(u , v);</span><br><span class="line">        add_edge(v , u);</span><br><span class="line">        dis[u] ++  , dis[v] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    search(<span class="number">1</span> , <span class="number">1</span> , <span class="literal">true</span>);   <span class="comment">//第一遍dfs寻找根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    search(root , <span class="number">1</span> , <span class="literal">true</span>);    <span class="comment">//第二遍dfs寻找树上最长链</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JZOI】Span-题解</title>
      <link href="2019/10/28/GmojP1751/"/>
      <url>2019/10/28/GmojP1751/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>某国有$n$个村子，$m$条道路。</p><p>为了实现“村村通工程”现在要”油漆”$n-1$条道路（因为某些人总是说该国所有的项目全是从国外进口来的，只是漆上本国的油漆罢了）。</p><p>因为“和谐”是此国最大的目标和追求，以致于对于最小造价什么的都不在乎了，只希望你所选出来的最长边与最短边的差越小越好。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行给出一个数字$t$，代表有多少组数据。</p><p>对于每组数据，首先给出$n$ , $m$</p><p>下面M行，每行三个数$a,b,c$代表$a$村与$b$的村道路距离为$c$.</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，为最小差值,如果无解输出<code>-1</code>.</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4 5</span><br><span class="line">1 2 3</span><br><span class="line">1 3 5</span><br><span class="line">1 4 6</span><br><span class="line">2 4 6</span><br><span class="line">3 4 7</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$100\%$的数据$2 ≤ n ≤ 100$,$0 ≤ m ≤ \frac{n \times (n − 1)}{2}$</p><p>每条边的权值小于等于$10^4$</p><p>保证没有自环与重边</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>真的是签到题了……</p><p>首先，题目中告诉我们要在$n$个点中选出$n-1$条边，自然而然的能想到最小生成树。</p><p>再看这个极小的数据范围，自然是怎么暴力怎么来。</p><p>我们把所有边加进图中，排一遍序，之后枚举长度最小的边，将比它小的边都忽略跑最小生成树即可。</p><p>时间复杂度为$O(m^2)$，由于本题数据范围较小，足以通过。</p><p>听说如果数据大的话可以使用$LCT$维护，<del>但我不会</del>。</p><p>剩下的见代码。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t , n , m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    ll dis;</span><br><span class="line">&#125;edge[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , ll dis)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;from , to , head[from] , dis&#125;;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[root] == root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre[root] = find(pre[root]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a , Edge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dis &lt; b.dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll maxn = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">    &#125;    </span><br><span class="line">    ll num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//    sort(edge + 1 , edge + 1 + m , cmp);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = find(edge[i].from) , r = find(edge[i].to);</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre[l] = r;</span><br><span class="line">        maxn = max(maxn , edge[i].dis);</span><br><span class="line">        num ++;</span><br><span class="line">        <span class="keyword">if</span>(num == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u , v , d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;n , &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span> , &amp;u , &amp;v , &amp;d);</span><br><span class="line">            add_edge(u , v , d);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(edge + <span class="number">1</span> , edge + <span class="number">1</span> + m , cmp);</span><br><span class="line">        ll ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Kruskal(i))&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans &gt; maxn - edge[i].dis)&#123;</span><br><span class="line">                    ans = maxn - edge[i].dis;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , (ans == <span class="number">0x3f3f3f3f</span> ? <span class="number">-1</span> : ans) ) ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">            head[i] = edge[i].from = edge[i].to = edge[i].dis = edge[i].last = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        edge_num = <span class="number">0</span>;</span><br><span class="line">        maxn = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces】Shop-题解</title>
      <link href="2019/10/27/CF521D/"/>
      <url>2019/10/27/CF521D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>有$n$个数，$m$个操作。形如：</p><ol><li>将$x$改为$val$</li><li>将$x$加上$val$</li><li>将$x$乘以$val$</li></ol><p>其中第$i$个操作的编号为$i$. 现在你可以从中选择最多$k$个操作(不能重复选),并按一定顺序执行，使得$\prod_{i = 1}^n x_i$最大。</p><p>请输出最后的最大值以及你选择的操作。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含$3$个整数，$n$ , $m$ , $k$</p><p>第二行包含$n$个整数，表示初始序列。</p><p>之后$m$行每行三个整数$opt_i , x_i , val_i$。分别表示操作类型，要修改的数的下标，修改后的数。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共两行，第一行包含一个整数，表示最大值。</p><p>第二行包含$k$个整数，按顺序输出您选择的操作。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2 4 3</span><br><span class="line">13 20</span><br><span class="line">1 1 14</span><br><span class="line">1 2 30</span><br><span class="line">2 1 6</span><br><span class="line">3 2 2</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 3 4</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$100\%$的数据，保证 $1 &lt; k &lt; 10^{5}$, $0&lt; m &lt; n &lt; 10^{5}$。</p><p>其他的数字均保证在$int$范围内。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道有点毒瘤的贪心题。</p><p>先考虑如果只有操作$3$该怎么做。很显然，若只有$3$操作的话我们直接排个序即可。</p><p>既然这样，我们就把前两种操作转换为操作$3$。</p><p>对于操作$1$，我们很容易发现对于一个位置$i$，我们最多只会使用一次操作$1$，而且一定是把它改成一个比它大的数。</p><p>因此我们可以把这次赋值操作看做一次加法操作。即将操作$1$改成操作$2$。</p><p>再来思考如何把操作$2$转变为操作$3$。</p><p>不难得出，对于一个数一定是要先加在乘的。而且一定先从大的开始使用。</p><p>所以说，每个数进行加法操作的顺序是固定的。把这些加法操作排序后都可以看做乘法操作（$a + b = a \times \frac{a + b}{a}$）</p><p>现在我们只剩下操作$3$了。排个序输出就可以啦。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span>&#123;</span><span class="comment">//opt为操作类型，id为操作编号，a为被修改数的下标，b为被修改后的分子，c为分母</span></span><br><span class="line">    ll opt , id , a , b , c;    </span><br><span class="line">&#125;node1[N] , node2[N] , node3[N] , ans[N];</span><br><span class="line"></span><br><span class="line">ll num1 , num2 , num3;  <span class="comment">//记录三种操作的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(Change A , Change B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (A.a != B.a) ? A.a &lt; B.a : A.b &lt; B.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Change A , Change B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (A.a != B.a) ? A.a &lt; B.a : A.b &gt; B.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">bool</span> <span class="title">cmp3</span><span class="params">(Change A , Change B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.b * B.c &gt; A.c * B.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">bool</span> <span class="title">cmp4</span><span class="params">(Change A , Change B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.opt &lt; B.opt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n , m , s;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x , y , z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; z &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(z == <span class="number">1</span> &amp;&amp; y &gt; a[x])&#123;     <span class="comment">//如果将一个数改成比他小的数，还不如不改。</span></span><br><span class="line">            node1[++ num1] = (Change)&#123;<span class="number">1</span> , i , x , y , <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z == <span class="number">2</span>)&#123;</span><br><span class="line">            node2[++ num2] = (Change)&#123;<span class="number">2</span> , i , x , y , <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z == <span class="number">3</span>)&#123;</span><br><span class="line">            node3[++ num3] = (Change)&#123;<span class="number">3</span> , i , x , y , <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    sort(node1 + <span class="number">1</span> , node1 + <span class="number">1</span> + num1 , cmp1);  <span class="comment">//将操作1排一遍序</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num1; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node1[i].a != node1[i + <span class="number">1</span>].a)&#123;   <span class="comment">//对于每一个位置选出最大的数</span></span><br><span class="line">            node1[++ tmp] = node1[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num1 = tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num1; i ++)&#123;    <span class="comment">//将操作1改为操作2</span></span><br><span class="line">        node2[++ num2].opt = node1[i].opt;</span><br><span class="line">        node2[num2].id = node1[i].id;</span><br><span class="line">        node2[num2].a = node1[i].a;</span><br><span class="line">        node2[num2].b = node1[i].b - a[node1[i].a];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node2 + <span class="number">1</span> , node2 + <span class="number">1</span> + num2 , cmp2);  </span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num2; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node2[i].a != node2[i - <span class="number">1</span>].a)&#123;</span><br><span class="line">            sum = a[node2[i].a];</span><br><span class="line">        &#125;</span><br><span class="line">        node2[i].c = sum, sum += node2[i].b;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num3; i ++)&#123;</span><br><span class="line">        node3[i].b -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num2; i ++)&#123;</span><br><span class="line">        node3[++ num3] = node2[i];  <span class="comment">//将操作2改成操作3</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(node3 + <span class="number">1</span> , node3 + <span class="number">1</span> + num3 , cmp3);  </span><br><span class="line">    ll number = min(num3 , s);  <span class="comment">//如果可以用的操作数大于总操作数，就都用上。</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= number; i ++)&#123;</span><br><span class="line">        ans[++ cnt] = node3[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    sort(ans + <span class="number">1</span> , ans + <span class="number">1</span> + cnt , cmp4);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i].id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷题库】跑路-题解</title>
      <link href="2019/10/27/luoguP1613/"/>
      <url>2019/10/27/luoguP1613/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>小$A$的工作不仅繁琐，更有苛刻的规定，要求小$A$每天早上在$6：00$之前到达公司，否则这个月工资清零。</p><p>可是小$A$偏偏又有赖床的坏毛病。</p><p>于是为了保住自己的工资，小$A$买了一个十分牛$B$的空间跑路器，每秒钟可以跑$2^k$千米（$k$是任意自然数）。</p><p>当然，这个机器是用$long int$存的，所以总跑路长度不能超过$max(long int)$(即$2146483647$)千米。</p><p>小$A$的家到公司的路可以看做一个有向图，小$A$家为点$1$，公司为点$n$，每条边长度均为$1000m$。</p><p>小$A$想每天能醒地尽量晚，所以让你帮他算算，他最少需要几秒才能到公司。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数$n，m$，表示点的个数和边的个数。</p><p>接下来$m$行每行两个数字$u，v$，表示一条$u$到$v$的边。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个数字，表示到公司的最少秒数。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$50\%$的数据，满足最优解路径长度$&lt; 1000$；</p><p>对于$100\%$的数据满足$0&lt; n&lt; 50$，$0&lt; m &lt; 10000$，最优解路径长度$&lt; 2147483647$。</p><p>保证一定存在一条从$1$到$n$的路径。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道倍增版子题。</p><p>看到题面中$2^k$，我们不难想到需要倍增求解。</p><p>题目中告诉我们任何$2^k$的路径都可以使用跑路器一次性走完，则我们设$map[i][j][k]$表示是否存在一条从$i$到$j$长度为$2^k$的路径。</p><p>根据倍增的定义，我们可知，若$map[i][mid][k - 1]$与$map[mid][j][k - 1]$均为$true$，则$map[i][j][k]$为$true$。</p><p>因此，我们可以直接使用$Floyd$来判断两点直接是否可以使用跑路器到达。</p><p>最后再跑一边$Floyd$，更新一下最短路长度即可。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> u , v;</span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">map</span>[N][N][N];</span><br><span class="line"></span><br><span class="line">ll dis[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>[u][v][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dis[u][v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">                dis[i][j] = min(dis[i][j] , dis[i][k] + dis[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;   <span class="comment">//初始化dis数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">            dis[i][j] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        add_edge(u , v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= <span class="number">64</span>; c ++)&#123;  <span class="comment">//枚举倍增指数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)&#123;   <span class="comment">//利用Floyd思想判断两点之间是否可以到达</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">map</span>[i][k][c - <span class="number">1</span>] &amp;&amp; <span class="built_in">map</span>[k][j][c - <span class="number">1</span>])&#123;</span><br><span class="line">                        <span class="built_in">map</span>[i][j][c] = <span class="literal">true</span>;</span><br><span class="line">                        dis[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Floyd();    <span class="comment">//最后更新一遍最短路。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dis[<span class="number">1</span>][n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 倍增 </tag>
            
            <tag> Floyd </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JZOI】天黑黑-题解</title>
      <link href="2019/10/26/GmojP3814/"/>
      <url>2019/10/26/GmojP3814/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">我走在每天必须面对的分岔路</span><br><span class="line">我怀念过去单纯美好的小幸福</span><br><span class="line">爱总是让人哭</span><br><span class="line">让人觉得不满足</span><br><span class="line">天空很大却看不清楚</span><br><span class="line">好孤独</span><br><span class="line">天黑的时候</span><br><span class="line">我又想起那首歌</span><br><span class="line">突然期待下起安静的雨</span><br><span class="line">原来外婆的道理早就唱给我听</span><br><span class="line">下起雨</span><br><span class="line">也要勇敢前行</span><br><span class="line">我相信</span><br><span class="line">一切都会平息</span><br><span class="line">我现在好想回家去</span><br><span class="line">天黑黑</span><br><span class="line">欲落雨</span><br><span class="line">天黑黑</span><br><span class="line">黑黑</span><br></pre></td></tr></table></figure><p>当整个世界陷入黑暗的时候，身为光明之神的Zyh想要用自己的若干个能量源和若干个集流器将这些能量源并成一个最大的能量源，这样他就可以造出最大的灯来照亮整个世界。</p><p>具体地来说每个能量源可以直接给出$e_i$的能量。</p><p>而每个集流器是由两个接受端口和一个输出端口组成的。集流器有两种：$A$类和$B$类。</p><p>其中，$A$类是叠加集流器，可以将两个接收端口的能量叠加并输出。$B$类是取代集流器，可以将两个接受端口的能量较大那个输出。</p><p>现在有$n-1$个集流器，$n$个能量源。Zyh给出了集流器的连接方式。</p><p>他想知道怎样放置能量源，能够使最后的输出最大化。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个字符串，表示连接的方式。</p><p>给出的形式如下：$X$表示一个单独的输出能量源的放置处；$A,S_1,S_2$，其中$S_1$和$S_2$表示两个输出能量.</p><p>$A$表示使用叠加集流器将能量并成一个，然后这本身也成为一个新的输出能源；</p><p>$B$也是同理，只不过是使用取代集流器。并且保证$A$和$B$的个数为$n-1$个。$X$的个数为$n$个。</p><p>第二行是$n$个正整数，表示这几个能量源可以提供的能量大小。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一个数，表示最大的输出能源。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">BXBXX</span><br><span class="line">8 2 3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">AXBXX</span><br><span class="line">8 2 3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$20\%$的数据，保证$0&lt;n&lt;10$</p><p>对于$60\%$的数据，保证$0&lt;n&lt;3 \times 10^3$</p><p>对于$100\%$的数据，保证$0&lt; n &lt;2\times 10^5$ $0 &lt; e_i&lt; 10^4$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道巧妙的贪心题。</p><p>手绘一下两个样例，不难发现，$A$型集流器对于能量没有损失，而$B$型集流器会损失掉较小的能量。</p><p>因此，我们可以考虑每一次都损失掉能量值最小的能量球。</p><p>之后呐？</p><p>或许您会将$B$型能量球的数量记为$b$，然后将损失掉前$b$个能量球？</p><p><del>然后您就成功的得到了60分</del></p><p>为什么这样是错的呐？我们考虑举反例。</p><p>若在一个$B$型集流器后接上两个$A$型集流器，就像下图</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/26/8F7tdC2U5KNsvnc.png" alt="反例.png"></p><p>则我们失去的不是一个能量球，而是两个。</p><p>对于这个反例，我们直接在输入时使用栈模拟处理即可。</p><p>具体实现方法和剩下的细节见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n , m , a[N];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">ll x;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span> &gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ll a , ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">            x ++;       <span class="comment">//统计能量球的数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span> , &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span> , a + <span class="number">1</span> + x , cmp);  <span class="comment">//对能量球进行降序排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;  <span class="comment">//倒序扫描，便于模拟</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;X&#x27;</span>)&#123;    <span class="comment">//如果当前位置可以放能量球，则放入</span></span><br><span class="line">            S.push(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;A&#x27;</span>)&#123;   <span class="comment">//如果是A型集流器，则将后边的两个位置加起来</span></span><br><span class="line">            <span class="keyword">int</span> top1 = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            <span class="keyword">int</span> top2 = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            S.push(top1 + top2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;       <span class="comment">//如果是B型，则删掉较小的那一个。</span></span><br><span class="line">            <span class="keyword">int</span> top1 = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            <span class="keyword">int</span> top2 = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            <span class="keyword">if</span>(top1 &gt; top2)&#123;</span><br><span class="line">                S.push(top1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                S.push(top2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       <span class="comment">//最后的栈顶则是可以取到的能量球数。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S.top(); i ++)&#123;</span><br><span class="line">        ans += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span> , ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JZOI】Tiny Counting-题解</title>
      <link href="2019/10/25/GmojP6342/"/>
      <url>2019/10/25/GmojP6342/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>给定序列$S$，求出所有四元组$(a,b,c,d)$，满足$a &lt; b$，$c &lt; d$且$S_a &lt; S_b$ ，$S_c &gt; S_d$<br>​<br>要求$a , b , c , d$互不相等。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$n$，表示数组长度。</p><p>第二行$n$个整数，分别为$S_1 , S_2 , S_3……S_n$,表示$S$数组。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，包含一个整数，表示最终的答案。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 4 3 2</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><hr><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>合法的$(a , b , c , d)$如下：</p><p>$(a , b , c , d) ∈ \lbrace (1 , 2 , 3 , 4) , (1 , 3 , 2 , 4) , (1 , 4 , 2 , 3) \rbrace$</p><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$20\%$的数据，保证$n &lt; 200$</p><p>对于$50\%$的数据，保证$n &lt; 1000$</p><p>对于另外$20\%$的数据，保证 $0 ≤ S_i ≤ 1$</p><p>对于$100\%$的数据，保证$n &lt; 10^5 , 0 &lt; S_i &lt; 10^9$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道比较基础的组合计数题。</p><p>若题目中没有$a , b , c , d$互不相等，则答案就是逆序对与顺序对的乘积，直接树状数组解决即可。</p><p>考虑如何解决上面的限制。</p><p>不难发现，不合法的四元组只有四种情况，即$a = c$ , $a = d$ , $b = c$ , $b = d$。且不会出现三个元素相等。</p><p>则我们设$(i , S_i)$为每个点的坐标。若$a = c$，我们就只需要求出其右上方的点数乘以右下方的点数即可</p><p>剩下三种情况请各位读者自行画图推理。</p><p>最后，统计答案直接离散化后套树状数组。</p><p>剩下的见代码</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tree_array&#123;</span><br><span class="line">    ll tree[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">lowbit</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (- x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">I <span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x , ll k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i = x; i &lt;= n; i += lowbit(i))&#123;</span><br><span class="line">            tree[i] += k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">I ll <span class="title">query</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i = x; i ; i -= lowbit(i))&#123;</span><br><span class="line">            ans += tree[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">I <span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            tree[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Tree_array;</span><br><span class="line"></span><br><span class="line">ll a[N] , b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + <span class="number">1</span> , b + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> number = unique(b + <span class="number">1</span> , b + <span class="number">1</span> + n) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        a[i] = lower_bound(b + <span class="number">1</span> , b + <span class="number">1</span> + number , a[i]) - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ls[N] , rs[N] , lb[N] , rb[N];</span><br><span class="line">ll ans , p , q; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;a.in&quot;</span> , <span class="string">&quot;r&quot;</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;a.out&quot;</span> , <span class="string">&quot;w&quot;</span> , <span class="built_in">stdout</span>);</span><br><span class="line">    input();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i --)&#123;</span><br><span class="line">        rs[i] = query(a[i] - <span class="number">1</span>);</span><br><span class="line">        p += rs[i];</span><br><span class="line">        rb[i] = query(n) - query(a[i]);</span><br><span class="line">        add(a[i] , <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        ls[i] = query(a[i] - <span class="number">1</span>);</span><br><span class="line">        q += ls[i];</span><br><span class="line">        lb[i] = query(n) - query(a[i]);</span><br><span class="line">        add(a[i] , <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    ans = p * q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        ans -= rb[i] * rs[i] + rb[i] * lb[i] + rs[i] * ls[i] + lb[i] * ls[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vijos &amp; JZOI】超级教主-题解</title>
      <link href="2019/10/24/vijosP1617/"/>
      <url>2019/10/24/vijosP1617/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>LHX教主很能跳，因为Orz他的人太多了。</p><p>教主跳需要消耗能量，每跳$1$米就会消耗$1$点能量，如果教主有很多能量就能跳很高。</p><p>教主为了收集能量，来到了一个神秘的地方，这个地方凡人是进不来的。</p><p>在这里，教主的正上方每$100$米处就有一个能量球（也就是这些能量球位于海拔$100，200，300$……米处。</p><p>每个能量球所能提供的能量是不同的，一共有$N$个能量球（也就是最后一个能量球在$N×100$米处）。</p><p>教主为了想收集能量，想跳着吃完所有的能量球。</p><p>教主可以自由控制他每次跳的高度，接着他跳起把这个高度以下的能量球都吃了，他便能获得能量球内的能量，接着吃到的能量球消失。</p><p>教主不会轻功或二段跳，所以教主不能因新吃到的能量而变化此次跳跃的高度。</p><p>并且教主还是生活在地球上的，所以教主每次跳完都会掉下来。</p><p>问教主若要吃完所有的能量球，最多还能保留多少能量。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第1行包含两个<strong>正整数</strong>$N$，$M$，表示了能量球的个数和LHX教主的初始能量。</p><p>第2行包含$N$个<strong>非负整数</strong>，从左到右第$i$个数字依次从下向上描述了位于$i×100$米位置能量球包含的能量，每两个整数之间用一个空格隔开。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅包括一个<strong>非负整数</strong>，为教主吃完所有能量球后最多保留的能量。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 200</span><br><span class="line">200 200 200</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">400</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$10\%$的数据，有$N≤10$；</p><p>对于$20\%$的数据，有$N≤100$；</p><p>对于$40\%$的数据，有$N≤10^3$；</p><p>对于$70\%$的数据，有$N≤10^5$；</p><p>对于$100\%$的数据，有$N≤2 \times 10^6$。</p><p>保证对于所有数据，教主都能吃到所有的能量球，并且能量球包含的能量之和不超过$2^31-1$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道简单DP。<del>但我考场没过</del></p><p>认真读题，不难看出题目中让我们最大化最后剩下的能量之和。也就是最大化<code>得到的能量 - 失去的能量</code>。</p><p>而得到的能量之和是固定的。因此，我们只能尽量少失去能量。</p><p>失去能量多少的决定于两点：跳跃次数与跳跃高度。相比之下，跳跃次数的影响更大。</p><p>也就是说，我们要尽量的少跳，即在能量够用的情况下尽量吃到更多的能量球。</p><p>考虑$dp$，设$f[i]$为吃到第$i$个能量球后能保留的最大能量，则最终状态为$f[n]$</p><p>转移时，枚举上一次到达的能量球是第几个，设其为$p$，可得</p><script type="math/tex; mode=display">f[i] = max(f[i] , f[p] + b[i] - b[p] - i * 100)</script><p>其中，$b$为前缀和数组，用于表示从$1$跳到$n$可以得到的能量数。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N] , a[N] , b[N];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;   <span class="comment">//处理前缀和</span></span><br><span class="line">        b[i] = b[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = m;   <span class="comment">//若不跳，则最大能量即为初始能量。</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;    <span class="comment">//记录当前跳到的能量球，相当于题解中的p</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(f[cnt] &lt; i * <span class="number">100</span>)&#123; </span><br><span class="line">            cnt ++; <span class="comment">//如果获得的能量不足以向上跳到第i个能量球，就考虑多得到一个能量球后在向上跳</span></span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = f[cnt] + b[i] - b[cnt] - i * <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> Vijos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vijos &amp; JZOI】迎接仪式-题解</title>
      <link href="2019/10/24/vijosP1616/"/>
      <url>2019/10/24/vijosP1616/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>LHX教主要来X市指导OI学习工作了。</p><p>为了迎接教主，在一条道路旁，一群Orz教主er穿着文化衫站在道路两旁迎接教主，每件文化衫上都印着大字。</p><p>一旁的Orzer依次摆出“欢迎欢迎欢迎欢迎……”的大字，但是领队突然发现，另一旁穿着“教”和“主”字文化衫的Orzer却不太和谐。</p><p>为了简单描述这个不和谐的队列，我们用“$j$”替代“教”，“$z$”替代“主”。而一个”$j$”与“$z$”组成的序列则可以描述当前的队列。</p><p>为了让教主看得尽量舒服，你必须调整队列，使得“$jz$”子串尽量多。</p><p>每次调整你可以交换任意位置上的两个人，也就是序列中任意位置上的两个字母。</p><p>而因为教主马上就来了，时间仅够最多作$k$次调整（当然可以调整不满$k$次），所以这个问题交给了你。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含$2$个正整数$n$与$k$，表示了序列长度与最多交换次数。</p><p>第二行包含了一个长度为$n$的字符串，字符串仅由字母“$j$”与字母“$z$”组成，描述了这个序列。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个非负整数，为调整最多$k$次后最后最多能出现多少个“$jz$”子串。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 2 </span><br><span class="line">zzzjj</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><hr><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>第$1$次交换位置$1$上的$z$和位置$4$上的$j$，变为$jzzzj$；</p><p>第$2$次交换位置$4$上的$z$和位置$5$上的$j$，变为$jzzjz$。</p><p>最后的串有$2$个“$jz$”子串。</p><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$10\%$的数据，有$N≤10$；</p><p>对于$30\%$的数据，有$K≤10$；</p><p>对于$40\%$的数据，有$N≤50$；</p><p>对于$100\%$的数据，有$N≤500,K≤100$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道<del>暴力</del>动态规划题。</p><p>不难注意到，题目的数据范围极小。因此，我们可以直接<del>大力</del>设计状态</p><p>设$f[k][i][j]$表示考虑前$k$个人，通过交换$i$次<code>j</code>，$j$次<code>z</code>的<code>jz</code>数。</p><p>然后<del>大力</del>分类讨论，考虑第$k$个人时<code>j</code>还是<code>z</code>。</p><p>若第$k - 1$个人为<code>j</code>，第$k$个人为<code>z</code>，则$f[k][i][j]$可以直接用$f[k - 2][i][j]$更新。答案为<script type="math/tex">f[k - 2][i][j] + 1</script></p><p>若第$k - 1$个人为<code>z</code>，第$k$个人为<code>j</code>，则$f[k][i][j]$相当于在$f[k - 2][i][j]$的基础上交换两个字符的位置。答案为<script type="math/tex">f[k - 2][i + 1][j + 1] + 1</script></p><p>若第$k - 1$个人为<code>z</code>，第$k$个人为<code>z</code>，则$f[k][i][j]$相当于在$f[k - 2][i][j]$的基础上将一个<code>z</code>换为<code>j</code>。则答案为<script type="math/tex">f[k - 2][i][j + 1] + 1</script></p><p>若第$k - 1$个人为<code>j</code>，第$k$个人为<code>j</code>，则$f[k][i][j]$相当于在$f[k - 2][i][j]$的基础上将一个<code>j</code>换为<code>z</code>。则答案为<script type="math/tex">f[k - 2][i + 1][j] + 1</script></p><p>大力转移即可。</p><p>还有就是，最后答案应为$max<em>{k = 1}^n \lbrace f</em>{k , i , j} , i = j \rbrace$。因为只有当交换次数一致时，答案才是符合题意的。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 501</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll f[N][<span class="number">150</span>][<span class="number">150</span>];<span class="comment">//f[k][i][j]为前i个字符，交换了i次j，j次z。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ll ans = <span class="number">-0x3f3f3f3f</span>;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span> , s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= m; k ++)&#123;</span><br><span class="line">                f[i][j][k] = <span class="number">-0x3f3f3f3f</span>;   <span class="comment">//开始时赋初值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span>)&#123;    <span class="comment">//同上</span></span><br><span class="line">        f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= n; k ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">                f[k][i][j] = f[k - <span class="number">1</span>][i][j];    <span class="comment">//分情况讨论，转移</span></span><br><span class="line">                <span class="keyword">if</span>(s[k - <span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; s[k] == <span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">                    f[k][i][j] = max(f[k][i][j] , f[k - <span class="number">2</span>][i][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[k - <span class="number">1</span>] == <span class="string">&#x27;z&#x27;</span> &amp;&amp; s[k] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; i &amp;&amp; j)&#123;</span><br><span class="line">                    f[k][i][j] = max(f[k][i][j] , f[k - <span class="number">2</span>][i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[k - <span class="number">1</span>] == <span class="string">&#x27;z&#x27;</span> &amp;&amp; s[k] == <span class="string">&#x27;z&#x27;</span> &amp;&amp; j)&#123;</span><br><span class="line">                    f[k][i][j] = max(f[k][i][j] , f[k - <span class="number">2</span>][i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[k - <span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; s[k] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; i)&#123;</span><br><span class="line">                    f[k][i][j] = max(f[k][i][j] , f[k - <span class="number">2</span>][i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == j)&#123;     </span><br><span class="line">                    ans = max(ans , f[k][i][j]);    <span class="comment">//统计合法答案。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> 分类讨论 </tag>
            
            <tag> Luogu </tag>
            
            <tag> Vijos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vijos &amp; JZOI】旅行-题解</title>
      <link href="2019/10/24/vijosP1615/"/>
      <url>2019/10/24/vijosP1615/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>今天是个神圣的日子，因为LHX教主要进行一段长途旅行。</p><p>但是教主毕竟是教主，他喜欢走自己的路，让别人目瞪口呆。</p><p>为什么呢，因为这条路线高低不平，而且是相当的严重。</p><p>但是教主有自己的办法，他会魔法。</p><p>这段路可以用一个长度为$N$的序列$a_i$来表示，$a_i$表示了第$i$这段路的高度。</p><p>教主即使会使用魔法他还是个人，教主如果想穿越这条路线，他必须从第$1$段路开始走，走到第$N$段，从第$i$段走到第$i+1$段路需要消耗$|a_{i + 1} - a_i|$点体力。</p><p>为了节省体力，教主使出了他神奇的魔法。</p><p>教主的魔法可以将一段路高度变高或者变低，但是使用魔法也需要体力，改变一段路$H$的高度就需要消耗$H$的体力。</p><p>接着，LHX教主想规划下如何调整路段高度后穿越，使得总体力消耗最小。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第1行为一个<strong>正整数</strong>$N$，表示了这条路线的长度。</p><p>第2行有$N$个<strong>正整数</strong>，相邻两个正整数用空格隔开，描述了$a_i$这个序列。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅包括一个<strong>非负整数</strong>，为最小的总体力消耗。</p><p>注意：答案可能超过$2^31-1$。因此，请使用<code>int64</code>或者<code>long long</code>类型保存答案。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3 4 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$10\%$的数据，有$N≤10$；</p><p>对于$30\%$的数据，有$a_i≤10^3$；</p><p>对于$40\%$的数据，有$N≤10^3$；</p><p>对于$100\%$的数据，有$N≤10^5，a_i≤10^7$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>考场上唯一A掉的签到题</del></p><p>先说解法：若中间的数高于或低于两边(即出现下图状况时)，则将中间的数变成两边的数中较近的那个。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/24/TZFeghzUfYE9buB.png" alt="解法图示.png"></p><p>证明如下：</p><p>设连续的三个数高度为$l , mid , r$。</p><p>若$l &lt; mid &gt; r$，即出现上图左侧的情况时，若我们直接走，消耗的体力为$|mid - l| + |r - mid|$(即下图蓝色部分)</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/24/xZL5aR7PcJrUHKW.png" alt="P1.png"></p><p>这时，若我们把$mid$降至与$min(l , r)$（此时为$r$）一样高时，则我们消耗的体力为$|r - l| + |mid - r|$，省去了一段$mid - r$。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/24/AVDYmX4BqFRK1Gs.png" alt="P2.png"></p><p>因此，这样做是更优的。</p><p>降至较近的那个是因为，若降到较远的那个，下降时消耗的体力值与走过的距离均会更大。</p><p>至于图示中右图的情况，请各位读者结合上面的讲解自行证明。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n , a[N];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i - <span class="number">1</span>] &lt; a[i] &amp;&amp; a[i] &gt; a[i + <span class="number">1</span>])&#123;     <span class="comment">//若中间比两边高</span></span><br><span class="line">            ll maxn = max(a[i - <span class="number">1</span>] , a[i + <span class="number">1</span>]);</span><br><span class="line">            ans += <span class="built_in">abs</span>(maxn - a[i]);</span><br><span class="line">            a[i] = maxn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[i - <span class="number">1</span>] &amp;&amp; a[i + <span class="number">1</span>] &gt; a[i])&#123;     <span class="comment">//若中间比两边低</span></span><br><span class="line">            ll minn = min(a[i - <span class="number">1</span>] , a[i + <span class="number">1</span>]);</span><br><span class="line">            ans += <span class="built_in">abs</span>(minn - a[i]);</span><br><span class="line">            a[i] = minn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;       <span class="comment">//统计答案</span></span><br><span class="line">        ans += <span class="built_in">abs</span>(a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 纪中集训 </tag>
            
            <tag> Vijos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces】Nick and Array-题解</title>
      <link href="2019/10/21/CF1180B/"/>
      <url>2019/10/21/CF1180B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>你有一个长度为$n$的数组$a$。</p><p>你可以进行任意次操作，每一次可以选择一个数$a_i$，并让$a_i$变成$-a_i-1$。</p><p>你的目标是使得这个数组每一个元素的乘积最大，请求出这个最大的价值，并输出这个最大价值的序列。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数$n$，表示数组的长度。</p><p>第二行包含$n$个整数，分别为$a_1…… a_n$，表示数组中的元素。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，包含$n$个整数，表示这个最大的价值序列。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2 2 2 2</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">-3 -3 -3 -3 </span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-3"><a href="#Input-‘s-eg-3" class="headerlink" title="Input ‘s eg 3"></a>Input ‘s eg 3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">-3 -3 2</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-3"><a href="#Output-‘s-eg-3" class="headerlink" title="Output ‘s eg 3"></a>Output ‘s eg 3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">-3 -3 2</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$100\%$的数据，保证$1 &lt; n &lt; 10^5$，$-10^6 &lt; a_i &lt; 10^6$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道简单贪心题。</p><p>手推几组样例后不难看出，一个数如果操作两次之后等于没操作。则题目就变成了对于每一个$a_i$，让你选择是否进行操作，使得乘积最大。</p><p>可以注意到，若$a_i$是一个正数，则$|- a_i - 1|$一定大于$n$。</p><p>又根据初中数学可得，偶数个负数的乘积一定是正数。</p><p>因此，对于$n$是偶数的情况我们直接全部变成负数即可。</p><p>而对于$n$为奇数的情况，不难看出，奇数减$1$一定是偶数。因此，我们只需要选择一个数不进行操作即可。</p><p>显然，我们要选择的是绝对值最大的数。</p><p>时间复杂度为$O(n)$，跑过$10^5$的数据绰绰有余。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n , a[N];</span><br><span class="line">ll maxn = <span class="number">0</span>;</span><br><span class="line">ll p = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt;= <span class="number">0</span>)&#123;          <span class="comment">//输入时将所有的数都变成负数</span></span><br><span class="line">            a[i] = -a[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxn = min(maxn , a[i]);</span><br><span class="line">        <span class="keyword">if</span>(maxn == a[i])&#123;       <span class="comment">//记录绝对值最大的数的位置</span></span><br><span class="line">            p = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;     <span class="comment">//如果n为偶数，直接输出序列即可。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;   <span class="comment">//否则的话，修改绝对值最大的数。</span></span><br><span class="line">            <span class="keyword">if</span>(p == i)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; -a[i] - <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOIP2010】乌龟棋-题解</title>
      <link href="2019/10/21/luoguP1541/"/>
      <url>2019/10/21/luoguP1541/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。</p><hr><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>乌龟棋的棋盘是一行$N$个格子，每个格子上有一个分数。</p><p>棋盘第$1$格是唯一的起点，第$N$格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。</p><p>乌龟棋中$M$张爬行卡片，分成$4$种不同的类型（$M$张卡片中不一定包含所有$4$种类型的卡片）。</p><p>每种类型的卡片上分别标有$1,2,3,4$四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。</p><p>游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。</p><p>游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。</p><p>玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。</p><p>很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同。</p><p>小明想要找到一种卡片使用顺序使得最终游戏得分最多。</p><p>现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>每行中两个数之间用一个空格隔开。</p><p>第$1$行包括$2$个正整数$N,M$，分别表示棋盘格子数和爬行卡片数。</p><p>第$2$行包括$N$个非负整数，$a_1,a_2,…,a_N$表示棋盘第$i$个格子上的分数。</p><p>第$3$行$M$个整数，$b_1,b_2,…,b_M$，表示$M$张爬行卡片上的数字。</p><p>输入数据保证到达终点时刚好用光$M$张爬行卡片。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，包括$1$个整数$ans$，表示小明最多能得到的分数。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">9 5</span><br><span class="line">6 10 14 2 8 8 18 5 17</span><br><span class="line">1 3 1 2 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">73</span><br></pre></td></tr></table></figure><hr><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>小明使用爬行卡片顺序为$1,1,3,1,2$,得到的分数为$6+10+14+8+18+17=73$。</p><p>注意，由于起点是$1$，所以自动获得第$1$格的分数$6$</p><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$30\%$数据,有$1≤N≤30,1≤M≤12$。</p><p>对于$50\%$的数据,有$1≤N≤120,1≤M≤50$，且有全部$4$种爬行卡片，每种卡片的张数不会超过$20$。</p><p>对于$100\%$的数据,有$1≤N≤350,1≤M≤120$，且有全部$4$种爬行卡片，每种卡片的张数不会超过$40$；</p><p>对于其他上面未提到的变量，保证$0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>真的是<code>NOIP</code>里最简单的DP题了……</del></p><p>不难发现，卡片的种类数与每一种卡片的数量都极少。因此，我们可以直接开一个四维数组表示状态。</p><p>设$f_{i,j,k,l}$表示四种卡片分别使用了$i , j , k , l$张所能得到的最大得分，每一次转移时暴力枚举最后一次使用的卡片即可。</p><p>时间复杂度$O(g_1 \times g_2 \times g_3 \times g_4)$，其中$g_i$表示第$i$种卡牌的数量，最大为$40$。足以通过本题。</p><p>当然，你也可以选择使用滚动数组压掉一维。这样就可以处理$g_i &lt; 90$的情况。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 45</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">10001</span>];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">ll f[N][N][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        g[num] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= g[<span class="number">1</span>]; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= g[<span class="number">2</span>]; j ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= g[<span class="number">3</span>]; k ++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= g[<span class="number">4</span>]; l ++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> len = <span class="number">1</span> + i + <span class="number">2</span> * j + <span class="number">3</span> * k + <span class="number">4</span> * l;</span><br><span class="line">                    <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                        f[i][j][k][l] = max(f[i][j][k][l] , f[i - <span class="number">1</span>][j][k][l] + a[len]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j != <span class="number">0</span>)&#123;</span><br><span class="line">                        f[i][j][k][l] = max(f[i][j][k][l] , f[i][j - <span class="number">1</span>][k][l] + a[len]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(k != <span class="number">0</span>)&#123;</span><br><span class="line">                        f[i][j][k][l] = max(f[i][j][k][l] , f[i][j][k - <span class="number">1</span>][l] + a[len]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(l != <span class="number">0</span>)&#123;</span><br><span class="line">                        f[i][j][k][l] = max(f[i][j][k][l] , f[i][j][k][l - <span class="number">1</span>] + a[len]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[g[<span class="number">1</span>]][g[<span class="number">2</span>]][g[<span class="number">3</span>]][g[<span class="number">4</span>]] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> Luogu </tag>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOIP2016】组合数问题-题解</title>
      <link href="2019/10/20/luoguP2822/"/>
      <url>2019/10/20/luoguP2822/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>组合数 $C_n^m$表示的是从$n$个物品中选出$m$个物品的方案数。</p><p>举个例子，从$(1,2,3)$三个物品中选择两个物品可以有$(1,2),(1,3),(2,3)$这三种选择方法。</p><p>根据组合数的定义，我们可以给出计算组合数$C_n^m$的一般公式：<script type="math/tex">C_n^m = \frac{n!}{m!\times(n - m)!}</script></p><p>其中，$!$代表阶乘，$n!=1\times2\times\cdots\times n$。特别地，定义$0! = 1$。</p><p>小葱想知道如果给定 $n,m$ 和 $k$，对于所有的 $0\leq i\leq n$,$0\leq j\leq \min \left ( i, m \right )$有多少对$(i,j)$满足$C_i^j$是$k$的倍数。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个整数 $t,k$，其中 $t$ 代表该测试点总共有多少组测试数据，$k$ 的意义见问题描述。</p><p>接下来 $t$ 行每行两个整数 $n,m$,其中 $n,m$ 的意义见问题描述。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共 $t$ 行，每行一个整数代表所有的 $0\leq i\leq n,0\leq j\leq \min \left ( i, m \right )$中有多少对 $(i,j)$ 满足 $C_i^j$是 $k$ 的倍数。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2 5</span><br><span class="line">4 5</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">7</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/20/GE3lBXsuP7Ukzha.png" alt="3457.png"></p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>组合数学入门题。</p><p>根据<code>Pascal</code>公式，即<script type="math/tex">C_n^m = C_{n - 1} ^ {m - 1} + C_{n - 1}^{m}</script></p><p>可以在$O(n^2)$的时间内预处理出$C_i^j \bmod k$的值。</p><p><del>然后暴力统计，你就拿了90分</del></p><p>之后使用前缀和$num_{s , i}$表示对于每一个$1 &lt; j &lt; i$，有多少个$C_s^j \bmod k = 0$，每一次询问时$O(n)$查询即可。</p><p>时间复杂度为$O(t \times n)$，而本题数据范围较小，足以通过。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll t , HA , n , m;</span><br><span class="line">ll c[N][N];</span><br><span class="line">ll num[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_num</span><span class="params">(<span class="keyword">int</span> n , ll HA)</span></span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = c[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++)&#123;<span class="comment">//预处理组合数表</span></span><br><span class="line">            c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + c[i - <span class="number">1</span>][j];    </span><br><span class="line">            c[i][j] %= HA;   <span class="comment">//由于模运算对加法，减法，乘法封闭，所以直接判断是否可以整除即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;   <span class="comment">//简单的憨憨前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">            num[i][j] = num[i][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(c[i][j] == <span class="number">0</span>)&#123;   <span class="comment">//如果可以整除，可行方案就+1</span></span><br><span class="line">                num[i][j] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t &gt;&gt; HA;</span><br><span class="line">    get_num(<span class="number">2001</span> , HA);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i ++)&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= n; j ++)&#123;    <span class="comment">//处理每一次询问</span></span><br><span class="line">            ans += num[j][min(j , m)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> Luogu </tag>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【成长之路】CSP-S2019初赛退役记</title>
      <link href="2019/10/19/csp-s2019-1/"/>
      <url>2019/10/19/csp-s2019-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本来要写初赛退役记的，结果退役失败了，所以……</p><p>非常抱歉，这篇文章鸽了。</p><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 成长之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长之路 </tag>
            
            <tag> 灌水区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【BZOJ &amp; 洛谷题库】算术天才⑨与等差数列-题解</title>
      <link href="2019/10/18/luoguP5278/"/>
      <url>2019/10/18/luoguP5278/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>算术天才$⑨$非常喜欢和等差数列玩耍。</p><p>有一天，他给了你一个长度为$n$的序列，其中第$i$个数为$a_i$。</p><p>他想考考你，每次他会给出询问$l,r,k$，问区间$[l , r]$内的数从小到大排序后能否形成公差为$k$的等差数列。</p><p>当然，他还会不断修改其中的某一项。</p><p>为了不被他鄙视，你必须要快速并正确地回答完所有问题。 </p><p><strong>注意：只有一个数的数列也是等差数列。</strong></p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数$n,m$，分别表示序列的长度和操作的次数。</p><p>第二行包含$n$个整数，依次表示序列中的每个数$a_i$ 。</p><p>接下来$m$行，每行一开始为一个数$opt$。</p><p>若$opt=1$，则接下来两个整数$x,y$，表示把$a_x$修改为$y$。</p><p>若$opt=2$，则接下来三个整数$l,r,k$，表示一个询问。</p><p>在本题中，所有的$x,y,l,r,k$都是经过加密的，都需要异或(即<code>xor</code> , <code>C++</code>中为<code>^</code>)你之前输出的<code>Yes</code>的个数来进行解密。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出若干行，对于每个询问操作，如果可以形成等差数列，请输出<code>Yes</code>，否则输出<code>No</code>。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">1 3 2 5 6</span><br><span class="line">2 1 5 1</span><br><span class="line">1 5 4</span><br><span class="line">2 1 5 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$100\%$的数据，保证$1 &lt; n , m &lt; 3 \times 10^5$，$1 &lt; a_i &lt; 10^9$</p><p>$1 &lt; x &lt; n$ ， $1 &lt; y &lt; 10^9$</p><p>$1 &lt; l , r &lt; n$ ， $1 &lt; k &lt; 10^9$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>养 生 题 目 警 告。</del></p><p>首先，我们先来回想一下等差数列的公差公式，即$max - min = (r - l) \times k$</p><p>移一下项，就变成了$k = \frac{max - min}{r - l}$</p><p>不难看出，如果我们要判断一段序列是否可以形成等差数列，必须要求出这段区间的最值(即$max$与$min$)，这样才能求出公差。</p><p>继续考虑等差数列的性质。可以注意到，如果区间内的数能够形成等差数列，必须满足以下两条件之一</p><ol><li>公差为$0$。</li><li>数列内无相同元素，公差为相邻两个数之差的绝对值的$gcd$（即最大公约数）。</li></ol><p>而相邻两数之差的绝对值可以通过差分维护。</p><p>这样的话，我们一共需要维护四种元素，分别是区间$max$ &amp; $min$，差分序列上的区间$gcd$，以及每个数前驱相同元素的位置。</p><p>其中，维护每个数前驱相同的元素的位置可以<code>map</code>套<code>set</code>，其他的均可以线段树维护</p><p>代码的话，<del>往死里写就完事了</del></p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n , m , a[N] , b[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>  , <span class="keyword">int</span> &gt; M;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>  &gt; S[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> opt , num , x , p , l , r , d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Segment_tree&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lson(x) x &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rson(x) x &lt;&lt; 1 | 1</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    ll maxn[N &lt;&lt; <span class="number">2</span>] , minn[N &lt;&lt; <span class="number">2</span>] , Gcd[N &lt;&lt; <span class="number">2</span>] , l[N &lt;&lt; <span class="number">2</span>] , r[N &lt;&lt; <span class="number">2</span>] , last[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">gcd</span><span class="params">(ll a , ll b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !b ? a : gcd(b , a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        minn[x] = min(minn[lson(x)] , minn[rson(x)]);</span><br><span class="line">        maxn[x] = max(maxn[lson(x)] , maxn[rson(x)]);</span><br><span class="line">        Gcd[x] = gcd(Gcd[lson(x)] , Gcd[rson(x)]);</span><br><span class="line">        last[x] = max(last[lson(x)] , last[rson(x)]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        l[x] = ql , r[x] = qr;</span><br><span class="line">        <span class="keyword">if</span>(ql == qr)&#123;</span><br><span class="line">            maxn[x] = minn[x] = a[ql];</span><br><span class="line">            Gcd[x] = b[ql];</span><br><span class="line">            last[x] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (ql + qr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(lson(x) , ql , mid);</span><br><span class="line">        build(rson(x) , mid + <span class="number">1</span> , qr);</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k , <span class="keyword">int</span> p , <span class="keyword">int</span> x , <span class="keyword">int</span> opt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[k] == r[k])&#123;</span><br><span class="line">            <span class="keyword">if</span>(opt == <span class="number">0</span>)&#123;</span><br><span class="line">                maxn[k] = minn[k] = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">                Gcd[k] = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                last[k] = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l[k] + r[k]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= mid)&#123;</span><br><span class="line">            change(lson(k) , p , x , opt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            change(rson(k) , p , x , opt);</span><br><span class="line">        &#125;</span><br><span class="line">        pushup(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">range_max</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[x] == ql &amp;&amp; r[x] == qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> maxn[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l[x] + r[x]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid &gt;= qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> range_max(lson(x) , ql , qr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ql &gt; mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> range_max(rson(x) , ql , qr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> max(range_max(lson(x) , ql , mid) , range_max(rson(x) , mid + <span class="number">1</span> , qr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">range_min</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[x] == ql &amp;&amp; r[x] == qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> minn[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l[x] + r[x]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid &gt;= qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> range_min(lson(x) , ql , qr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ql &gt; mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> range_min(rson(x) , ql , qr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> min(range_min(lson(x) , ql , mid) , range_min(rson(x) , mid + <span class="number">1</span> , qr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">range_gcd</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[x] == ql &amp;&amp; r[x] == qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> Gcd[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l[x] + r[x]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid &gt;= qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> range_gcd(lson(x) , ql , qr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ql &gt; mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> range_gcd(rson(x) , ql , qr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> gcd(range_gcd(lson(x) , ql , mid) , range_gcd(rson(x) , mid + <span class="number">1</span> , qr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">range_last</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[x] == ql &amp;&amp; r[x] == qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> last[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l[x] + r[x]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid &gt;= qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> range_last(lson(x) , ql , qr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ql &gt; mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> range_last(rson(x) , ql , qr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> max(range_last(lson(x) , ql , mid) , range_last(rson(x) , mid + <span class="number">1</span> , qr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        b[i] = <span class="built_in">abs</span>(a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(M.find(a[i]) == M.end())&#123;</span><br><span class="line">            M[a[i]] = ++ cnt;</span><br><span class="line">            S[cnt].insert(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        S[M[a[i]]].insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Segment_tree :: build(<span class="number">1</span> , <span class="number">1</span> , n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; opt;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; x;</span><br><span class="line">            p ^= num , x ^= num;</span><br><span class="line">            a[p] = x;</span><br><span class="line">            Segment_tree :: change(<span class="number">1</span> , p , x , <span class="number">0</span>);</span><br><span class="line">            Segment_tree :: change(<span class="number">1</span> , p , <span class="built_in">abs</span>(a[p] - a[p - <span class="number">1</span>]) , <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(p &lt;= n)&#123;</span><br><span class="line">                Segment_tree :: change(<span class="number">1</span> , p + <span class="number">1</span> , <span class="built_in">abs</span>(a[p + <span class="number">1</span>] - a[p]) , <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; d;</span><br><span class="line">            l ^= num , r ^= num , d ^= num;</span><br><span class="line">            <span class="keyword">if</span>(Segment_tree :: range_max(<span class="number">1</span> , l , r) - Segment_tree :: range_min(<span class="number">1</span> , l , r) == <span class="number">1l</span>l * d * (r - l) &amp;&amp; (d == <span class="number">0</span> || l == r || ((Segment_tree :: range_gcd(<span class="number">1</span> , l + <span class="number">1</span> , r) % d == <span class="number">0</span>) &amp;&amp; Segment_tree :: range_last(<span class="number">1</span> , l , r) &lt; l)))&#123;</span><br><span class="line">                ++ num;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> STL </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> Luogu </tag>
            
            <tag> BZOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces】Jzzhu and Cities-题解</title>
      <link href="2019/10/17/CF449B/"/>
      <url>2019/10/17/CF449B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>给你$n$个点，$m$条带权边的无向图，以及$k$条特殊边，每条边连接$1$和$k_i$ 。</p><p>问在保证每个点到$1$的最短距离不变的情况下，最多可以删除这$k$条边中的多少条边，</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行3个数字$n,m,k$</p><p>下面$m$行，每行3个数字$u_i,v_i,x_i$</p><p>再下面$k$ 行，每行两个数字$k_i,v_i$，代表连接$1$到$k_i$ 的边，权值为$v_i$</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，为一个整数$ans$。表示能删除的最大边数。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 5 3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">1 3 3</span><br><span class="line">3 4 4</span><br><span class="line">1 5 5</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2 2 3</span><br><span class="line">1 2 2</span><br><span class="line">2 1 3</span><br><span class="line">2 1</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$100\%$的数据，保证$1 &lt; u_i , v_i , s_i &lt; n &lt; 10^5$</p><p>$1 &lt; k &lt; 10^5$</p><p>$1 &lt; m &lt; 3 \times 10^5$</p><p>$1 &lt; x_i , y_i &lt; 10^9$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>听说这题假做法很多？？？</p><p>这里只说真做法。</p><p>对于每一条特殊的边，它能被删除，当且仅当它不在从$1$到任意一点的唯一最短路中。</p><p>因此，我们模拟$Dijkstra$的过程，判断每一条特殊边是否在最短路中即可。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , k;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    ll dis;</span><br><span class="line">&#125;edge[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"><span class="keyword">int</span> head[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , ll dis)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = (Edge)&#123;to , head[from] , dis&#125;;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pairs pair<span class="meta-string">&lt;ll , ll &gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;pairs &gt;  Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll u , v , w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span> , &amp;n , &amp;m , &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">        u --;</span><br><span class="line">        v --;</span><br><span class="line">        add_edge(u , v , w);</span><br><span class="line">        add_edge(v , u , w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span> , &amp;v , &amp;w);</span><br><span class="line">        v --;</span><br><span class="line">        Q.push(<span class="built_in">make_pair</span>(- w  , v - n));</span><br><span class="line">    &#125;</span><br><span class="line">    Q.push(<span class="built_in">make_pair</span>(<span class="number">0</span> , <span class="number">0</span>));</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        pairs v = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(v.second &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            v.second += n;</span><br><span class="line">            <span class="keyword">if</span>(vis[v.second])&#123;</span><br><span class="line">                ans ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vis[v.second])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[v.second] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[v.second] ; i ; i = edge[i].last)&#123;</span><br><span class="line">            Q.push(<span class="built_in">make_pair</span>(v.first - edge[i].dis , edge[i].to));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span> , ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Codeforces </tag>
            
            <tag> 图论 </tag>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces】Hard Process-题解</title>
      <link href="2019/10/16/CF660C/"/>
      <url>2019/10/16/CF660C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>给你一个数组，其中有$n$个元素，每个元素不是$0$就是$1$。</p><p>现在可以进行$k$次操作，每次操作可以改变数组中的一个元素（只能改成$0$或$1$）。</p><p>请求出操作后最长连续$1$的序列的长度，并输出操作后的序列。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入两个整数$n$和$k$，分别代表元素的个数与可以进行的操作数。</p><p>第二行包含$n$个整数$a_1 , a_2 …… a_n$。每个整数只存在$1$或$0$两种情况。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行为一个整数$z$，表示最长连续$1$的序列长度。</p><p>第二行包含$n$个整数，表示操作后的序列。</p><p>如果有多个答案，请输出其中的任意一种答案。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">7 1</span><br><span class="line">1 0 0 1 1 0 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 0 0 1 1 1 1</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">10 2</span><br><span class="line">1 0 0 1 0 1 0 1 0 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 0 0 1 1 1 1 1 0 1</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$100\%$的数据， $1 &lt; n &lt; 3 * 10^5 , 0 &lt; k &lt; n$。 </p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道贪心好题。</p><p>先来看朴素做法：暴力枚举区间，然后暴力统计其中$0$的数量，时间复杂度为$O(n^3)$，显然无法通过</p><p>考虑如何优化这个算法。</p><p>显然，对于一段含有$0$的区间，我们让区间中所有$0$填满是最优的。</p><p>因此我们只需要维护一段区间，让这段区间中$0$的个数小于等于$k$即可。</p><p>这样的话，我们可以直接从第$1$位开始拓展一段区间。初始时，这段区间的$l , r$均为$1$，即$[1 , 1]$。</p><p>若向后拓展$1$位后$0$的总数不大于$k$，即$[l , r + 1]$不大于$k$，则拓展是可行的。直接拓展即可。</p><p>否则将$l$右移，直到这段区间中$0$的数量小于$k$为止。</p><p>时间复杂度为$O(n)$，足以通过本题。</p><p>剩下的详见代码注释</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , k;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line">ll ans = <span class="number">0</span> , cnt = <span class="number">0</span>;   <span class="comment">//cnt为0的个数</span></span><br><span class="line"><span class="keyword">int</span> L , R;     <span class="comment">//最终答案的那段连续为1的区间的左右端点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span> , r = <span class="number">1</span>; r &lt;= n; r ++)&#123;</span><br><span class="line">        cnt += (a[r] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);     </span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; k)&#123;    <span class="comment">//如果0的数量大于k，则左端点右移</span></span><br><span class="line">            cnt -= (a[l] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r - l + <span class="number">1</span> &gt; ans)&#123;     <span class="comment">//如果当前连续1的序列长度大于当前的答案，则更新</span></span><br><span class="line">            ans = r - l + <span class="number">1</span>;</span><br><span class="line">            L = l;</span><br><span class="line">            R = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;        <span class="comment">//最后输出即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= i &amp;&amp; i &lt;= R)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JSOI2007】建筑抢修-题解</title>
      <link href="2019/10/16/luoguP4053/"/>
      <url>2019/10/16/luoguP4053/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>小刚在玩<del><code>JSOI</code></del>提供的一个称之为“建筑抢修”的游戏。</p><p>经过了一场激烈的战斗，$T$部落消灭了所有$Z$部落的入侵者。</p><p>但是$T$部落的基地里已经有$N$个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。</p><p>现在的情况是：$T$部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。</p><p>同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。</p><p>如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就会报废。</p><p>你的任务是帮小刚合理的制订一个修理顺序，尽可能多的抢修建筑。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个整数$n$，表示建筑的数目。</p><p>接下来$n$行每行两个整数$t_1,t_2$，用来描述一个建筑：修理这个建筑需要$t_1$秒，如果在$t_2$秒之内还没有修理完成，这个建筑就报废了。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出只有一行，一个整数$s$，表示最多可以抢修的建筑数.</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">100 200</span><br><span class="line">200 1300</span><br><span class="line">1000 1250</span><br><span class="line">2000 3200</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$100\%$的数据，$0 &lt; N &lt; 1.5 \times 10^5$， $0 &lt; t_1 &lt; t_2 &lt; 2147483647$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道简单的贪心题。</p><p>首先，我们需要把所有数按照$t_2$进行升序排序，从而确定修理建筑的先后顺序。</p><p>但仅仅这样贪心不一定是最优的，需要在中途进行转正。</p><p>排序之后，我们从$1$到$n$遍历一遍建筑，确定这个建筑是否需要修理。</p><p>显然，如果可以在这个建筑报废之前修理好它，则一定修。</p><p>否则的话，则一定会报废一个建筑。显然，要报废的建筑的是修理时间最长的建筑。</p><p>剩下的详见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 150001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Building</span>&#123;</span></span><br><span class="line">    ll t1;</span><br><span class="line">    ll t2;</span><br><span class="line">&#125;build[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Building a , Building b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.t2 &lt; b.t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll sum , ans;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;ll &gt; Q;    <span class="comment">//采用优先队列维护耗时最长的建筑。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; build[i].t1 &gt;&gt; build[i].t2;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(build + <span class="number">1</span> , build + <span class="number">1</span> + n , cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        sum += build[i].t1;</span><br><span class="line">        Q.push(build[i].t1);</span><br><span class="line">        <span class="keyword">if</span>(sum &lt;= build[i].t2)&#123;     <span class="comment">//如果可以修，就修。</span></span><br><span class="line">            ans ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;       <span class="comment">//否则报废耗时最长的建筑。</span></span><br><span class="line">            sum -= Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 各省省选 </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces】Discounts-题解</title>
      <link href="2019/10/16/CF161B/"/>
      <url>2019/10/16/CF161B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>超市进行优惠活动，顾客如果在一架购物车中放上一个凳子$(?)$，他就可以半价买掉这架购物车里最便宜的商品。</p><p>每一辆购物车的容量是无限的，但一个购物车里只能有一件商品半价。</p><p>现在$Polycarpus$要用$k$架购物车装要买的$n$件商品，里面有一些是凳子。他希望用最少的钱来买这些东西。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数$n$、$k$；</p><p>第$2$行至第$n+1$行，每行两个整数$c_i$，$t_i$ 。</p><p>其中$c_i$表示商品$i$的价格，$t_i$表示商品$i$的类型（$1$表示它是凳子，$2$表示它不是凳子）</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行<strong>输出一个一位小数</strong>，表示折扣之后最少需要付的价格。</p><p>接下来的$k$行，每行开头输出一个整数$a_i$，表示购物车$i$中商品的数量。</p><p>后面跟着<script type="math/tex">a_i</script>个整数 <script type="math/tex">b_1,b_2...b_{a_i}</script>，分别表示商品的编号。</p><p>方案可能有很多，输出其中一种即可。购物车和商品的输出顺序不作要求。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">2 1</span><br><span class="line">3 2</span><br><span class="line">3 1</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5.5</span><br><span class="line">2 1 2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">4 1</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8.0</span><br><span class="line">1 1</span><br><span class="line">2 4 2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><hr><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>在样例$1$中，购物车有$2$架，其中一架装商品$1$（凳子）和$2$（其他），另一架装商品$3$（凳子）。</p><p>这样安排便可以使价格最低。</p><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$100\%$的数据，$1 &lt; n , k &lt; 10^3 ， 1 &lt; c_i &lt; 10^9 ， t_i \in \lbrace 1 , 2 \rbrace$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>又是一道贪心好题</p><p>我们先只考虑单个凳子的情况，显然，一个凳子只能让自己或者一个价格比自己低的东西半价。</p><p>而题目中让我们最小化价格，即让省下的钱最多。因此，我们尽量多的让一个凳子单独在一个购物车中。</p><p>显然，这个最大值为$k - 1$。因为你还要留出一辆购物车来存储其他的物品。</p><p>但这还不够。如果凳子的数量小于$k - 1$的话，我们就把所有的凳子半价，然后原价买下其他商品即可</p><p>最后别忘了保留一位小数。</p><p>剩下的见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , k;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> val;    <span class="comment">//题目要求输出一位小数，因此要开long double</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> str;</span><br><span class="line">&#125;node[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ans_num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a , Node b)</span></span>&#123;      </span><br><span class="line">    <span class="keyword">if</span>(a.str == b.str == <span class="number">1</span>)&#123;       <span class="comment">//如果他们都是凳子，就把价值大的放在前边。</span></span><br><span class="line">        <span class="keyword">return</span> a.val &gt; b.val;</span><br><span class="line">    &#125;                           </span><br><span class="line">    <span class="keyword">else</span>&#123;                       <span class="comment">//否则，将凳子放在前边</span></span><br><span class="line">        <span class="keyword">return</span> a.str &lt; b.str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>  , <span class="keyword">int</span> &gt; ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; node[i].val &gt;&gt; node[i].str;</span><br><span class="line">        node[i].val *= <span class="number">1.0</span>;</span><br><span class="line">        node[i].num = i;</span><br><span class="line">        <span class="keyword">if</span>(node[i].str == <span class="number">1</span>)&#123;</span><br><span class="line">            cnt ++;     <span class="comment">//记录凳子的数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node + <span class="number">1</span> , node + <span class="number">1</span> + n , cmp);</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; k - <span class="number">1</span>)&#123;        <span class="comment">//分类讨论，当凳子数量大于购物车数量-1时</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            node[i].val /= <span class="number">2</span>;</span><br><span class="line">            ans_num += node[i].val;</span><br><span class="line">            ans[i] = <span class="built_in">make_pair</span>(<span class="number">1</span> , node[i].num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> minn = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i ++)&#123;</span><br><span class="line">            ans_num += node[i].val;</span><br><span class="line">            <span class="keyword">if</span>(node[i].val &lt; minn)&#123;</span><br><span class="line">                minn = node[i].val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans_num -= minn;</span><br><span class="line">        ans_num += minn / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; ans_num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[i].first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans[i].second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n - k + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; node[i].num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == k - <span class="number">1</span>)&#123;  <span class="comment">//当凳子数量等于购物车数量-1时</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            node[i].val /= <span class="number">2</span>;</span><br><span class="line">            ans_num += node[i].val;</span><br><span class="line">            ans[i] = <span class="built_in">make_pair</span>(<span class="number">1</span> , node[i].num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i ++)&#123;</span><br><span class="line">            ans_num += node[i].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; ans_num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[i].first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans[i].second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n - k + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; node[i].num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;   <span class="comment">//当凳子数量小于购物车数量-1时</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++)&#123;</span><br><span class="line">            node[i].val /= <span class="number">2</span>;</span><br><span class="line">            ans_num += node[i].val;</span><br><span class="line">            ans[i] = <span class="built_in">make_pair</span>(<span class="number">1</span> , node[i].num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            ans_num += node[i].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; ans_num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[i].first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans[i].second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt;= k - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; node[i].num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n - k + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; node[i].num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> Codeforces </tag>
            
            <tag> 分类讨论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JLOI2011】飞行路线-题解</title>
      <link href="2019/10/14/luoguP4568/"/>
      <url>2019/10/14/luoguP4568/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p><code>Alice</code>和<code>Bob</code>现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。</p><p>该航空公司一共在$n$个城市设有业务，设这些城市分别标记为$0$到$n-1$，一共有$m$种航线。</p><p>每种航线连接两个城市，并且航线有一定的价格。</p><p><code>Alice</code>和<code>Bob</code>现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。</p><p>航空公司对他们这次旅行也推出优惠，他们可以免费在最多$k$种航线上搭乘飞机。</p><p>那么<code>Alice</code>和<code>Bob</code>这次出行最少花费多少？</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>数据的第一行有三个整数，$n,m,k$,分别表示城市数，航线数和免费乘坐次数。</p><p>第二行有两个整数，$s,t$，分别表示他们出行的起点城市编号和终点城市编号。</p><p>接下来有$m$行，每行三个整数，$a,b,c$，表示存在一种航线，能从城市$a$到达城市$b$，或从城市$b$到达城市$a$，价格为$c$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出数据仅有一行，包含一个整数$ans$，为最少花费的钱数。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 6 1</span><br><span class="line">0 4</span><br><span class="line">0 1 5</span><br><span class="line">1 2 5</span><br><span class="line">2 3 5</span><br><span class="line">3 4 5</span><br><span class="line">2 3 3</span><br><span class="line">0 2 100</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于$30\%$的数据,$2 \le n \le 50,1 \le m \le 300,k=0$;</p><p>对于$50\%$的数据,$2 \le n \le 600,1 \le m \le 6000,0 \le k \le 1$;</p><p>对于$100\%$的数据,$2 \le n \le 10000,1 \le m \le 50000,0 \le k \le 10$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分层图最短路的版子题。</p><h3 id="30分做法"><a href="#30分做法" class="headerlink" title="30分做法"></a>30分做法</h3><p>设起点为$start$,终点为$finish$。</p><p>对于$30\%$的数据，$k = 0$，则我们直接使用$Dijkstra$算法求解从$start$到$finish$的最短路即可。</p><p><del>10年前的省选暴力分都是白送的吗？？？</del></p><hr><h3 id="100分做法"><a href="#100分做法" class="headerlink" title="100分做法"></a>100分做法</h3><p>考虑如何处理免费次数。</p><p>我们将图建成$k$层，第$i$层对应着使用了$i$次免费次数。</p><p>各层内部正常连边，而上下两层之间从上到下连边权为$0$的边。这样，每跑一层，就相当于用了一次免费机会。</p><p>就像下图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/14/xyisIzf4G8Ng1FV.png" alt="样例.png"></p><p>但这样还不够，因为如果提供的免费机会大于坐飞机的次数的话，则花费为$0$。</p><p>因此，我们还需要对每一层的$finish$向下一层的$finish$建一条边权为$0$的边。以便于到达终点之后处理剩下的免费次数。</p><p>最后，我们只需要跑一次从$start$到$finish + n * k$的最短路即可。</p><p>剩下的详见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 125001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , s , k;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    ll dis;</span><br><span class="line">&#125;edge[(M * K) &lt;&lt; <span class="number">1</span>];    <span class="comment">//每一层都要建m条边，并且题目中要求是双向边，因此，总边数为(m * k) * 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[(M * K) &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , ll dis)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = Edge&#123;to , head[from] , dis&#125;;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dis[(M * K) &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[(M * K) &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pairs pair<span class="meta-string">&lt;ll , ll &gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;pairs , <span class="built_in">vector</span>&lt;pairs &gt; , greater&lt;pairs &gt; &gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">        dis[i] = <span class="number">0x3f3f3f3f</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    Q.push(<span class="built_in">make_pair</span>(dis[s] , s));</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> v = Q.top().second;</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[v]; i ; i = edge[i].last)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[to] &gt; dis[v] + edge[i].dis)&#123;</span><br><span class="line">                dis[to] = dis[v] + edge[i].dis;</span><br><span class="line">                Q.push(<span class="built_in">make_pair</span>(dis[to] , to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    <span class="keyword">int</span> start , finish;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; start &gt;&gt; finish;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        add_edge(u , v , w);</span><br><span class="line">        add_edge(v , u , w);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j ++)&#123;   <span class="comment">//对于每一层，分别建边</span></span><br><span class="line">            add_edge(u + (j - <span class="number">1</span>) * n , v + j * n , <span class="number">0</span>);  <span class="comment">//与下一层建立两条边权为0的边</span></span><br><span class="line">            add_edge(v + (j - <span class="number">1</span>) * n , u + j * n , <span class="number">0</span>);</span><br><span class="line">            add_edge(u + j * n , v + j * n , w);    <span class="comment">//在本层中直接建边</span></span><br><span class="line">            add_edge(v + j * n , u + j * n , w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)&#123;   <span class="comment">//最后在每一个结束点之间分别建一条边权为0的边，方便处理没用完的免费次数。</span></span><br><span class="line">        add_edge(finish + (i - <span class="number">1</span>) * n , finish + i * n , <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(start);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dis[finish + k * n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 各省省选 </tag>
            
            <tag> Luogu </tag>
            
            <tag> 分层图最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JSOI2008】星球大战-题解</title>
      <link href="2019/10/13/luoguP1197/"/>
      <url>2019/10/13/luoguP1197/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。</p><p>某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。</p><p>之后他们在各个星球之间建立了以太隧道，这些星球通过特殊的以太隧道互相直接或间接地连接。</p><p>但好景不长，很快帝国又重新造出了他的超级武器。</p><p>凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。</p><p>由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。</p><p>现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数$n$ , $m$，分别表示星球的数目和以太隧道的数目。</p><p>接下来的 $m$ 行，每行包括两个整数 $x$, $y$ ，表示星球 $x$ 和星球 $y$ 之间有 “以太” 隧道，可以直接通讯。</p><p>接下来的一行为一个整数 $k$ ，表示将遭受攻击的星球的数目。</p><p>接下来的 $k$ 行，每行有一个整数，按照顺序列出了帝国军的攻击目标。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共$k + 1$行，第一行是开始时星球的连通块个数。</p><p>接下来的 $k$ 行，每行一个整数，表示经过该次打击后现存星球的连通块个数。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8 13</span><br><span class="line">0 1</span><br><span class="line">1 6</span><br><span class="line">6 5</span><br><span class="line">5 0</span><br><span class="line">0 6</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">7 1</span><br><span class="line">7 2</span><br><span class="line">7 6</span><br><span class="line">3 6</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$100\%$的数据，$0 &lt; m &lt; 200000$ , $0 &lt; n &lt; 2\times m$，$0 &lt; x , y &lt; n$</p><p>星球编号为$0$到$n - 1$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道并查集好题。</p><p>题目给出的删除操作并不容易实现，因此，我们把删除操作转换为重建操作。</p><p>这样，题目就由$1$个连通块拆为多个连通块变成了由多个连通块合成$1$个连通块。</p><p>对于每一次操作，我们建立一个新的节点，然后使用并查集来判断其连通性，并将其记录到答案中。</p><p>输出时倒序输出即可。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[root] == root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre[root] = find(pre[root]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pd</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(find(a) == find(b))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    a = find(a);</span><br><span class="line">    b = find(b);</span><br><span class="line">    <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">        pre[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_number;</span><br><span class="line"><span class="keyword">int</span> hhead[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    edge[++ edge_number].to = to;</span><br><span class="line">    edge[edge_number].from = from;</span><br><span class="line">    edge[edge_number].last = head[from];</span><br><span class="line">    head[from] = edge_number;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> x , y , k;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> boom[N];</span><br><span class="line"><span class="keyword">bool</span> Broken[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    Start();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        add_edge(x , y);</span><br><span class="line">        add_edge(y , x);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; boom[i];</span><br><span class="line">        Broken[boom[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> number = n - k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Broken[edge[i].from] &amp;&amp; !Broken[edge[i].to] &amp;&amp; pd(edge[i].from , edge[i].to) == <span class="literal">false</span>)&#123;</span><br><span class="line">            number --;</span><br><span class="line">            merge(edge[i].from , edge[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[k + <span class="number">1</span>] = number;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &gt;= <span class="number">1</span>; i --)&#123;</span><br><span class="line">        number ++;</span><br><span class="line">        Broken[boom[i]] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = head[boom[i]] ; j ; j = edge[j].last)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Broken[edge[j].to] &amp;&amp; pd(boom[i] , edge[j].to) == <span class="literal">false</span>)&#123;</span><br><span class="line">                number --;</span><br><span class="line">                merge(boom[i] , edge[j].to);        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 各省省选 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ZROI】ZROI 2019普及组Day3-题解</title>
      <link href="2019/10/12/ZROI-pj5-Day3/"/>
      <url>2019/10/12/ZROI-pj5-Day3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem-A"><a href="#Problem-A" class="headerlink" title="Problem A"></a>Problem A</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://zhengruioi.com/contest/429/problem/992">点我康题目</a></p><p>(ps.所有题目链接均需要开启<code>ZROI普及组5联测</code>权限)</p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一道送分题目。</p><p>我们共有$3$种不同的走法，分别是不坐缆车，从$a$处上车$b$处下车，从$b$处上车$a$处下车。</p><p>这三种走法需要走路的长度分别为$|y - x|$ , $|x - a| + |y - b|$ , $|x - b| + |y - a|$。</p><p>因此，我们只需要分别算出$3$种走法的长度，然后取$min$即可</p><hr><h3 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x , y , a , b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; min(min(<span class="built_in">abs</span>(y - x) , <span class="built_in">abs</span>(x - a) + <span class="built_in">abs</span>(b - y)) , <span class="built_in">abs</span>(x - b) + <span class="built_in">abs</span>(a - y));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Problem-B"><a href="#Problem-B" class="headerlink" title="Problem B"></a>Problem B</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://zhengruioi.com/contest/429/problem/993">点我康题目</a></p><hr><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>一道典型的搜索题。</p><p>首先，我们很容易想到可以直接枚举这个数中的每一位取与不取以及他们的顺序，但这样做最坏的时间复杂度高达$O(13!)$，而且很不好写。</p><p>因此，我们可以转换一下思路：直接枚举从$0$到根号下$n * 10$是否可行。</p><p>这样做虽然看起来时间复杂度很大，但我们所要做的工作就只是判断这个数可不可行，也就减少了多余的计算。</p><p>并且我们从小到大枚举，输出的顺序也就正好满足了题目要求。</p><p>但要注意，枚举的范围是从$0$到根号下$n <em> 10$，因为当原数中的每一位调换顺序后可能会比原数要大，但显然小于要$n </em> 10$.</p><hr><h3 id="Code-Accepted-1"><a href="#Code-Accepted-1" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t[N] , s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(t , <span class="number">0</span> , <span class="keyword">sizeof</span>(t));</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">t[n % <span class="number">10</span>] ++;</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(t[i] &gt; s[i])&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span> , &amp;n))&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(s , <span class="number">0</span> , <span class="keyword">sizeof</span>(s));</span><br><span class="line">ll num = n;</span><br><span class="line"><span class="keyword">while</span>(num)&#123;</span><br><span class="line">s[num % <span class="number">10</span>] ++;</span><br><span class="line">num /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt;= <span class="built_in">sqrt</span>(n * <span class="number">10</span>); i ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(check(i) &amp;&amp; check(i * i))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld * %lld = %lld\n&quot;</span> , i , i , i * i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Problem-C"><a href="#Problem-C" class="headerlink" title="Problem C"></a>Problem C</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://zhengruioi.com/contest/429/problem/994">点我康题目</a></p><hr><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>一道背包问题的改版。</p><p>认真读题，不难注意到题目中写着<code>每种酒有且只有一瓶</code>。而且题目要求价值最大化。因此，这是一道$01$背包问题</p><p>又因为题目让我们输出最大方案数，因此，我们需要使用$01$背包计数</p><p>状态转移方程为:$f<em>j += f</em>{j - d_i}$</p><hr><h3 id="Code-Accepted-2"><a href="#Code-Accepted-2" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t , n , m;</span><br><span class="line"><span class="keyword">int</span> f[N] , d[<span class="number">51</span>];</span><br><span class="line">ll num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f , <span class="number">0</span> , <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(d , <span class="number">0</span> , <span class="keyword">sizeof</span>(d));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        Clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">            num += d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        sort(d + <span class="number">1</span> , d + <span class="number">1</span> + n);</span><br><span class="line">        num -= d[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; i --)&#123;</span><br><span class="line">            num -= d[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= d[i]; j --)&#123;</span><br><span class="line">                f[j] += f[j - d[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m - num; d[i - <span class="number">1</span>] &gt; m - num - j &amp;&amp; j &gt; <span class="number">0</span>; j --)&#123;</span><br><span class="line">                ans += f[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Problem-D"><a href="#Problem-D" class="headerlink" title="Problem D"></a>Problem D</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://zhengruioi.com/contest/429/problem/995">点我康题目</a></p><hr><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>一道数据结构题</p><p>题目中给出的删除操作并不好实现，因此，我们考虑使用星球大战的套路，把删除改为重建。</p><p>这样的话，题目就转变为了将多个连通块合成一个连通块。</p><p>我们将询问排序，然后按照时间顺序处理询问。</p><p>实现时，用并查集维护连通性即可。</p><hr><h3 id="Code-Accepted-3"><a href="#Code-Accepted-3" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1501</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; b.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[N * N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w , id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ask &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ask[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span> , <span class="number">1</span> , <span class="number">0</span> , <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span> , <span class="number">0</span> , <span class="number">-1</span> , <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t , n , m , k;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[N][N] , pre[N * N] , size[N * N] , ans[N * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[root] == root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre[root] = find(pre[root]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * m + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> node_num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j];</span><br><span class="line">            node[++ node_num] = Node&#123;i , j , <span class="built_in">map</span>[i][j]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= node_num; i ++)&#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">        size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ask[i].w;</span><br><span class="line">        ask[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ask + <span class="number">1</span> , ask + <span class="number">1</span> + k);</span><br><span class="line">    sort(node + <span class="number">1</span> , node + <span class="number">1</span> + n * m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span> , prt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x , y , tx , ty , u , v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(prt &lt;= n * m &amp;&amp; node[prt].dis &gt; ask[i].w)&#123;</span><br><span class="line">            tot ++;</span><br><span class="line">            x = node[prt].from;</span><br><span class="line">            y = node[prt].to;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3</span>; j ++)&#123;</span><br><span class="line">                tx = x + dx[j];</span><br><span class="line">                ty = y + dy[j];</span><br><span class="line">                <span class="keyword">if</span>(tx &gt;= <span class="number">1</span> &amp;&amp; ty &gt;= <span class="number">1</span> &amp;&amp; tx &lt;= n &amp;&amp; ty &lt;= m &amp;&amp; <span class="built_in">map</span>[tx][ty] &gt; ask[i].w)&#123;</span><br><span class="line">                    u = find(id(x , y));</span><br><span class="line">                    v = find(id(tx , ty));</span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">if</span>(u == v)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(size[u] &lt; size[v])&#123;</span><br><span class="line">                        pre[u] = v;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(size[u] &gt; size[v])&#123;</span><br><span class="line">                        pre[v] = u;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        pre[u] = v;</span><br><span class="line">                        size[v] ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tot --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            prt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ask[i].id] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i ++)&#123;</span><br><span class="line">        Solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> ZROI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HEOI2015】兔子与樱花-题解</title>
      <link href="2019/10/11/luoguP4107/"/>
      <url>2019/10/11/luoguP4107/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>已知花意，未见其花，已见其花，未闻花名，再见其花，落泪千溟，未闻花名，但识花香，已知花名，花已不在。未闻花名，但识花香，再遇花时，泪已千行。<br>                                                         ——《secret base》</p></blockquote><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>很久很久之前，森林里住着一群兔子,有一天，兔子们突然决定要去看樱花。</p><p>兔子们所在森林里的樱花树由$n$个树枝分叉点组成，编号从$0$到$n-1$，这$n$个分叉点由$n-1$个树枝连接,其中$0$号节点是根节点。</p><p>这个树的每个节点上都会有一些樱花，其中第$i$个节点有$c_i$朵樱花。</p><p>樱花树的每一个节点都有最大的载重$m$，对于每一个节点$i$，它的儿子节点的个数和$i$节点上樱花个数之和不能超过$m$，即$son_i + c_i &lt;= m$。</p><p>其中$son_i$表示$i$的儿子的个数，如果$i$为叶子节点，则$son_i = 0$</p><p>现在兔子们觉得樱花树上节点太多，希望去掉一些节点。</p><p>当一个节点被去掉之后，这个节点上的樱花和它的儿子节点都被连到删掉节点的父节点上。</p><p>如果父节点也被删除，那么就会继续向上连接，直到第一个没有被删除的节点为止。</p><p>现在兔子们希望计算在不违背最大载重的情况下，最多能删除多少节点。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入两个正整数$n$和$m$，分别表示樱花树的节点个数和最大载重</p><p>第二行$n$个整数$c_i$，表示第$i$个节点上的樱花个数</p><p>接下来$n$行，每行第一个数$k_i$表示这个节点的子节点个数，接下来$k_i$个整数表示这个节点的子节点的编号</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅有一行，包含一个整数$ans$，表示最多能删除多少节点。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">10 4</span><br><span class="line">0 2 2 2 4 1 0 4 1 1</span><br><span class="line">3 6 2 3</span><br><span class="line">1 9</span><br><span class="line">1 8</span><br><span class="line">1 1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">2 7 4</span><br><span class="line">0</span><br><span class="line">1 5</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$30\%$的数据，$1 &lt; n &lt; 5 \times 10^3, 1 &lt; m &lt; 100, 0 &lt; c_i &lt; 100$</p><p>对于$70\%$的数据，$1 &lt; n &lt; 2 \times 10^5, 1 &lt; m &lt; 2000, 0 &lt; c_i &lt; 1000$</p><p>对于$100\%$的数据，$1 &lt; n &lt; 2 \times 10^6, 1 &lt; m &lt; 100000, 0 &lt; c_i &lt; 1000$</p><p>数据保证初始时，每个节点樱花数与儿子节点个数之和小于$m$</p><p>约定根节点不可以被删除，被删除的节点不计入总权重。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道贪心好题。</p><p>首先，对于除根节点外的每个节点$i$，我们删除它所需要的代价是$son_i + c_i$（即其儿子的数量加上其樱花数），这些代价会直接转移到它的父节点上。</p><p>而父节点的承受能力是有限的。每一次删除后，父节点的代价都会加上其被删去的子节点的代价，这个代价越接近与给出的上限$m$，我们就越难进行下一步操作。</p><p>因此我们要尽量让删去节点$i$后，其父节点的代价尽量的小。</p><p>综上，我们可得贪心方案：在删除时，每一个节点都删去自己的子节点中代价最少的那一个，然后更新自己的代价，直到不能删除为止。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , opt , ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N];</span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = Edge&#123;to , head[from]&#125;;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flower[N];</span><br><span class="line"><span class="keyword">int</span> son[N];</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span> , <span class="keyword">int</span> &gt; node[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[k]; i; i = edge[i].last)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        search(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[k]; i ; i = edge[i].last)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        node[num ++] = <span class="built_in">make_pair</span>(flower[to] + son[to] , to);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node , node + num);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> cut = node[i].second;</span><br><span class="line">        <span class="keyword">if</span>(flower[cut] + flower[k] + son[cut] + son[k] - <span class="number">1</span> &lt;= m)&#123;</span><br><span class="line">            flower[k] += flower[cut];</span><br><span class="line">            son[k] += son[cut] - <span class="number">1</span>;</span><br><span class="line">            ans ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span> , &amp;n , &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;flower[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;son[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= son[i]; j ++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;opt);</span><br><span class="line">            add_edge(i , opt + <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    search(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 各省省选 </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TJOI2010】阅读理解-题解</title>
      <link href="2019/10/10/luoguP3879/"/>
      <url>2019/10/10/luoguP3879/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>英语老师留了$N$篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典。</p><p>为了节约时间，现在需要你来做个统计，算一算某些生词都在哪几篇短文中出现过。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为整数$N$，表示短文篇数，其中每篇短文只含空格和小写字母。</p><p>按下来的$N$行，每行描述一篇短文。每行的开头是一个整数$L$，表示这篇短文由$L$个单词组成。接下来是$L$个单词，单词之间用一个空格分隔。</p><p>然后为一个整数$M$，表示要做$M$次询问。后面有$M$行，每行表示一个要统计的生词。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出$M$行，分别表示每个生词在哪几篇短文中出现过。并按从小到大输出短文的序号。序号之间用一个空格隔开</p><p>如果该单词一直没出现过，则仅输出一个空行即可。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">9 you are a good boy ha ha o yeah</span><br><span class="line">13 o my god you like bleach naruto one piece and so do i</span><br><span class="line">11 but i do not think you will get all the points</span><br><span class="line">5</span><br><span class="line">you</span><br><span class="line">i</span><br><span class="line">o</span><br><span class="line">all</span><br><span class="line">naruto</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$30\%$的数据，$1 ≤ M ≤ 10^3$</p><p>对于$100\%$的数据，$1 ≤ M ≤ 10^5，1 ≤ N ≤ 10^3$</p><p>每篇短文长度（含相邻单词之间的空格） $≤ 5,000$个字符，每个单词长度 $≤ 20$个字符</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>又是一道<code>Trie</code>树的模板</p><p>对于每篇文章，我们把它的每一个单词插入<code>Trie</code>树之中，之后用<code>bool</code>数组$flag[rt][i]$表示$rt$在第$i$篇文章中是否出现过。</p><p>查询时从小到大遍历每一篇文章(即$flag$数组的第二维)，如果被标记过，输出即可。</p><p>最后别忘了输出空行。</p><hr><p>$Upd$：后来有个老鸽传了一组数据，在空间上卡掉了用来判断是否出现的$flag$数组。针对这种做法，我们可以将其开为<code>bitset</code>。</p><p>这样的话，$flag$数组的空间大小就变成了原来的$\frac{1}{32}$，即可轻松通过本题。</p><p>以及，<code>bitset</code>使用之前需要添加<code>#include&lt;bitset&gt;</code></p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , k;</span><br><span class="line"><span class="built_in">bitset</span>&lt;1001&gt; flag[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Trie&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> son[<span class="number">26</span>];</span><br><span class="line">    &#125;node[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x , <span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length() , rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!node[rt].son[c])&#123;</span><br><span class="line">                node[rt].son[c] = ++ tot;</span><br><span class="line">            &#125;</span><br><span class="line">            rt = node[rt].son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        flag[rt][x] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> bj = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length() , rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!node[rt].son[c])&#123;</span><br><span class="line">                bj = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rt = node[rt].son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bj == <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag[rt][i])&#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">            Trie :: insert(i , str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        Trie :: find(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Trie树 </tag>
            
            <tag> 各省省选 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> Luogu </tag>
            
            <tag> bitset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Codeforces】New Year Snowmen-题解</title>
      <link href="2019/10/09/CF140C/"/>
      <url>2019/10/09/CF140C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>现在来做雪人，每个雪人由三个不同大小的雪球构成：一个大的，一个中等的，一个小的。</p><p>现在有$n$个雪球半径分别为$r_1, r_2, …, r_n$ </p><p>​为了做雪人，三个雪球的大小必须两两不同。例如，半径分别为 $1,2,3$ 的雪球可以做成雪人，但$2,2,3$或$2,2,2$就不行。请帮忙计算最多能做出的雪人数量。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个整数$n$，代表雪球的数量.</p><p>接下来一行有n个整数$r_1，r_2……r_i$，分别代表每个雪球的半径。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共$k + 1$行</p><p>第一行是一个数$k$,表示最大的雪人数. </p><p>接下来$k$行是每个雪人的描述，每行三个数，分别代表大雪球的半径，中等雪球的半径，小雪球的半径. </p><p>允许按任意顺序输出雪人描述. 如果有多种方案，输出任意一个</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 2 1</span><br><span class="line">6 5 4</span><br></pre></td></tr></table></figure><h3 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 2 3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于$100\%$的数据，保证$0 &lt; n &lt; 10^5$，$0 &lt; r_i &lt; 10^9$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道贪心好题。</p><p>考虑一种很显然的贪心：每一次取出出现次数最多的三种雪球。</p><p>由于数据大小高达$10^9$，因此，我们先对数据进行离散化。</p><p>之后使用优先队列维护雪球数量，每一次取出堆顶的$3$个元素，然后分别<code>-1</code>。如果还有剩余的雪球，就再次放入堆中。</p><p>时间复杂度$O(nlogn)$，足以跑过$10^5$的数据。</p><p>剩下的详见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ball</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ball &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number &lt; b.number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ball[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N] , b[N];</span><br><span class="line"><span class="keyword">int</span> ans_x[N] , ans_y[N] , ans_z[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Ball &gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span> , a + <span class="number">1</span> + n);</span><br><span class="line">    sort(b + <span class="number">1</span> , b + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> len = unique(b + <span class="number">1</span> , b + <span class="number">1</span> + n) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;)&#123;        <span class="comment">//离散化数据</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j + <span class="number">1</span> &lt;= n &amp;&amp; a[j + <span class="number">1</span>] == a[i])&#123;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> finish = j - i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = lower_bound(b + <span class="number">1</span> , b + <span class="number">1</span> + len , a[i]) - b; </span><br><span class="line">        Q.push((Ball)&#123;num , finish&#125;);</span><br><span class="line">        i = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q.size() &gt;= <span class="number">3</span>)&#123;       </span><br><span class="line">        Ball x = Q.top();       <span class="comment">//取出堆顶的元素</span></span><br><span class="line">        Q.pop();</span><br><span class="line">        Ball y = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        Ball z = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        x.number --;        </span><br><span class="line">        <span class="keyword">if</span>(x.number &gt; <span class="number">0</span>)&#123;       <span class="comment">//如果还有剩下的雪球，就放回堆中。</span></span><br><span class="line">            Q.push((Ball)&#123;x.id , x.number&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        y.number --;</span><br><span class="line">        <span class="keyword">if</span>(y.number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            Q.push((Ball)&#123;y.id , y.number&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        z.number --; </span><br><span class="line">        <span class="keyword">if</span>(z.number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            Q.push((Ball)&#123;z.id , z.number&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ans ++;</span><br><span class="line">        ans_x[ans] = b[x.id];</span><br><span class="line">        ans_y[ans] = b[y.id];      <span class="comment">//统计答案</span></span><br><span class="line">        ans_z[ans] = b[z.id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ans; i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tt[<span class="number">3</span>];      </span><br><span class="line">        tt[<span class="number">0</span>] = ans_x[i], tt[<span class="number">1</span>] = ans_y[i], tt[<span class="number">2</span>] = ans_z[i];</span><br><span class="line">        sort(tt, tt + <span class="number">3</span>);       <span class="comment">//输出前排序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, tt[<span class="number">2</span>], tt[<span class="number">1</span>], tt[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>没错，这又是一道提交了很多次的题目。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/09/MfG2rYBCR7ekyUV.png" alt="New Year Snowman.png"></p><p>其中大部分错误还都是zz错误，包括忘记离散化，排序时仅排了一个数组，输出前不排序等……</p><p>因此，这又是一个提升的机会。</p><p>希望下次不要再犯这种zz错误了……</p><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> Codeforces </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷题库】于是他错误的点名开始了-题解</title>
      <link href="2019/10/09/luoguP2580/"/>
      <url>2019/10/09/luoguP2580/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p><code>XS</code>中学化学竞赛组教练是一个酷爱炉石的人。</p><p>他会一边搓炉石一边点名以至于有一天他连续点到了某个同学两次，然后正好被路过的校长发现了然后就是一顿欧拉欧拉欧拉……。</p><hr><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>这之后校长任命你为特派探员，每天记录他的点名。</p><p>校长会提供化学竞赛学生的人数和名单，而你需要告诉校长他有没有点错名。<del>（为什么不直接不让他玩炉石。）</del></p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$，表示班上人数。</p><p>接下来 $n$ 行，每行一个字符串表示每个人的名字。</p><p>第 $n+2$ 行一个整数 $m$，表示教练报的名字数量。</p><p>接下来 $m$ 行，每行一个字符串表示教练报的名字</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个教练报的名字，输出一行。</p><p>如果该名字正确且是第一次出现，输出<code>OK</code>.</p><p>如果该名字错误，输出<code>WRONG</code>.</p><p>如果该名字正确但不是第一次出现，输出<code>REPEAT</code>。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5  </span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">ad</span><br><span class="line">acd</span><br><span class="line">3</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">e</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">OK</span><br><span class="line">REPEAT</span><br><span class="line">WRONG</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $40\%$的数据，$n≤1000,m≤2000$；</p><p>对于 $70\%$的数据，$n≤10000,m≤20000$；</p><p>对于 $100\%$的数据， $n≤10000，m≤100000$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>Trie树的版子题。</p><p><del>当然你也可以用<code>map</code>轻易水过</del></p><p>建立一颗以26个字母为子节点的Trie树，然后直接寻找子串出现次数即可。</p><p>其他的详见代码注释。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Trie&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> son[<span class="number">27</span>];    <span class="comment">//可能出现的子节点，一共从a到z共26</span></span><br><span class="line">        <span class="keyword">int</span> cnt;        <span class="comment">//cnt 有多少个以当前节点结尾的字符串</span></span><br><span class="line">        <span class="keyword">int</span> size;       <span class="comment">//size 有多少个字符串以当前节点为前缀</span></span><br><span class="line">        <span class="keyword">int</span> number;     <span class="comment">//点名的次数</span></span><br><span class="line">    &#125;node[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;      <span class="comment">//向Trie树中插入一个字符串</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length() , rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;     </span><br><span class="line">            <span class="keyword">if</span>(!node[rt].son[c])&#123;</span><br><span class="line">                node[rt].son[c] = ++ tot;   <span class="comment">//如果没有这个字母，就插入</span></span><br><span class="line">            &#125;</span><br><span class="line">            rt = node[rt].son[c];   <span class="comment">//向下转移</span></span><br><span class="line">            node[rt].size ++;</span><br><span class="line">        &#125;</span><br><span class="line">        node[rt].cnt ++;    <span class="comment">//统计答案，以当前节点结尾的字符串 + 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length() , rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!node[rt].son[c])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">//如果有一位找不到了，直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            rt = node[rt].son[c];       <span class="comment">//向下转移</span></span><br><span class="line">        &#125;</span><br><span class="line">        node[rt].number ++;     <span class="comment">//被多叫到了一次</span></span><br><span class="line">        <span class="keyword">return</span> node[rt].number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Trie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        insert(q);  <span class="comment">//把名字插入Trie树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> num = find(q);  </span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;   <span class="comment">//如果找不到这个名字</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;WRONG&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;  <span class="comment">//如果是第一次叫到</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;           <span class="comment">//如果被叫到很多次了</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;REPEAT&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Trie树 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【成长之路】Payphone-X的zz错误</title>
      <link href="2019/10/08/zz-mistake/"/>
      <url>2019/10/08/zz-mistake/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="忘记初始化"><a href="#忘记初始化" class="headerlink" title="忘记初始化"></a>忘记初始化</h2><p>写并查集时自作多情写了个<code>Start()</code>，然后……没调用。</p><hr><h2 id="合并并查集时不加find"><a href="#合并并查集时不加find" class="headerlink" title="合并并查集时不加find"></a>合并并查集时不加find</h2><p>事实上，我的并查集合并一直是这么写的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    pre[a] = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但正确的写法应该是这样</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(find(a) != find(b))&#123;</span><br><span class="line">        pre[find(a)] = find(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h2 id="排序时把n和m弄反"><a href="#排序时把n和m弄反" class="headerlink" title="排序时把n和m弄反"></a>排序时把n和m弄反</h2><p>不多说，说多都是泪。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(EDGE + <span class="number">1</span> , EDGE + <span class="number">1</span> + n , cmp);    <span class="comment">//Wrong!!!</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(find(EDGE[i].from) != find(EDGE[i].to))&#123;</span><br><span class="line">            merge(EDGE[i].from , EDGE[i].to);</span><br><span class="line">            add_edge(EDGE[i].from , EDGE[i].to , EDGE[i].dis);</span><br><span class="line">            add_edge(EDGE[i].to , EDGE[i].from , EDGE[i].dis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="写LCA不比较最后一步"><a href="#写LCA不比较最后一步" class="headerlink" title="写LCA不比较最后一步"></a>写LCA不比较最后一步</h2><p>在<a href="https://www.luogu.org/problem/P1967">Luogu P1967 货车运输</a>一题中，作者写了以下的<code>LCA</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(find(x) != find(y))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y])&#123;</span><br><span class="line">        swap(x , y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[fa[y][i]] &gt;= dep[x])&#123;</span><br><span class="line">            ans = min(ans , val[y][i]);   </span><br><span class="line">            y = fa[y][i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y)&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i] != fa[y][i])&#123;</span><br><span class="line">        ans = min(ans , min(val[x][i] , val[y][i]));</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">            y = fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;     \\Wrong!!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但事实上，正确的写法是这样的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(find(x) != find(y))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y])&#123;</span><br><span class="line">        swap(x , y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[fa[y][i]] &gt;= dep[x])&#123;</span><br><span class="line">            ans = min(ans , val[y][i]);   </span><br><span class="line">            y = fa[y][i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y)&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i] != fa[y][i])&#123;</span><br><span class="line">        ans = min(ans , min(val[x][i] , val[y][i]));</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">            y = fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(ans, min(val[x][<span class="number">0</span>], val[y][<span class="number">0</span>]));     <span class="comment">//需要比较最后一步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="不写retuen"><a href="#不写retuen" class="headerlink" title="不写retuen"></a>不写retuen</h2><p>考场上写<code>Exgcd</code>忘了<code>return</code>，导致死递归。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x , y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//Wrong!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b , a % b);</span><br><span class="line">    <span class="keyword">int</span> tx = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tx - a / b * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="邻接表不开两倍空间"><a href="#邻接表不开两倍空间" class="headerlink" title="邻接表不开两倍空间"></a>邻接表不开两倍空间</h2><p>经典错误，不解释。</p><hr><h2 id="离散化后不调用"><a href="#离散化后不调用" class="headerlink" title="离散化后不调用"></a>离散化后不调用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ans_x[ans] = x.id;  <span class="comment">//Wrong!!!</span></span><br><span class="line">ans_y[ans] = y.id;  <span class="comment">//Wrong!!!</span></span><br><span class="line">ans_z[ans] = z.id;  <span class="comment">//Wrong!!!</span></span><br></pre></td></tr></table></figure><p>上面的写法等于没离散化，正确的写法是这样的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ans_x[ans] = b[x.id];</span><br><span class="line">ans_y[ans] = b[y.id];</span><br><span class="line">ans_z[ans] = b[z.id];</span><br></pre></td></tr></table></figure><hr><h2 id="读错题目"><a href="#读错题目" class="headerlink" title="读错题目"></a>读错题目</h2><p>在<a href="https://www.luogu.org/problem/CF140C">CF140C</a>中，题目要求顺序输出，但我没看到……</p><p>于是……</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/09/MfG2rYBCR7ekyUV.png" alt="New Year Snowman.png"></p><hr><h2 id="比较时不加绝对值"><a href="#比较时不加绝对值" class="headerlink" title="比较时不加绝对值"></a>比较时不加绝对值</h2><p>在之前的一场考试中，作者在比较路程长度时没有加绝对值，导致走的路程出现了负数……</p><p>然后……就没有然后了……</p><hr><h2 id="读错题目-X-2"><a href="#读错题目-X-2" class="headerlink" title="读错题目 X 2"></a>读错题目 X 2</h2><p>在打<a href="http://codeforces.com/contest/1244">Codeforces Round #592 Div2</a>时，作者再次读错题目，以为B题是一个类似于双端搜索的难题。</p><p>然后……就没有然后了……</p><hr><h2 id="开小数组"><a href="#开小数组" class="headerlink" title="开小数组"></a>开小数组</h2><p>在记录从矩阵左上角到右下角的路径时，作者忘记开两倍数组……</p><p>于是乎……</p><blockquote><p>100 -&gt; 70<br>Rank 4 -&gt; Rank 15</p></blockquote><hr><h2 id="使用不关流的cin读入大数据"><a href="#使用不关流的cin读入大数据" class="headerlink" title="使用不关流的cin读入大数据"></a>使用不关流的cin读入大数据</h2><p>RT.</p><blockquote><p>100 -&gt; 50<br>Rank 3 -&gt; Rank 9</p></blockquote><p><del>自闭……</del></p><hr><h2 id="inf设小"><a href="#inf设小" class="headerlink" title="inf设小"></a>inf设小</h2><p>RT.</p><blockquote><p>100 -&gt; 30<br>Rank 2 -&gt; Rank 16</p></blockquote><hr><h2 id="树剖最后一步写错"><a href="#树剖最后一步写错" class="headerlink" title="树剖最后一步写错"></a>树剖最后一步写错</h2><p>在某次比赛中，作者写了如下的树剖查询</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_opposite</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tp[x] != tp[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[tp[x]] &lt; dep[tp[y]])&#123;</span><br><span class="line">            swap(x , y);</span><br><span class="line">        &#125;</span><br><span class="line">        Segment_tree :: range_opposite(<span class="number">1</span> , dfn[tp[x]] , dfn[x]);</span><br><span class="line">        x = fa[tp[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[tp[x]] &gt; dep[tp[y]]) swap(x , y);    <span class="comment">//Wrong!!!</span></span><br><span class="line">        Segment_tree :: range_opposite(<span class="number">1</span> , dfn[x] + <span class="number">1</span> , dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而正确的写法是这样的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_opposite</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tp[x] != tp[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[tp[x]] &lt; dep[tp[y]])&#123;</span><br><span class="line">            swap(x , y);</span><br><span class="line">        &#125;</span><br><span class="line">        Segment_tree :: range_opposite(<span class="number">1</span> , dfn[tp[x]] , dfn[x]);</span><br><span class="line">        x = fa[tp[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[x] &gt; dep[y]) swap(x , y);</span><br><span class="line">        Segment_tree :: range_opposite(<span class="number">1</span> , dfn[x] + <span class="number">1</span> , dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="To-Be-Continue"><a href="#To-Be-Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h1><p><del>希望哪天真的能THE END</del></p>]]></content>
      
      
      <categories>
          
          <category> 成长之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结篇 </tag>
            
            <tag> 成长之路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOIP2013】货车运输-题解</title>
      <link href="2019/10/08/luoguP1967/"/>
      <url>2019/10/08/luoguP1967/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>$A$国有$n$座城市，编号从 $1$到$n$，城市之间有 $m$ 条双向道路。</p><p>每一条道路对车辆都有重量限制，简称限重。</p><p>现在有 $q$ 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个用一个空格隔开的整数$n$,$m$,表示 $A$ 国有$n$ 座城市和 $m$ 条道路。</p><p>接下来 $m$行每行$3$个整数 $x$, $y$, $z$,每两个整数之间用一个空格隔开，表示从$x$号城市到$y$号城市有一条限重为 $z$ 的道路。注意：$x$ 不等于 $y$，两座城市之间可能有多条道路。</p><p>接下来一行有一个整数 $q$，表示有 $q$ 辆货车需要运货。</p><p>接下来 $q$ 行，每行两个整数 $x$、$y$，之间用一个空格隔开，表示一辆货车需要从 $x$ 城市运输货物到 $y$ 城市，注意:$x$ 不等于 $y$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共有 $q$ 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。</p><p>如果货车不能到达目的地，输出$−1$。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2 4</span><br><span class="line">2 3 3</span><br><span class="line">3 1 1</span><br><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">-1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>对于 $30\%$的数据，$0 &lt; n &lt; 1,000,0 &lt; m &lt; 10,000,0 &lt; q&lt; 1,0000$</p><p>对于 $60\%$的数据，$0 &lt; n &lt; 1,000,0 &lt; m &lt; 50,000,0 &lt; q&lt; 1,0000$</p><p>对于 $100\%$的数据，$0 &lt; n &lt; 10,000,0 &lt; m &lt; 50,000,0 &lt; q&lt; 30,000,0 ≤ z ≤ 100,0000$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最大生成树 + 倍增$LCA$</p><p>首先，我们很容易看出有一些边权很小的边（即限重很小的边）是永远不会被走过的。因此，我们可以求一颗最大生成树。</p><p>之后我们需要寻找给出两点之间的路径。又因为在生成树上，两点间的路径唯一。so……我们只需找到这条路径上边权最大的边即可。</p><p>我们可以使用最近公共祖先来实现这个过程：首先对最大生成树的每一个节点进行遍历，求出深度等相关信息，之后利用他们进行倍增。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , s;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge1</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from , to;</span><br><span class="line">    ll dis;</span><br><span class="line">&#125;EDGE[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge1 a , Edge1 b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dis &gt; b.dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    ll dis;</span><br><span class="line">&#125;edge[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , ll dis)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = Edge&#123;to , head[from] , dis&#125;;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[root] == root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pre[root] = find(pre[root]);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    pre[find(a)] = find(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(EDGE + <span class="number">1</span> , EDGE + <span class="number">1</span> + m , cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(find(EDGE[i].from) != find(EDGE[i].to))&#123;</span><br><span class="line">            merge(EDGE[i].from , EDGE[i].to);</span><br><span class="line">            add_edge(EDGE[i].from , EDGE[i].to , EDGE[i].dis);</span><br><span class="line">            add_edge(EDGE[i].to , EDGE[i].from , EDGE[i].dis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> dep[N];</span><br><span class="line">ll val[N][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x] ; i ; i = edge[i].last)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(vis[to])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fa[to][<span class="number">0</span>] = x;</span><br><span class="line">        dep[to] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        val[to][<span class="number">0</span>] = edge[i].dis;</span><br><span class="line">        search(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(find(x) != find(y))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y])&#123;</span><br><span class="line">        swap(x , y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[fa[y][i]] &gt;= dep[x])&#123;</span><br><span class="line">            ans = min(ans , val[y][i]);   </span><br><span class="line">            y = fa[y][i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y)&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i] != fa[y][i])&#123;</span><br><span class="line">        ans = min(ans , min(val[x][i] , val[y][i]));</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">            y = fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(ans, min(val[x][<span class="number">0</span>], val[y][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u , v , d;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; d;</span><br><span class="line">        EDGE[i].from = u;</span><br><span class="line">        EDGE[i].to = v;</span><br><span class="line">        EDGE[i].dis = d;</span><br><span class="line">    &#125;</span><br><span class="line">    Kruskal();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            dep[i] = <span class="number">1</span>;</span><br><span class="line">            search(i);</span><br><span class="line">            fa[i][<span class="number">0</span>] = i;</span><br><span class="line">            val[i][<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= log2(n); j ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">            val[i][j] = min(val[i][j - <span class="number">1</span>] , val[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; LCA(u , v) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实在我写这题之前我就已经口胡出了这题的解法，并且在<code>QBOI</code>，<code>SDSC</code>，<code>ZROI</code>等集训中上台切了三次。</p><p>但在写代码时，仍然出现了许多zz错误。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/08/OGzARZyItNMbsuK.png" alt="货车运输.png"></p><p>其中，除第一次错误是由于调试问题所导致外，其他错误都是像没<code>return</code>，没有比较<code>LCA</code>的最后一步，把$m$打成$n$等zz错误所导致。</p><p>这再次印证了我代码能力差，是个口胡选手的事实。</p><p>因此，我决定公开我写代码时的zz错误，一是提醒自己，二是让更多人看到这份记录，以免和我犯同样的错误。</p><p>最后，希望大家可以以此为戒，不要像我一样只会口胡不会做题。</p><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> Luogu </tag>
            
            <tag> NOIP </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【福建省历届夏令营】没有上司的舞会-题解</title>
      <link href="2019/10/06/luoguP1352/"/>
      <url>2019/10/06/luoguP1352/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>某大学有$N$个职员，编号为$1~N$。</p><p>他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。</p><p>现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数$R_i$.</p><p>但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。</p><p>所以，请你编程计算，邀请哪些职员可以使快乐指数最大，并求出最大的快乐指数。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$N$。</p><p>接下来$N$行，第$i+1$行表示$i$号职员的快乐指数$R_i$。</p><p>接下来$N-1$行，每行输入一对整数$L$,$K$。表示$K$是$L$的直接上司。</p><p>最后一行输入$0$ $0$</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出只有一行，为一个整数$ans$，表示最大的快乐指数。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">6 4</span><br><span class="line">7 4</span><br><span class="line">4 5</span><br><span class="line">3 5</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>树形$dp$入门经典</p><p>设$f[i][01]$表示第$i$个人来与不来时的最大欢乐值，第二维为$0$表示他不来，$1$表示他来。</p><p>如果他来，则他的下属们都不会来，因此我们只需要加上他的欢乐指数。即</p><script type="math/tex; mode=display">f[i][1] = f[son][0] + r[i]</script><p>如果他不来，则他的下属们可以来也可以不来(因为下属可能也是别人的领导，所以下属全都来并不一定是最好的)。因此我们需要在这之中取一个$Max$，即</p><script type="math/tex; mode=display">f[i][0] = max(f[son][0] , f[son][1])</script><p>在输入时，开一个数组记录没有上司的那个人，则那个人就是校长，记为$root$。则最后的答案就是$max(f[root][0] , f[root][1])$</p><p>是不是很简单啊(逃 ~ </p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N];</span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = Edge&#123;to , head[from]&#125;;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> happy[N];</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x] ; i ; i = edge[i].last)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        dp(to);</span><br><span class="line">        f[x][<span class="number">1</span>] += f[to][<span class="number">0</span>];</span><br><span class="line">        f[x][<span class="number">0</span>] += max(f[to][<span class="number">0</span>] , f[to][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][<span class="number">1</span>] += happy[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; happy[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u , v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        fa[u] ++;</span><br><span class="line">        <span class="keyword">if</span>(u != <span class="number">0</span> &amp;&amp; v != <span class="number">0</span>)&#123;</span><br><span class="line">            add_edge(v , u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(f[root][<span class="number">1</span>] , f[root][<span class="number">0</span>]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形dp </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】ODT(珂朵莉树)</title>
      <link href="2019/10/04/Chtholly-Tree/"/>
      <url>2019/10/04/Chtholly-Tree/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>多学一点数据结构一般是有好处的，至少可以帮你打暴力<br>                                   ——Wei_taming</p></blockquote><p>因此，作者开始补习<del>DL</del>数据结构</p><hr><h2 id="什么是珂朵莉？"><a href="#什么是珂朵莉？" class="headerlink" title="什么是珂朵莉？"></a>什么是珂朵莉？</h2><p>珂朵莉是世界上最幸福的女孩子，没有之一，不接受任何反驳！</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/06/BsXjzCTKk3uDLmv.png" alt="Chtholly.png"></p><hr><h2 id="什么是珂朵莉树？"><a href="#什么是珂朵莉树？" class="headerlink" title="什么是珂朵莉树？"></a>什么是珂朵莉树？</h2><p>珂朵莉树原名<code>ODT(Ord Driver Tree)</code>，即老司机树。是一种基于<code>set</code>的暴力数据结构，起源于<a href="https://codeforces.com/problemset/problem/896/C">Codeforces-896C</a></p><p>其原理在于使用<code>STL</code>中的<code>set</code>来维护一段连续的相同元素。</p><p>它的时间复杂度其实是假的，但在数据随机时可以有很好的表现。</p><p>而且珂朵莉树使用的局限性较大，如果没有<strong>区间赋值</strong>操作，则珂朵莉树就毫无用武之地。</p><p>因此，珂朵莉树大部分情况用于骗分。</p><hr><h2 id="珂朵莉树的核心操作"><a href="#珂朵莉树的核心操作" class="headerlink" title="珂朵莉树的核心操作"></a>珂朵莉树的核心操作</h2><h3 id="定义节点"><a href="#定义节点" class="headerlink" title="定义节点"></a>定义节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l , r;</span><br><span class="line">    <span class="keyword">mutable</span> ll val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; b.l</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;Node &gt; S;</span><br></pre></td></tr></table></figure><p>在上面的代码中，每一个<code>Node</code>都是在维护一段连续的区间，这些区间的大小不等。</p><p>其中，$l$代表区间左端点，$r$代表区间右端点，$val$代表当前这段区间每一个元素的值.</p><p>顺带提一句，<code>mutable</code>可以直接对迭代器进行修改而不影响里边的值。</p><p>最后重载运算符，调整每一个节点在<code>set</code>中的存储顺序。</p><p>这样，我们就完成了珂朵莉树的节点创建。</p><hr><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>对于建树，我们只需要把区间中的每一个数看做一段长度为$1$的区间，然后暴力插入即可</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll a[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        s.insert((Node)&#123;i , i , a[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="分裂-Spilt"><a href="#分裂-Spilt" class="headerlink" title="分裂(Spilt)"></a>分裂(Spilt)</h3><p>$Spilt(pos)$操作可以将含有$pos$位置的区间分为两部分，分别为$[1 , pos - 1]$与$[pos , r]$</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> range set<span class="meta-string">&lt;Node &gt; S :: iterator</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">range <span class="title">spilt</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    range it = S.lower_bound((Node)&#123;pos , pos , <span class="number">-1</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span>(it != S.end() &amp;&amp; it -&gt; l == pos)&#123;</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line">    it --;</span><br><span class="line">    Node ins = *it;</span><br><span class="line">    S.erase(it);</span><br><span class="line">    S.insert((Node)&#123;ins.l , pos - <span class="number">1</span> , ins.val&#125;);</span><br><span class="line">    <span class="keyword">return</span> S.insert((Node)&#123;pos , ins.r , ins.val&#125;).first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数的返回值为一个迭代器，代表从$[pos , r]$这一段区间，方便之后的操作。</p><p>在函数的开头，我们需要寻找第一个左端点$l$大于等于$pos$的节点。</p><p>之后对其进行特判：如果说找到的这段区间不在珂朵莉树的末尾，而且找到的这个节点的$l = pos$,则证明我们找到了这个节点，直接返回即可。</p><p>否则，则刚刚找到的这个节点的$l$一定大于$pos$（我们使用的是<code>lower_bound</code>，找到的那段区间的$l$一定大于等于$pos$，而等于的情况已经被我们特判掉）。因此我们需要返回到上一段区间进行寻找。</p><p>之后需要一个替代变量$ins$存储我们刚刚找到的区间，然后将原来的的区间删掉，再插入$[l , pos - 1]$与$[pos , r]$，最后返回以$pos$为左端点$l$的区间，即$[pos , r]$。</p><p>现在，我们就完成了珂朵莉树的分裂操作。</p><hr><h3 id="区间推平-Assign"><a href="#区间推平-Assign" class="headerlink" title="区间推平(Assign)"></a>区间推平(Assign)</h3><p>现在，我们已经可以轻松分裂一颗珂朵莉树。</p><p>但随着珂朵莉树的不断分裂，<code>set</code>中的元素也会渐渐增多，从而不断增大珂朵莉树的时间复杂度。</p><p>因此，我们还需要$Assign$来降低时间复杂度。</p><p>$Assign$操作的用处在于推平一段区间，说白了，就是将一个区间全部修改为一个值，从而合并珂朵莉树。</p><p>在数据随机的情况下，$Assign$操作的出现频率并不小，大约在$\frac{1}{3}$上下。而且$Assign$操作可以一次合并多个节点，可以将<code>set</code>的大小控制在一个可控的范围之内。因此，$Assign$操作是珂朵莉树的重要保证。</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l  , <span class="keyword">int</span> r , ll val)</span></span>&#123;</span><br><span class="line">    range R = spilt(r + <span class="number">1</span>);         </span><br><span class="line">    range L = spilt(l);     </span><br><span class="line">    S.erase(L , R);</span><br><span class="line">    S.insert(Node&#123;l , r , val&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们分别分裂左右区间。(要注意，这里需要<strong>先分裂右区间</strong>。因为在分离左区间时会导致迭代器失效，若这时强行分裂，会导致程序$RE$)</p><p>之后我们分别删除我们分离出来的左右区间，最后将整段区间加入即可。</p><hr><h2 id="珂朵莉树的其他操作"><a href="#珂朵莉树的其他操作" class="headerlink" title="珂朵莉树的其他操作"></a>珂朵莉树的其他操作</h2><p>下面我们就以珂朵莉树的起源:<a href="https://codeforces.com/problemset/problem/896/C">Codeforces-896C</a>为例，讲解珂朵莉树的其他操作。</p><h3 id="区间加"><a href="#区间加" class="headerlink" title="区间加"></a>区间加</h3><p>直接分裂出区间端点，然后暴力解决即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_add</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    range R = spilt(r + <span class="number">1</span>);</span><br><span class="line">    range L = spilt(l);</span><br><span class="line">    <span class="keyword">for</span>(range i = L; i != R; i ++)&#123;</span><br><span class="line">        i -&gt; val += val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="区间快速幂之和"><a href="#区间快速幂之和" class="headerlink" title="区间快速幂之和"></a>区间快速幂之和</h3><p>即求：<script type="math/tex">\sum_{i = 1}^{r} a^x_i</script></p><p>对每一段区间暴力快速幂即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll a , ll n , ll HA)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a % HA;</span><br><span class="line">    &#125;</span><br><span class="line">    ll c = Pow(a , n / <span class="number">2</span> , HA);</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> c * c % HA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (c * c * a) % HA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">range_pow</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , ll val , ll HA)</span></span>&#123;</span><br><span class="line">    range R = spilt(r + <span class="number">1</span>);</span><br><span class="line">    range L = spilt(l);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(range i = L; i != R; i ++)&#123;</span><br><span class="line">        ans += (ll)(i -&gt; r - i -&gt; l + <span class="number">1</span>) * Pow(i -&gt; v , val , HA);</span><br><span class="line">        ans %= HA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="区间第k大"><a href="#区间第k大" class="headerlink" title="区间第k大"></a>区间第k大</h3><p>原理也很简单，就是把那段区间的元素丢入一个<code>vector</code>，然后排序。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">range_query</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pairs pair<span class="meta-string">&lt;ll , int&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;pairs &gt; V;</span><br><span class="line">    V.clear();</span><br><span class="line">    range R = spilt(r + <span class="number">1</span>);</span><br><span class="line">    range L = spilt(l);</span><br><span class="line">    <span class="keyword">for</span>(range i = L; i != R; i ++)&#123;</span><br><span class="line">        V.push_back(pairs(i -&gt; val , i -&gt; r - i -&gt; l + <span class="number">1</span>));</span><br><span class="line">    &#125; </span><br><span class="line">    sort(V.begin() , V.end());</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pairs &gt; :: iterator i = V.begin(); i != V.end(); i ++)&#123;</span><br><span class="line">        sum += i -&gt; second;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= k)&#123;</span><br><span class="line">            <span class="keyword">return</span> i -&gt; first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="操作模板"><a href="#操作模板" class="headerlink" title="操作模板"></a>操作模板</h3><p>不知道大家看出来了没有，珂朵莉树的操作大部分是有模板可以套的。</p><p>模板如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    range R = spilt(r + <span class="number">1</span>);</span><br><span class="line">    range L = spilt(l);</span><br><span class="line">    <span class="keyword">for</span>(range i = L; i != R; i ++)&#123;</span><br><span class="line">        ………………</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Code-Ctholly-Tree"><a href="#Code-Ctholly-Tree" class="headerlink" title="Code[Ctholly Tree]"></a>Code[Ctholly Tree]</h2><p>最后放上珂朵莉树起源的代码好了<del>（为啥我觉得一半代码都在写数据生成器？？？）</del></p><p>题目链接:<a href="https://codeforces.com/problemset/problem/896/C">Codeforces-896C</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , s;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ODT&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> range set<span class="meta-string">&lt;Node&gt; :: iterator</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> l , r;</span><br><span class="line">        <span class="keyword">mutable</span> ll val;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> l &lt; b.l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;                       </span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;Node &gt; S; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            S.insert(Node&#123;i , i , a[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">range <span class="title">spilt</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        range it = S.lower_bound((Node)&#123;pos , pos , <span class="number">-1</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span>(it != S.end() &amp;&amp; it -&gt; l == pos)&#123;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line">        it --;</span><br><span class="line">        Node ins = *it;</span><br><span class="line">        S.erase(it);</span><br><span class="line">        S.insert((Node)&#123;ins.l , pos - <span class="number">1</span> , ins.val&#125;);</span><br><span class="line">        <span class="keyword">return</span> S.insert((Node)&#123;pos , ins.r , ins.val&#125;).first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l  , <span class="keyword">int</span> r , ll val)</span></span>&#123;</span><br><span class="line">        range R = spilt(r + <span class="number">1</span>);</span><br><span class="line">        range L = spilt(l);</span><br><span class="line">        S.erase(L , R);</span><br><span class="line">        S.insert(Node&#123;l , r , val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">range_add</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        range R = spilt(r + <span class="number">1</span>);</span><br><span class="line">        range L = spilt(l);</span><br><span class="line">        <span class="keyword">for</span>(range i = L; i != R; i ++)&#123;</span><br><span class="line">            i -&gt; val += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">Pow</span><span class="params">(ll a , ll n , ll HA)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a % HA;</span><br><span class="line">        &#125;</span><br><span class="line">        ll c = Pow(a , n / <span class="number">2</span> , HA) % HA;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (c * c) % HA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  (((c * c) % HA) * a) % HA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">range_pow</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , ll val , ll HA)</span></span>&#123;</span><br><span class="line">        range R = spilt(r + <span class="number">1</span>);</span><br><span class="line">        range L = spilt(l);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(range i = L; i != R; i ++)&#123;</span><br><span class="line">            ans += (ll)(i -&gt; r - i -&gt; l + <span class="number">1</span>) * Pow(i -&gt; val , val , HA);</span><br><span class="line">            ans %= HA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">range_query</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> pairs pair<span class="meta-string">&lt;ll , int&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;pairs &gt; V;</span><br><span class="line">        V.clear();</span><br><span class="line">        range R = spilt(r + <span class="number">1</span>);</span><br><span class="line">        range L = spilt(l);</span><br><span class="line">        <span class="keyword">for</span>(range i = L; i != R; i ++)&#123;</span><br><span class="line">            V.push_back(pairs(i -&gt; val , i -&gt; r - i -&gt; l + <span class="number">1</span>));</span><br><span class="line">        &#125; </span><br><span class="line">        sort(V.begin() , V.end());</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pairs &gt; :: iterator i = V.begin(); i != V.end(); i ++)&#123;</span><br><span class="line">            sum += i -&gt; second;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= k)&#123;</span><br><span class="line">                <span class="keyword">return</span> i -&gt; first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll seed, vmax;</span><br><span class="line"></span><br><span class="line"><span class="function">I ll <span class="title">rnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ret = seed;</span><br><span class="line">    seed = (seed * <span class="number">7</span> + <span class="number">13</span>) % <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; seed &gt;&gt; vmax;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        ODT::S.insert(ODT :: Node&#123;i, i, (rnd() % vmax) + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        ll op = (rnd() % <span class="number">4</span>) + <span class="number">1</span>, l = (rnd() % n) + <span class="number">1</span>, r = (rnd() % n) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)&#123;</span><br><span class="line">            swap(l , r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">3</span>)&#123;</span><br><span class="line">            x = (rnd() %(r - l + <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            x = (rnd() % vmax) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">4</span>)&#123;</span><br><span class="line">            y = (rnd() % vmax) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                ODT :: range_add(l, r, x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                ODT :: assign(l, r, x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ODT :: range_query(l, r, x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ODT :: range_pow(l, r, x, y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 暴力 </tag>
            
            <tag> 珂朵莉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考场技巧】对拍的应用</title>
      <link href="2019/09/17/same/"/>
      <url>2019/09/17/same/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>周五晚上(2019/9/13)，作者打了一场比赛，结果因为写了一个假的对拍而导致$DP$爆零。</p><p>因此，就有了这篇文章。</p><hr><h2 id="对拍的组成"><a href="#对拍的组成" class="headerlink" title="对拍的组成"></a>对拍的组成</h2><p>对拍程序一般由$4$个部分组成，分别是暴力程序，正解，数据生成器，对拍器。</p><p>其中，<strong>暴力程序必须保证其正确性</strong>。</p><hr><h2 id="对拍的写法"><a href="#对拍的写法" class="headerlink" title="对拍的写法"></a>对拍的写法</h2><p>此程序在<code>Windows 10 1903</code>版本下亲测可用，如果您使用的电脑系统为<code>Mac</code>或<code>Ubuntu</code>，请自行修改。</p><p><strong>Code：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll num , s , t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">num ++;</span><br><span class="line">system(<span class="string">&quot;data.exe&quot;</span>);</span><br><span class="line">s = clock();</span><br><span class="line">system(<span class="string">&quot;a.exe&quot;</span>);</span><br><span class="line">t = clock();</span><br><span class="line">system(<span class="string">&quot;b.exe&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(system(<span class="string">&quot;fc try1.out try2.out&quot;</span>))&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;AC time&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t - s &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;AC&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;WA time&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t - s &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;WA&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">system(<span class="string">&quot;fc try1.out try2.out&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause &gt; nul&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><del>不用理解，直接背就行</del></p><h2 id="对拍的使用"><a href="#对拍的使用" class="headerlink" title="对拍的使用"></a>对拍的使用</h2><p>首先，你需要在自己的桌面上建立一个名为<code>Same</code>的文件夹</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/17/8eVfHTrwXDAKBvb.jpg" alt="Same.jpg"></p><p><code>Same</code>文件夹内需要包含$4$个文件，分别是您的暴力，正解，数据生成器和对拍程序。在这里对应文件夹中的<code>a.cpp</code>,<code>b.cpp</code>,<code>data.cpp</code>,<code>Same.cpp</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/17/sEckjvVpXT492Im.jpg" alt="Same2.jpg"></p><p>其中，<code>a.cpp</code>与<code>b.cpp</code>需要加上文件输入输出，读入的文件均为<code>try.in</code>，输出的文件分别为<code>try1.out</code>与<code>try2.out</code>，<code>data.cpp</code>需要向<code>try.in</code>中输入数据。</p><p>在一切就绪之后，我们运行<code>a.cpp</code>，<code>b.cpp</code>，<code>data.cpp</code>，这时，文件夹里会多出以下文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/17/dzf8ABpTn5QbuF9.jpg" alt="Same3.jpg"></p><p>之后运行<code>Same.cpp</code>，这时，对拍程序即开始运行。如果对拍成功，会显示以下界面</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/17/UmGDBkQuqyLX6cx.jpg" alt="AC.jpg"></p><p>如果出现错误，会显示以下界面：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/17/CwKQkapJjNlOuiH.jpg" alt="WA.jpg"></p><p>这时，我们就可以收集<code>try.in</code>中的数据，用来调试我们的正解。</p><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>但要注意，对拍只可以对小数据进行调试，暴力无法跑出大数据。</p><p>因此，我们要注意对于边界条件的检查与把控，不要出现数组越界的情况。</p><p>另外，对拍不一定能随机到有强度的数据，特别是在图论题中。</p><p>因此，对于数据量小的极限数据，我们还是要自己手动制作。</p><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 考场技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 考场技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学】数学杂烩</title>
      <link href="2019/09/10/math2/"/>
      <url>2019/09/10/math2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>众所周知，数论是OI中很重要的一部分。</p><p>然而作为一个即将初赛的$CSP-S$选手，我基本不会数论。</p><p>于是现在我要开始学数论！！！</p><hr><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><p>数论是纯粹数学的分支之一，主要研究整数的性质。</p><p>在学习数论之前，先来了解一下一些基本知识</p><hr><h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p>模运算的定义十分简单，即余数。</p><p>具体来讲，对于两个非负整数$a$ , $b$，$a / b$的余数记做$a \bmod b$，即$a$模$b$。</p><p>在这里，$mod$相当于C++中的$\%$运算。</p><p>而对于非负整数$a$与负整数$b$ , $a \bmod b$的值即为$a$除以$b$的余数再加上$b$。</p><hr><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>若$a \bmod c = b \bmod c$, 则称$a$与$b$在模$c$意义下同余，写作$a \equiv b\pmod c$</p><hr><h3 id="模运算的性质"><a href="#模运算的性质" class="headerlink" title="模运算的性质"></a>模运算的性质</h3><p>对于整数$a$与正整数$b$，有：</p><script type="math/tex; mode=display">a + b \equiv (a \bmod p) + (b \bmod p)\pmod p</script><script type="math/tex; mode=display">a - b \equiv (a \bmod p) - (b \bmod p)\pmod p</script><script type="math/tex; mode=display">a \times b \equiv (a \bmod p) \times (a \bmod p)\pmod p</script><p>我们将这种性质称为<strong>模运算对加法，减法，乘法封闭</strong>。</p><p>但要注意，<strong>除法并不满足这种性质</strong>，因此，我们一般很少直接使用除法。</p><hr><h2 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h2><p>对于两个<strong>互质</strong>(注意，必须要互质)的非负整数$a$，$p$ , 存在 $ax \pmod p = 1$。</p><p>称$x$是$a$在模$p$意义下的乘法逆元，记做$a^{-1}$。</p><p>不难看出，乘法逆元具有以下性质：</p><script type="math/tex; mode=display">x \times x^{-1} \equiv 1\pmod p</script><p>乘法逆元的可以用于代替计算除法，在模意义下，除以一个数等价于乘其乘法逆元。</p><hr><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>对于任意的正整数$a$和<strong>质数</strong>$p$(需保证$a$不是$p$的倍数)，有</p><script type="math/tex; mode=display">a^{p - 1} \equiv 1\pmod p</script><p>将上面的公式变一下形，就成了</p><script type="math/tex; mode=display">a \times a^{p - 2} \equiv 1\pmod p</script><p>即 <script type="math/tex">a \equiv \frac{1}{a^{p - 2}} \pmod p</script></p><p>根据乘法逆元的定义，$a^{p - 2}$即为$a$在模$p$意义下的乘法逆元。</p><p>对此，我们可以用快速幂进行计算，时间复杂度为$O(\log a)$</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HA 19260817  <span class="comment">//这里的HA为模数.</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll a , ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll c = Pow(a , n &gt;&gt; <span class="number">1</span>) % HA;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ((c % HA) * (c % HA)) % HA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((c % HA) * (c % HA) * (a % HA)) % HA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pow(a , HA - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但要注意，费马小定理<strong>只有在模数为质数时才可以使用</strong>，因为如果模数不是质数，并不是每一个数都存在逆元。</p><hr><h3 id="线性递推"><a href="#线性递推" class="headerlink" title="线性递推"></a>线性递推</h3><p>如果要求一个数的乘法逆元，我们可以用费马小定理很快求出。</p><p>但如果要在模数很大的情况下求$n$个数的逆元的话，费马小定理的时间复杂度就成了$O(n\times p)$。</p><p>因为$p$一般都为一个$10^9$级别的质数，因此，费马小定理很难在规定时间内求出答案。</p><p>这时，我们将需要使用线性递推法。</p><p>线性递推法可以在线性的时间内求出从$2$到$p$的所有数的逆元，其推导过程如下：</p><p>首先，$1^{-1} \equiv 1 \pmod p$。这是很显然的。</p><p>然后设$p = k \times i + r$，即$k$为$p / i$的商，$r$为余数</p><p>将这个式子放在模$p$意义下，可得：<script type="math/tex">k \times i + r \equiv 0 \pmod p</script></p><p>然后乘上$i^{-1} , r^{-1}$，可得：<script type="math/tex">k \times r^{-1} + i^{-1} \equiv 0 \pmod p</script></p><script type="math/tex; mode=display">i^{-1} \equiv -⌊\frac{p}{i}⌋\times (p \bmod i)^{-1} \pmod p</script><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3000001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv[N] , n;</span><br><span class="line"></span><br><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    inv[i] = (HA - HA / i) * inv[HA % i] % HA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(n)$，很适合用来预处理从$1$到$n$所有数的逆元。</p><hr><h2 id="Gcd-amp-Lcm"><a href="#Gcd-amp-Lcm" class="headerlink" title="Gcd &amp; Lcm"></a>Gcd &amp; Lcm</h2><h3 id="最大公因数-Gcd"><a href="#最大公因数-Gcd" class="headerlink" title="最大公因数(Gcd)"></a>最大公因数(Gcd)</h3><p>能够同时整除$a$与$b$的最大的数，叫做$a$与$b$的最大公因数，记做$gcd(a , b)$</p><p>对于任意的$gcd(a , b)$，有<script type="math/tex">gcd(a , b) = gcd(a , a - b) = gcd(b , a - b)</script></p><hr><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>一般情况下，我们使用欧几里得算法求解两个数的最大公因数。</p><p>刚刚提到，对于任意的$gcd(a , b)$，有<script type="math/tex">gcd(a , b) = gcd(a , a - b) = gcd(b , a - b)</script></p><p>考虑$a$远远大于$b$时，则</p><script type="math/tex; mode=display">gcd(a , b) = gcd(b , a - b) = gcd(b , a - b - b) = gcd(b , a - b - b - b)……= gcd(b , a\bmod b)</script><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b , a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度取决于其递归深度，为$O(\log a)$</p><hr><h3 id="最小公倍数-Lcm"><a href="#最小公倍数-Lcm" class="headerlink" title="最小公倍数(Lcm)"></a>最小公倍数(Lcm)</h3><p>同时是整数$a$与整数$b$的倍数的最小的数叫做$a$与$b$的最小公倍数，记做$lcm(a , b)$</p><p>直接套用公式即可求出。</p><script type="math/tex; mode=display">lcm(a , b) = \frac{a\times b}{gcd(a , b)}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b , a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a , b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度同样也是$O(\log a)$的。</p><hr><h2 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h2><p>关于$x$的形如<script type="math/tex">ax \equiv b \pmod p</script>的方程称为线性同余方程。</p><p>求解以上的线性同余方程，相当于求解下面的不定方程</p><script type="math/tex; mode=display">ax + by = p</script><hr><h3 id="扩展欧几里得-Exgcd"><a href="#扩展欧几里得-Exgcd" class="headerlink" title="扩展欧几里得(Exgcd)"></a>扩展欧几里得(Exgcd)</h3><p>扩展欧几里得算法<code>exgcd</code>可以在求出$gcd(a , b)$的同时求出$ax \equiv b \pmod {gcd(a , b)}$，即二元一次不定方程$ax + by = gcd(a , b)$的一组整数解。</p><p>其原理在于收集欧几里得算法在求解$gcd(a , b)$时产生的式子并带入。</p><p>举个栗子<del>(就不给你吃o(´^｀)o)</del>：</p><p>在求$gcd(71 , 13)$时，可以得到以下式子</p><script type="math/tex; mode=display">71 = 13 \times 5 + 6</script><script type="math/tex; mode=display">13 = 6 \times 2 + 1</script><p>现在移一下项，把余数都移到左边,就成了下面这个样子</p><script type="math/tex; mode=display">6 = 71 + 13\times (-5)</script><script type="math/tex; mode=display">1 = 13 + 6\times (-2)</script><p>从$gcd(71 , 13)$开始，把刚刚推出的式子一一带入，就成了下面的样子</p><p>$gcd(71 , 13)$<br>$= 1$<br>$= 13 + 6\times (-2)$<br>$= 13 + [71 + 13\times(-5)]\times(-2)$<br>$= 13 \times 11 + 71 \times (-2)$<br>$= 71 \times (-2) + 13 \times 11$</p><p>看最后一个式子，是不是就是$a = 71$ ,$b = 13$时的不定方程？</p><p>所以解为$x = -2$, $y = 11$。</p><p>在刚刚的过程中，不难看出每一次计算都交换了$x$与$y$的位置，并将$y$减去了原来与$x$辗转相除的商的乘积。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line">ll x , y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a , ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b , a % b);</span><br><span class="line">    ll tx = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tx - a / b * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><p>素数，即质数，指只有$1$与它本身两个因子的数。</p><h3 id="素数判定"><a href="#素数判定" class="headerlink" title="素数判定"></a>素数判定</h3><p>如何判定一个数$n$是不是质数呐？？？</p><p>最朴素的办法应该就是把$2$到$n - 1$的数都试除一遍，看能否除尽。</p><p>但我们发现并不需要除到$n - 1$，只需要除到$\sqrt n$即可。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(\sqrt n)$，对于单个数据而言，已经很优秀了。</p><hr><h3 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h3><p>但大多数时候，我们不仅要判断单个数是否为质数，而是要判断含有$n$个数的区间内有多少素数或有哪些素数。</p><p>这时，跑$n$边朴素算法的时间复杂度高达$O(n \sqrt{num})$，已经远远无法满足我们的要求。</p><p>因此，我们需要更加高效的做法。</p><hr><h4 id="埃拉托斯特尼筛（埃氏筛）"><a href="#埃拉托斯特尼筛（埃氏筛）" class="headerlink" title="埃拉托斯特尼筛（埃氏筛）"></a>埃拉托斯特尼筛（埃氏筛）</h4><p>埃氏筛的核心思想只有一句话：<strong>素数的倍数一定不是素数</strong></p><p>因此，我们可以默认数组中的每一个数都为素数，然后依次筛掉。</p><p><strong>特别提醒：$1$既不是质数也不是合数，因此，需要从$2$开始筛</strong></p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Prime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IS_Prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        Prime[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Prime[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i)&#123;</span><br><span class="line">                Prime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(n \log \log n)$，属于比较优秀的筛法。</p><hr><h4 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h4><p>不难看出，刚刚的埃氏筛中有一个致命的缺点：一个数可能会被筛掉多次。</p><p>因此，我们可以对此作出改善。</p><p><strong>Code：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[N]; </span><br><span class="line"><span class="keyword">bool</span> Prime[N];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IS_Prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        Prime[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Prime[i])&#123;</span><br><span class="line">            a[num ++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num &amp;&amp; i * a[j] &lt; n; j ++)&#123;</span><br><span class="line">            Prime[i * a[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i % a[j]))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以保证每个数据被其最小质因子筛掉，因此，时间复杂度为$O(n)$。</p><hr><h2 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块"></a>数论分块</h2><p>数论分块是一种比较特殊的分块算法，可以用来解决形如$ f(n) = \sum\limits_{i = 1}^{n}\lfloor \frac{n}{i} \rfloor$的问题</p><p>显然，这个式子直接求解的复杂度为$O(n)$。但面对形如$10^{12}$的大数据时，则显得比较无能为力。</p><p>这时候，我们就需要一个更加优秀的做法。</p><p>观察一下这个式子，并手造几组小数据带入，可以得到下表</p><div class="table-container"><table><thead><tr><th style="text-align:center">$n$</th><th style="text-align:left">分步计算</th><th style="text-align:center">$f(n)$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">2 + 1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">3 + 1 + 1</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left">4 + 2 + 1 + 1</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">5 + 2 + 1 + 1 + 1</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">6 + 3 + 2 + 1 + 1 + 1</td><td style="text-align:center">14</td></tr><tr><td style="text-align:center">7</td><td style="text-align:left">7 + 3 + 2 + 1 + 1 + 1 + 1</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">8</td><td style="text-align:left">8 + 4 + 2 + 2 + 1 + 1 + 1 + 1</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">9</td><td style="text-align:left">9 + 4 + 3 + 2 + 1 + 1 + 1 + 1 + 1</td><td style="text-align:center">23</td></tr></tbody></table></div><p>不难发现，对于单一的$\lfloor \frac{n}{i} \rfloor$，<strong>有些位置的值是相同的，而且呈块状分布</strong></p><p>继续观察，可以发现<strong>若一个块的左端点为</strong>$l$，<strong>则其右端点为</strong>$\lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor} \rfloor$</p><p>直接分块求解即可。</p><p>时间复杂度为$O(\sqrt n)$，足以跑过$10^{12}$的大数据。</p><p><strong>Code：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; r; l &lt;= n; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">    r = n / (n / l);</span><br><span class="line">    ans += n / i * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h1><p>组合数学是研究组合模型，计数，构造等方面问题的数学分治，是$OI$重要的组成部分。</p><p>在学习组合数学之前，先来看一下组合数学的基本计数原理。</p><hr><h2 id="计数原理"><a href="#计数原理" class="headerlink" title="计数原理"></a>计数原理</h2><h3 id="加法原理"><a href="#加法原理" class="headerlink" title="加法原理"></a>加法原理</h3><p>一般的，如果做一件事有$n$种不同的途径，其中做第$i$件事有$n_i$种方案，则做这件事一共有$\sum n_i$种方案</p><hr><h3 id="乘法原理"><a href="#乘法原理" class="headerlink" title="乘法原理"></a>乘法原理</h3><p>一般的，如果做一件事有$n$个步骤，其中第$i$个步骤有$n_i$种不同的完成方案，则做这件事一共有$\prod m_i$种方法。</p><hr><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>统计多个集合的并集的方法如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 先把所有集合的元素加起来</span><br><span class="line"><span class="bullet">2.</span> 然后减去【多加的】每两个集合相交的元素数量</span><br><span class="line"><span class="bullet">3.</span> 然后加上【多减的】每三个集合相交的元数数量</span><br><span class="line"><span class="bullet">4.</span> ………………………………</span><br></pre></td></tr></table></figure><p>举个栗子<del>(就不给你吃o(´^｀)o)</del>：</p><p>现在有三个集合$A , B , C$，其中</p><script type="math/tex; mode=display">A = \lbrace 0 , 1 , 2 , 3 , 4 \rbrace</script><script type="math/tex; mode=display">B = \lbrace 0 , 3 , 4 , 5 , 6\rbrace</script><script type="math/tex; mode=display">C = \lbrace 0 , 5 , 6 , 7 , 8 \rbrace</script><p>请求出集合$A , B , C$的并集中的元素数量。</p><p>首先，把三个集合的元素总数加起来，为$15$。</p><p>之后减去每两个集合的交集，可得$15 - (3 + 3 + 1) = 8$</p><p>之后再加上三个集合的交集，可得$8 + 1 = 9$</p><p>显然，原集合的并集大小为$9$。</p><p>现在把刚刚运算过程中的式子重新整理，可以得到</p><script type="math/tex; mode=display">9 = 15 - (3 + 3 + 1) + 1</script><p>不难看出，此时等式的左边是多个集合的并的元数数量，等式的右边的每一项是几个集合的交的元素数量，右边每一项的符号取决于其项数的奇偶。</p><hr><h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>将$n$个不同元素按照不同的顺序进行排列，设总方案数为$f(n)$(定义$f(0) = 1$)，考虑第一个元素的位置，则有</p><script type="math/tex; mode=display">f(n) = f(n - 1) \times n</script><p>化简一下，则$f(n) = n!$。</p><hr><h3 id="普通排列"><a href="#普通排列" class="headerlink" title="普通排列"></a>普通排列</h3><p>从$n$个元素中取出$k$个进行排列，设总方案数为$P(n , k)$考虑每一次取数时的选择，第一次有$n$种选择，第二次有$n - 1$种……第$n$次则有$n - k + 1$种。</p><p>即<script type="math/tex">P(n , k) = \prod\limits_{i = 0}^{k - 1} (n - i)</script></p><p>把这个公式和$n!$对比，很容易可以发现少了$n - k$之后的项。</p><p>即<script type="math/tex">P(n , k) = \frac{n!}{(n - k)!}</script></p><hr><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>从$n$个元素中选取$k$个元素进行组合，设总方案为$C_n^k$。把排列数$P(n , k)$等价于从$n$个元素中选取$k$个进行全排列。</p><p>即<script type="math/tex">P(n , k) = C_n^k \times k!</script></p><p>移一下项，可得<script type="math/tex">C_n^k = \frac{P(n , k)}{k!} = \frac{n!}{(n-1)! \times k!}</script></p><hr><h3 id="特殊性质"><a href="#特殊性质" class="headerlink" title="特殊性质"></a>特殊性质</h3><script type="math/tex; mode=display">C_n^0 = C_n^n = 1</script><script type="math/tex; mode=display">C_n^1 = n</script><script type="math/tex; mode=display">C_n^k = C_{n - 1}^k \times C_{n - 1}^{k - 1}</script><p>其中，最后一个为<code>Pascal</code>公式，可以用来打组合数表。</p><hr><h2 id="组合数的计算"><a href="#组合数的计算" class="headerlink" title="组合数的计算"></a>组合数的计算</h2><h3 id="组合数表"><a href="#组合数表" class="headerlink" title="组合数表"></a>组合数表</h3><p>使用<code>Pascal</code>公式递推，如果数据太大的话需要高精或者取模。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1001</span></span><br><span class="line"></span><br><span class="line">ll c[N][N];         <span class="comment">//c[i][j]表示在i个数中选n个数的组合数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_num</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">            c[i][j] = c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="单独计算"><a href="#单独计算" class="headerlink" title="单独计算"></a>单独计算</h3><p>直接套公式即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)&#123;</span><br><span class="line">        ans = ans * (n - i + <span class="number">1</span>) / i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://oi.men.ci/">Menci’s Blog &amp; 课件</a></li><li><a href="http://inspiral.coding.me/">Struct 瓶子’s Blog</a></li><li><a href="https://blog.csdn.net/passer__/article/details/77720807">Passer’s CSDN Blog</a></li><li><a href="https://www.luogu.org/problemnew/solution/P3811">Luogu P3811【模板】乘法逆元-题解</a></li><li><a href="https://www.cnblogs.com/zjp-shadow/p/7773566.html">zip-shadow’s CSDN Blog</a></li></ol><p>感谢上述dalao对我数论学习的帮助</p><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 总结篇 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷题库】路径统计-题解</title>
      <link href="2019/09/07/luoguP1608/"/>
      <url>2019/09/07/luoguP1608/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h3><p>“RP餐厅”的员工素质就是不一般，在齐刷刷的算出同一个电话号码之后，就准备让HZH,TZY去送快餐了.</p><p>他们将自己居住的城市画了一张地图，已知在他们的地图上，有$N$个地方。</p><p>而且他们目前处在标注为$1$的小镇上，而送餐的地点在标注为$N$的小镇。（有点废话）</p><p>除此之外还知道这些道路都是单向的，从小镇I到J需要花费$D_ij$的时间。</p><p>为了更高效快捷的将快餐送到顾客手中，他们想走一条从小镇$1$到小镇$N$花费最少的一条路。</p><p>但是他们临出发前，撞到因为在路上堵车而生气的FYY，深受启发，不能仅知道一条路线，万一。。。</p><p>于是，他们邀请FYY一起来研究起了下一个问题：这个最少花费的路径有多少条？</p><hr><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入文件第一行为两个空格隔开的数$N，E$，表示这张地图里有多少个小镇及有多少边的信息。</p><p>下面$E$行，每行三个数$I、J、C$，表示从$I$小镇到$J$小镇有道路相连且花费为$C$.</p><hr><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出文件包含两个数，分别是最少花费和花费最少的路径的总数.</p><p>两个不同的最短路方案要求：路径长度相同（均为最短路长度）且至少有一条边不重合。</p><p>若城市$N$无法到达则只输出一个<code>No answer</code>;</p><hr><h3 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h3><h4 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 5 4</span><br><span class="line">1 2 2</span><br><span class="line">2 5 2</span><br><span class="line">4 1 1</span><br></pre></td></tr></table></figure><h4 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4 2</span><br></pre></td></tr></table></figure><hr><h3 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h3><p>对于$30\%$的数据 $N≤20$;</p><p>对于$100\%$的数据 $1≤N≤2000$,$0&lt;≤E&lt;≤N\times(N-1)$, $1≤C≤10$.</p><p>不保证没有重边，自环。</p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一句话题意：给你一张有向图，让你求出从$1$到$n$的最短路长度与最短路数量。</p><p>我们只需要一个最短路模板和一个计数操作即可。</p><p>Dijkstra的计数操作代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans[N];     <span class="comment">//ans为最短路数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dis[to] &gt; dis[v] + edge[i].dis)&#123;     <span class="comment">//如果需要进行松弛操作</span></span><br><span class="line">    dis[to] = dis[v] + edge[i].dis;</span><br><span class="line">    ans[to] = ans[v];   <span class="comment">//就用新的最短路数量覆盖原来的最短路数量</span></span><br><span class="line">    Q.push(<span class="built_in">make_pair</span>(dis[to] , to));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(dis[to] = dis[v] + edge[i].dis)&#123;    <span class="comment">//如果这是另一条最短路</span></span><br><span class="line">    ans[to] += ans[v];  <span class="comment">//将数量相加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计数之前不要忘记把ans[1]初始化为1</strong></p><p>对于重边的话，我们很容易注意到$N$的数据范围只有$2000$。</p><p>因此，我们直接开一个二维数组<strong>记录重边中最短的一条</strong>即可。</p><p>剩下的就是最短路模板了</p><hr><h3 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> end head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , s;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    ll dis;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> end[N];</span><br><span class="line"><span class="keyword">int</span> edge_num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , ll dis)</span></span>&#123;</span><br><span class="line">    edge[++ edge_num] = Edge&#123;to , dis , end[from]&#125;;</span><br><span class="line">    end[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pairs pair<span class="meta-string">&lt;ll  , ll &gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;pairs , <span class="built_in">vector</span>&lt;pairs &gt; , greater&lt;pairs &gt; &gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        dis[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        Q.push(<span class="built_in">make_pair</span>(dis[i] , i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = Q.top().second;</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[now])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[now] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = end[now] ; i ; i = edge[i].last)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[to] &gt; dis[now] + edge[i].dis)&#123;   <span class="comment">//最短路计数部分</span></span><br><span class="line">                dis[to] = dis[now] + edge[i].dis;</span><br><span class="line">                ans[to] = ans[now];</span><br><span class="line">                Q.push(<span class="built_in">make_pair</span>(dis[to] , to)); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dis[to] == dis[now] + edge[i].dis)&#123;</span><br><span class="line">                ans[to] += ans[now];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">2001</span>][<span class="number">2001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l  , r;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[l][r] == <span class="literal">false</span> || <span class="built_in">map</span>[l][r] &gt; s)&#123;</span><br><span class="line">            add_edge(l , r , s);</span><br><span class="line">            <span class="built_in">map</span>[l][r] = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    Dijkstra(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(dis[n] == <span class="number">0x3f3f3f3f</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No answer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dis[n] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 图论 </tag>
            
            <tag> Luogu </tag>
            
            <tag> 最短路计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷题库】足球-题解</title>
      <link href="2019/08/22/luoguP1326/"/>
      <url>2019/08/22/luoguP1326/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>丈夫崛起高昂首，腾身一跃向胜利冲锋<br>                          ——《崛起》</p></blockquote><a id="more"></a><h2 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h2><p>我们当中有很多热爱中国足球的同学，我们都知道中超（中国足球超级联赛）的规则：</p><p>一场比赛中，若获胜（即你的得分严格大于对手得分）则获得3的积分。</p><p>若打平（即你的得分等于对手得分）则获得1分。</p><p>若失败（即你的得分严格小于对手得分）获得0积分。</p><p>这个问题很简单，假设$N$轮中比赛中你一共攻入$S$个球，丢掉$T$个球，那么你可能获得的最大得分和最小得分是多少？</p><hr><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>多组数据，每组数据一行：</p><p>一行三个整数$S$、$T$、$N$</p><hr><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>对于每组数据输出一行，两个整数表示最大得分和最小得分。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1 1 1</span><br><span class="line">1 1 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p>保证所有数据均在long long(即int64)范围之内</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道贪心好题，但绝对没有紫题的难度。</p><p>首先，题目要求我们求最大值与最小值。因此，我们需要对两个答案分类讨论。</p><h3 id="MAX"><a href="#MAX" class="headerlink" title="MAX"></a>MAX</h3><p>既然要求得分最大，那么我们要让赢的场数尽量的多。</p><p>那么我们的<strong>核心思想在于尽量让更多的场进球，更少的场输球</strong> </p><p>分以下两种情况讨论：</p><h4 id="进球数-gt-场数"><a href="#进球数-gt-场数" class="headerlink" title="进球数 &gt; 场数"></a>进球数 &gt; 场数</h4><p>如果进球数大于比赛场数的话，理论上我们就一定以<code>1 : 0</code>可以赢$N$场。</p><p>但是我们还要处理丢掉的球。</p><p>因此，我们只需要先以<code>1 : 0</code>赢$N - 1$场，得分为$3 \times (N - 1)$.</p><p>对于剩下的一场，我们还需要进行分类讨论。</p><p>我们提前算出我们还要进球的数量，即$S - (N - 1)$，如果大于我们输的球就加3分，等于加1分，小于不加分。</p><hr><h4 id="进球数-lt-场数"><a href="#进球数-lt-场数" class="headerlink" title="进球数 &lt;= 场数"></a>进球数 &lt;= 场数</h4><p>在这种情况下，我们最多只能以<code>1 : 0</code>赢$S$场，得分为$3 \times S$。</p><p>对于剩下的场数，我们需要尽量达成平局。因此我们只需要输一场来处理丢掉的球，得分为$N - S - 1$。</p><p>但要注意，如果此时的$T = 0$，即没有丢球的话，我们就不需要输了，则此时的得分为$N - S$</p><hr><h3 id="MIN"><a href="#MIN" class="headerlink" title="MIN"></a>MIN</h3><p>求最小值时，我们不能简单地说输的越多越好，因为赢一场就是3分，而平三场才有三分。</p><p>因此我们<strong>求最小值时需要比较赢一场，剩下都输</strong>与<strong>有的平局有的输</strong>两种情况。</p><p>下面我们还是分两种情况进行分类讨论。</p><h4 id="进球数-gt-丢球数"><a href="#进球数-gt-丢球数" class="headerlink" title="进球数 &gt; 丢球数"></a>进球数 &gt; 丢球数</h4><p>此时，我们一定不可能一场都不赢，因为就算全是平局，也会有剩下的进球数。</p><p>因此我们就让他以<code>S : 0</code>先赢一次，浪费掉所有的进球数。</p><p>对于剩下的$N - 1$场，如果$N - 1 &gt; T$，即剩下的场数大于输球数，我们就让他输掉$T$场，剩下的都为平局。此时得分为$3 + (N - 1 - T)$</p><p>如果$N - 1 &lt;= T$，即剩下的场数小于等于输球数，那么我们就让他全部输掉。此时得分为3分。</p><hr><h4 id="进球数-lt-丢球数"><a href="#进球数-lt-丢球数" class="headerlink" title="进球数 &lt;= 丢球数"></a>进球数 &lt;= 丢球数</h4><p><del>啊，终于可以一场都不赢了</del></p><p>因为我们要尽量多输几场，所以每场比赛比分都是<code>0 : 1</code>。因此我们要看$S - T$与$N$的大小关系。</p><p>如果$S - T$ 大于等于$N$，那么每一场都输掉。得分就是0分、</p><p>否则用平局补充，得分就是$N - (S - T)$。</p><p>还有就是不要忘了赢一局可能比用平局更低的情况……</p><p>最后的答案在这两种里取最小值就好了。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll s , t , n;</span><br><span class="line"></span><br><span class="line"><span class="function">I ll <span class="title">MAX</span><span class="params">(ll s , ll t , ll n)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s &gt;= n)&#123;</span><br><span class="line">        ans += <span class="number">3</span> * (n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s - n + <span class="number">1</span> &gt; t)&#123;</span><br><span class="line">            ans += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s - n + <span class="number">1</span> == t)&#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span> * s + (n - s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * s + (n - s - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">I ll <span class="title">MIN</span><span class="params">(ll s , ll t , ll n)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s &gt; t)&#123;</span><br><span class="line">        ans += <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(n - <span class="number">1</span> &gt; t)&#123;</span><br><span class="line">            ans += n - <span class="number">1</span> - t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s &lt;= t)&#123;</span><br><span class="line">        ll a = <span class="number">3</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(t &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">            a += n - <span class="number">1</span> - t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; t - s)&#123;</span><br><span class="line">             b = n - (t - s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(a , b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; MAX(s , t , n) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; MIN(s , t , n) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 分类讨论 </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷题库】断罪者-题解</title>
      <link href="2019/08/12/luoguP4971/"/>
      <url>2019/08/12/luoguP4971/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在我的心脏停止跳动之前，我依然想继续守护着你   ——《心拍数#0822》</p></blockquote><a id="more"></a><h3 id="题目背景："><a href="#题目背景：" class="headerlink" title="题目背景："></a>题目背景：</h3><p>四季映姬·亚玛萨那度（以下简称四季大人）是地狱的最高裁判长。</p><p>她平时负责给死者定罪，判断让死者去地狱还是天界，或者别的什么地方。</p><p>四季大人当然可以轻松地给死者断罪，但是死者太多了，四季大人需要你帮她断罪，以便腾出时间让她对别人进行说教。</p><hr><h3 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h3><p>人们的罪恶值$E$由人们生前所做过的事和他的死亡方式来决定.他们做过的坏事都会有一个罪恶值，</p><p>这些坏事有可能会并入同一个集合，一个集合的罪恶值为该集合中罪恶值最大的坏事的罪恶值，</p><p>而他们一生做过的事会互相影响，我们将他们生前做过的事分为4种，而最后的罪恶值$E$由其中所有集合的罪恶值的和决定。</p><pre><code>1.做坏事——有罪恶值，单独为一集合。  2.做好事——将一件坏事的罪恶值清零。3.忏悔——将指定集合中，最大罪恶值的事罪恶值减少。4.认清自己——将两个坏事集合合并。</code></pre><p>而死亡方式可分为 自然死亡 、事故死亡 和 自杀 。</p><pre><code>1.自然死亡，没什么影响。2.事故死亡，可以免除最大罪恶的坏事集合。3.自杀，最大的坏事集合罪恶值翻倍。</code></pre><hr><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行三个输入$T$ , $W$ , $K$，代表有$T$个人等待断罪，$W$为死亡方式，与描述序号对应，$K$含义见输出格式。</p><p>接下来的$T$组数据， 每组数据第一行两个输入$n$ ,$m$，代表他做过的坏事数量和其他事的数量。</p><p>第二行$n$个输入，代表每件坏事的罪恶值。</p><p>第3到第$m+2$行，每行有三种输入可能。（请联系题目描述进行理解）<br>$2$ $A$ 表示做好事，将坏事$A$罪恶值清零 。<br>$3$ $A$ $B$ 表示忏悔，指定集合为$A$所在的集合，最大罪恶值的事减少$B$，若最大罪恶值比$B$小，则最大罪恶值的事罪恶值清零。<br>$4$ $A$ $B$ 表示认清自己，将$B$所在集合与$A$所在的集合合并。</p><hr><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对于每一个人，一行输出</p><p>若他的罪恶值为$0$则输出$Gensokyo$，</p><p>若他的罪恶值大于$K$则输出$Hell$，</p><p>否则输出$Heaven$</p><p>之后输出它的罪恶值</p><hr><h3 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h3><h4 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1 1 10</span><br><span class="line">5 2</span><br><span class="line">1 2 3 4 5</span><br><span class="line">2 3</span><br><span class="line">4 2 4</span><br></pre></td></tr></table></figure><h4 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Heaven 10</span><br></pre></td></tr></table></figure><hr><h4 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg 2"></a>Input ‘s eg 2</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2 2 8</span><br><span class="line">5 4</span><br><span class="line">4 8 7 5 6</span><br><span class="line">4 2 4</span><br><span class="line">2 2</span><br><span class="line">4 2 3</span><br><span class="line">3 3 2</span><br><span class="line">3 2</span><br><span class="line">5 1 2</span><br><span class="line">2 2</span><br><span class="line">3 3 2</span><br></pre></td></tr></table></figure><h4 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h4><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Hell 9</span><br><span class="line">Gensokyo 0</span><br></pre></td></tr></table></figure></h2><h4 id="Input-‘s-eg-3"><a href="#Input-‘s-eg-3" class="headerlink" title="Input ‘s eg 3"></a>Input ‘s eg 3</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2 1 15</span><br><span class="line">5 4</span><br><span class="line">1 2 3 4 5</span><br><span class="line">4 2 3</span><br><span class="line">3 2 100</span><br><span class="line">4 1 4</span><br><span class="line">4 4 1</span><br><span class="line">5 4</span><br><span class="line">1 2 3 4 5</span><br><span class="line">3 2 15</span><br><span class="line">4 2 3</span><br><span class="line">4 1 4</span><br><span class="line">4 3 4</span><br></pre></td></tr></table></figure><h4 id="Output-‘s-eg-3"><a href="#Output-‘s-eg-3" class="headerlink" title="Output ‘s eg 3"></a>Output ‘s eg 3</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Heaven 11</span><br><span class="line">Heaven 9</span><br></pre></td></tr></table></figure><hr><h3 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h3><p>所有数据均在长整型范围内，对于所有数据，均有$m\le nm≤n,1\le K1≤K$，保证输入不存在负数。</p><p>由于读入数据可能会很大，建议使用较快的读入。</p><p>约定① 对于合并两个集合的操作，至少有一个集合只有一件坏事</p><p>约定② 这群人不会做好事</p><p><a href="https://imgchr.com/i/mSzmCQ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/12/mSzmCQ.jpg" alt="mSzmCQ.jpg"></a></p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一道<del>毒瘤</del>数据结构题</p><p>首先我们简化一下题意</p><blockquote><p>给你$n$个集合与三种操作，操作如下</p><ol><li>单点修改——将指定集合中的某个元素清零</li><li>维护最值——将指定集合中的最大值减少</li><li>合并——合并两个集合。</li></ol></blockquote><p>下面，我们就来看一下各种分数的做法</p><hr><h4 id="30分做法"><a href="#30分做法" class="headerlink" title="30分做法"></a>30分做法</h4><p>不难看出，第二个操作可以用优先队列轻易实现，而数据中正好有6个点没有1，3操作。</p><p>于是我们可以用STL的优先队列模拟这个过程，最后加起来即可。</p><hr><h4 id="60分做法"><a href="#60分做法" class="headerlink" title="60分做法"></a>60分做法</h4><p>写过30分做法之后，我们就要尝试实现单点修改。</p><p>但STL中的优先队列不支持单点修改啊</p><p>那怎么办？</p><p><del>手写堆呗QAQ</del></p><p>我们可以通过手写堆来模拟这个过程，但由于我们不确定每个堆的大小，因此不能直接开2000000个堆，要用链表实现或数组模拟</p><p>这样我们就可以过掉所有满足特殊约定的点。</p><p>对于不满足特殊约定的点也可以暴力合并，但时间复杂度极高，为$O((n1+n2)log(n1+n2))$ 。</p><p>因此，我们需要想办法优化我们的合并操作</p><hr><h4 id="满分做法"><a href="#满分做法" class="headerlink" title="满分做法"></a>满分做法</h4><p>那我们该怎么优化我们的合并操作呐？</p><p>在这里，我们引入一个新的数据结构:左偏树</p><p>左偏树是一种<strong>具有左偏性质的堆状二叉树</strong>，因此优先队列的操作都可以中左偏树实现。</p><p>而且左偏树具有十分强大的合并操作，可以在$O(nlogn)$的时间复杂度下合并两个优先队列。</p><p>想了解左偏树的同学们请点击<a href="https://payphone-x.github.io/2019/07/05/left-tree/#more">这里Ｏ(≧▽≦)Ｏ</a></p><p>学过之后你会发现这是一道模板题……直接修改一下pop操作就过啦</p><hr><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Left_tree&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">int</span> dis;</span><br><span class="line">    <span class="keyword">int</span> far;</span><br><span class="line">    &#125;node[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node[root].pre == root)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node[root].pre = find(node[root].pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node[x].dis &lt; node[y].dis)&#123;</span><br><span class="line">    swap(x , y);</span><br><span class="line">    &#125;</span><br><span class="line">    node[x].right = merge(node[x].right , y);</span><br><span class="line">    node[node[x].right].pre = x;</span><br><span class="line">        node[x].far = (node[x].right == <span class="number">0</span>) ? <span class="number">0</span> : node[node[x].right].far + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(node[node[x].left].far &lt; node[node[x].right].far)&#123;</span><br><span class="line">    swap(node[x].left , node[x].right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void pop(int x)&#123;</span></span><br><span class="line"><span class="comment">    int l = node[x].left;</span></span><br><span class="line"><span class="comment">    int r = node[x].right;</span></span><br><span class="line"><span class="comment">    node[x].dis = 0;</span></span><br><span class="line"><span class="comment">    node[l].pre = l;</span></span><br><span class="line"><span class="comment">    node[r].pre = r;</span></span><br><span class="line"><span class="comment">    node[x].pre = merge(l , r);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;A , <span class="keyword">const</span> <span class="keyword">int</span> &amp;dis , <span class="keyword">bool</span> flag)</span></span>&#123;</span><br><span class="line">        node[A].dis -= dis;</span><br><span class="line">        <span class="keyword">if</span>(node[A].dis &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            node[A].dis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node[node[A].left].pre = node[A].left;</span><br><span class="line">        node[node[A].right].pre = node[A].right;</span><br><span class="line">        <span class="keyword">int</span> l = node[A].left;</span><br><span class="line">        <span class="keyword">int</span> r = node[A].right;</span><br><span class="line">        node[A].left = node[A].right = node[A].far = <span class="number">0</span>;</span><br><span class="line">        tem = merge(l , r);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            merge(find(A) , tem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            merge(tem , A);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Left_tree;</span><br><span class="line"></span><br><span class="line">ll t , w , k;</span><br><span class="line">ll n , m;</span><br><span class="line">ll opt , A , B;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span> , &amp;t , &amp;w , &amp;k);</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;n , &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            node[i].pre = i;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;node[i].dis);</span><br><span class="line">            node[i].left = node[i].right = node[i].far = <span class="number">0</span>;</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;opt , &amp;A);</span><br><span class="line">            <span class="keyword">if</span>(opt == <span class="number">2</span>)&#123;</span><br><span class="line">                Delete(A , node[A].dis , <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(opt == <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;B);</span><br><span class="line">                Delete(find(A) , B , <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(opt == <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;B);</span><br><span class="line">                merge(find(A) , find(B));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        B = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            A = find(i);</span><br><span class="line">            <span class="keyword">if</span>(!vis[A])&#123;</span><br><span class="line">                vis[A] = <span class="literal">true</span>;</span><br><span class="line">                B = max(B , node[A].dis);</span><br><span class="line">                ans += node[A].dis;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w == <span class="number">2</span>)&#123;</span><br><span class="line">            ans -= B;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w == <span class="number">3</span>)&#123;</span><br><span class="line">            ans += B;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Gensokyo &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((ll)ans &lt;= k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Heaven &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hell &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 可并堆 </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【文章转载】慢慢的，就没有了，就像从未存在过</title>
      <link href="2019/08/12/nothing/"/>
      <url>2019/08/12/nothing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>最后，我们变成了一群做梦的人，这个梦的名字，叫根据相关法律法规，相关搜索结果不予显示的梦。</p></blockquote><p>本文转载于<a href="https://keepthethink.github.io/archives/3811762271/">Helium’s Blog</a></p><p>原作者：小海，文章来源：豆瓣网。原文已经不复存在。</p><a id="more"></a><div class="note warning">**本文为博主的转载文章，第一作者并非博主本人，且无任何政治立场。****因此，请读者不要去试图摸索任何“深层意思”或发表人身攻击等不适当言论****与此同时，阅读本文产生的一切后果，与作者无关。**</div><p>几年以前，我曾经嘲笑过某科技界大佬。当时他说：也许90后、95后会慢慢不知道谷歌是什么网站。</p><p>　　那一年，这对于我来说简直就是世界上最好笑的笑话。谷歌，全世界最卓越的互联网公司，活在互联网的一代中国人，会不知道他们的网站？</p><p>　　今天，我收回这句嘲笑。因为这件不可能的事，它慢慢变成了现实。</p><p>　　没有人再关注什么谷歌不谷歌。对他们来说，百度也蛮好用的，反正他们几乎没用过谷歌。没有谷歌又怎样？大家还是开心的刷微博，看微信，听歌，看娱乐节目。对于从来就不知道谷歌的人来说，少了谷歌又有什么影响？</p><p><a href="https://imgchr.com/i/exYiLt"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/12/exYiLt.jpg" alt="exYiLt.jpg"></a></p><p>　  多年前，我们也是可以登陆Facebook的。其实这个网站和校内一样，也挺蠢的。可在上面你能看到老外们的生活，可以轻易的跟一万公里以外的人互相拜访，可以看到很多根本不会开到校内上的主页。你用汉语回复，下面给你聊起来的可能是香港仔，可能是台湾人。你用英语回复，说不定有比你英语用的更蹩脚的寂寞的北欧人来跟你搭讪。你感觉地球真的变成了地球村，你还没拉门走出去，别人就推门走了进来。</p><p>　　然后，它就没有了。起初，它的失踪激起了很大的声音，后来，声音就消失了。</p><p>　　多年前，我们也是可以登陆Twitter的。其实这个网站和微博一样，也不过是些信息流，刷上一整天，也不见得有什么用处。但至少，你可以以最快速度获取你想知道的任何新事，你会真正了解什么事情在全世界是流行的，而不是经过各种截图、翻译、转发，甚至曲解、断章取义、黑白颠倒的东西。你知道的是真相，赤裸裸的，也许有点太短的真相。但至少中间不会有无数人的加工与再加工，偏激、片面，就在这个过程中产生了，不管后来者有意还是无意。</p><p>　　然后，它就没有了。首先是它的本体没有了，然后它的模仿者也没有了，模仿者的模仿者也没有了。只剩一个模仿者的模仿者的模仿者，现在你每天能在上面看到无数广告。</p><p>　　多年前，我们也是可以登陆YouTube的。对于有的人来说，这个网站就是个大型优酷，当年有人信誓旦旦的说，没有YouTube，我们中国人会很快让优酷超过YouTube。可这么多年过去了，视频还是那么卡，内容还是那么垃圾，原创还是那么容易被盗窃，视频丰富度还是那么的可怜。在YouTube上，你能看到全世界最棒的手艺人，最逗乐的笑话，最天马行空的创意，最激荡人心的音乐，最美好的完美瞬间，可在优酷上，你想看一分钟视频，请先看半分钟广告。</p><p>哦，对了。Instagram，有些人可能感觉它和QQ空间也差不多。可我在上面关注了六百多个摄影师，它们都是顶好顶好的影像记录者，每天看他们的作品，我感觉到很幸福， 那种即使没有到那里去，也身临其境的幸福。我还在上面认识了一个日本的爱自拍的帅小伙，一个爱喝酒的韩国大叔，一个十年前到过中国今天会在每张我发的紫禁城照片下点赞的美国大爷，一个美丽无比的俄罗斯妹子，我和他们基本上都难以交流，语言是很大的障碍，但几个简单的单词，心意也就到了，这种感觉，有时候比多年老友相聚还兴奋。因为这是人类不同族群自由交流互相沟通的过程，这种过程很神奇，真的很神奇。</p><p>　　可现在，它没有了，它之所以没有就因为在某个特定的时间你在搜索特定的词汇时，会搜出来特定的照片。虽然这么搜的人并不多，虽然看到的人也不会大惊小怪，也不会觉得天黑了，天亮了，天要塌了，天要变了。可它就是没了，Instagram，就这么没了。谷歌也是这么没的，Twitter也是这么没的，Facebook也是这么没的。不知道是什么人，在什么场合，说了什么话，下了什么决定。就要有超过十亿人像陷于哥谭市的孤岛里一样，看着一座又一座桥梁被炸掉，又被炸掉，又被炸掉，然后，就什么都没了。</p><p>　　我时常觉得悲哀，真的好悲哀，一个我根本不认识也不知道是谁的人，也许是一个群体，在不断抢走我身边的东西，而我却无能为力。我抱怨一声，他听不到，任何人都听不到。我怒吼一句，身边的大多数人却像看疯子一样的看着我。我哀嚎一声，这声音被阻碍在黑黑的幕墙以里。我发出尖锐的嘶吼，这声音传不了多远，就和我那被抢走的东西一样，消失了，不见了，就像从来没存在过一样。</p><p>　　对于本来就没存在过的东西，有谁又会觉得在意呢？那些本来拥有又被掠夺的人的哀愁，后来的人又怎么懂呢？我曾经是拥有一切的，我曾经是拥有世界的，我站在这片土地上，呼吸的是自由的空气，饮下的是自由的琼浆玉液。就在长的无法计数的时间里，我自由生命的一部分又一部分就这么被杀死了，突然就杀死了。可我还始终觉得，它们还奄奄一息的活着，就像它们是慢慢的死去的一样。</p><p>　　可它们终归是死了，而且随着它们的死，愈来愈多的事情慢慢的发生了，很慢很慢，几乎不被人察觉，可还是发生了。</p><p>　　没有谷歌，我可以用百度呀。可某些结果被越挪越后，越挪越后，最后就不见了。就像本来就不该搜出这个结果一样。</p><p>　　没有Facebook，我可以用校内呀。可你想发只有在Facebook上能发的文章，很快在校内上就失踪了。接着，校内变成了人人，话题变成了人人都关心的话题。大家都在抢着看星座、明星、八卦、娱乐。没有人会关心什么消失了，反正它们本来也没多少存在感。</p><p>　　没有YouTube，我可以用优酷呀。可你却经常只能在优酷上看到抄袭别人的作品，而且还不署名，而且还洋洋得意，而且还自我陶醉，就好像那个idea本来属于他自己一样。你看了还要惊呼，他是如此的有创意！好一个抄袭的创意，可你却不知道，因为你不知道这个世界上有个网站叫YouTube。</p><p>　　没有Twitter，我还可以用微博呀。可你想知道最近发生了什么，你搜的越勤快，越能看到越明显的“根据相关法律法规，相关搜索结果不予显示”。时间长了，你想，反正知道了也没什么用，不如不看了。</p><p>　　慢慢的，一扇又一扇的门关上了。今天你打开世界上最大的博客网站，发现它没了。明天你一看，世界上最好的设计师分享网站没了，一开始是刷新的很慢很慢，后来它就没了。过两天再一看，平常每天都会读两篇文章的媒体网站没了，那里的文章缤纷多彩，最后都变成了该页无法显示几个字。再过几个月，大学的网站不让上了，摄影师的网站不让上了，就连百度日本这种自家网站，也没了。</p><p>　　接着，漫画看不了了，接着，动画看不成了。接着，美剧英剧失踪了。下载美剧英剧的网站又又又失踪了。尊重正版，保护权益，行吧，然后字幕网站也没了。</p><p>　　游戏没了，你习惯性登陆的游戏网站，发现下载栏正在整治中。论坛关了，天天都在看的论坛，突然接到相关部门的电话，因为“报备问题”不让办了。个人网站，私人博客，对不起，说没就没有，你在上面存了多少多年辛勤耕耘的东西都没用。</p><p>　　你关注的人，有一天你登陆微博，发现他怎么好久都没说话了，然后你搜索了一下，发现他的账号不存在了，而且你搜他的名字，他的名字未予显示。</p><p>　　一盏一盏的灯，灭了。四面八方的光源，消失了。我们生活的五光十色的世界，变成了一片黑色。</p><p>　　天黑了，那么睡觉吧，但愿长醉不复醒。</p><p>　　最后，我们变成了一群做梦的人，这个梦的名字，叫根据相关法律法规，相关搜索结果不予显示梦。</p>]]></content>
      
      
      <categories>
          
          <category> 转载区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 灌水区 </tag>
            
            <tag> 文章转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【成长之路】记我的第一场ACM</title>
      <link href="2019/08/11/my-first-acm/"/>
      <url>2019/08/11/my-first-acm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>转眼间，来浙江集训也有十来天了。好像自从来到这里开始，我就一直在期待这场ACM。</p><p>虽说之前了解过一点ACM的知识，但也仅限于别人的Blog与游记之中。自己的亲身体验，也还是第一次。</p><p>这场ACM，打的也真的算是一波三折。</p><p>不过最后结果还挺不错的，也算一次非凡的经历吧。</p><hr><h2 id="赛前组队"><a href="#赛前组队" class="headerlink" title="赛前组队"></a>赛前组队</h2><p>赛前一天，大家都处于欢乐的组队状态之中</p><p>之前我和一起来浙江的ygj，jzx约好一队，可比赛前一天中午我们却又因为各种各样的原因决定重新组队。</p><p>上课之前，我在教室前排吆喝了一句还有队伍缺人吗？过了一会，南外的zxb与金华的wd dalao就来拉我进队。</p><p>然后我们就在一起想队名，直到快下课我们才想到了一个还中听的名字，叫$\text{Lemon}$$。</p><p>之后听说Rank 1可以拿到烤肉券，但我们也不觉得自己能拿到，所以就没把这个当回事。</p><p>除此之外就是各种$\text{fAKe}$</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/11/expZCj.jpg" alt="expZCj.jpg"></p><p><del>我才不会告诉你那个端茶倒水的是我呐o(´^｀)o</del></p><hr><h2 id="比赛的小插曲"><a href="#比赛的小插曲" class="headerlink" title="比赛的小插曲"></a>比赛的小插曲</h2><p>比赛前一天晚上，我习惯性的登录了一下Codeforces，却发现Codeforces的页面没了</p><p>“或许又被鸽到长城外边去了？”我心里这样想着，但又有种不是很好的感觉，也没多想就睡觉了。</p><p>结果第二天，我的感觉真TM灵验了！Codeforces真TM炸了！</p><p>更可怕的是，我们的题目都是依靠Codeforces进行评测的。</p><p>就这样，我们打了一天的三人$\text{OI}$赛制……</p><p>到了下午，Codeforces还是没好，没办法，SR老师只好先讲题。</p><p>在讲题时，我发现我们打的基本都是正解，也就是说，如果Codeforces没炸的话，我们应该会是前几名。</p><p><del>自闭ing</del></p><p>到了晚上，我给Logey，HandwerSTD，Shq抱怨这事，结果一句安慰都没得到……</p><p><del>自闭$\times$ 2 ing</del></p><p>不过第二天，SR老师说等毛老师来了之后还会给我们补一场ACM。之后我就重新回到了期待之中</p><hr><h2 id="正式比赛"><a href="#正式比赛" class="headerlink" title="正式比赛"></a>正式比赛</h2><h3 id="比赛前"><a href="#比赛前" class="headerlink" title="比赛前"></a>比赛前</h3><p>三天后，毛老师果然给我们补了一场ACM。</p><p>比赛前一天晚上，我想早睡，可Herself32却要暴切黑题来吊打我……</p><p>于是乎，我又陪她熬到了十二点半……</p><p>结果第二天早上，Herself32又赖床，咋都叫不醒，快八点才从床上爬起来<del>（Herself32：嘤）</del></p><p>等我到教室的时候，教室已经基本坐满了，但幸好zxb与wd dalao为我留了位置。</p><p>过了不到5分钟毛老师就开始下放密码。</p><p>当我看到密码的那一刻，我真心有种智熄的感觉……</p><p><a href="https://imgchr.com/i/ex9DO0"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/11/ex9DO0.jpg" alt="ex9DO0.jpg"></a></p><p><del>毛老师您是魔鬼吗？？？</del></p><hr><h3 id="比赛开始"><a href="#比赛开始" class="headerlink" title="比赛开始"></a>比赛开始</h3><p>拿到密码之后我们就开始看题……一人一道，zxb和wd dalao正序开题，我倒序。</p><p>看到$J$题的第一眼我就发现这是一颗需要区间$gcd$线段树，<del>但我不会写</del>。</p><p>又一看$I$题，艹，这是什么神仙题，怎么那么多圆？<del>(后来才知道那是一道SB数学题)</del></p><p>而zxb dalao那边已经开始做$A$题，在大概15分钟的时候我们交了一发$A$，结果T到飞起。</p><p>而我开始看$D$题，不久便想到了一个时间复杂度为$O(n^2)$的做法，后来优化成了$O(nlogn)$，交了一发，过了。</p><p>与此同时，zxb他们也想到了第一题的优化做法，交了一发，也过了。</p><p>就这样，我们在开场$1$个小时之后成了全场Rank 1。</p><hr><h3 id="稳住，别浪"><a href="#稳住，别浪" class="headerlink" title="稳住，别浪"></a>稳住，别浪</h3><p>可Rank 1的排名并没有持续太久，一回便被反超了。</p><p>于是乎，我开始肝$B$题，zxb开始肝$I$题，而wd开始肝$E$题。</p><p>当我看到$B$题时，我只知道它要考$xor$的某些性质，但我并不知道它到底想考那条性质。</p><p>so……我便一条条的回想$xor$的性质。</p><p>大概5分钟后，我的脑海里浮现出了一句话</p><blockquote><p>$xor$的逆运算是其本身，也就是说(a ^ b) ^ b = a</p></blockquote><p>然后，我便把思路告诉了zxb，不久后，我们队伍就A了这道题。</p><p>又过了一会，zxb切掉了$I$题，我们队伍又回到了Rank 1。</p><p>此时，距离比赛结束还有3个小时。</p><hr><h3 id="惊险又刺激的30min"><a href="#惊险又刺激的30min" class="headerlink" title="惊险又刺激的30min"></a>惊险又刺激的30min</h3><p>之后，我们队伍就一直在Rank 1保持着。</p><p>但大约1个小时之后，事情又出现了转机。</p><p>1个小时之后，我们的队伍又被再次反超，这次的对手，是ZROI-D班的一哥。</p><p>说实话，我们都没有信心能够打败这样的对手。但我们一直在努力争取着，不让他们与我们拉开太大的分数。</p><p>很快，我们就A掉了除了$E$，$F$的所有题，而对手，也是一样。</p><p>这时，就看谁能更快$A$掉剩下的两题了。</p><p>我和zxb一起肝$F$，但对手好像更快，没过多久，他们就$A$掉了$F$题</p><p>我们的压力更大了……</p><p>我手造了几组样例，一直试图找到其中的规律，可无奈怎也找不到。</p><p>没办法，只好写了个爆搜交了上去。</p><p>结果</p><p><strong>A了</strong></p><p><del>我艹这TM什么辣鸡数据啊</del></p><p>之后我们两个便与wd一起搞$E$题，但可惜到最后也没搞出来。</p><p>而对手根本没有考虑到我们之前已经写了一部分$E$，再加上他们罚时过多，知道自己没有翻盘的可能，便开始摸起了鱼。</p><p>最后，我们真的成功拿到了Rank 1。</p><p><strong>我们，成功了</strong></p><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这次的ACM中我们打出了不错的成绩，我认为有以下几点原因</p><ol><li>队伍分工比较明确。</li><li>每个人都各有所长，都可以得以发挥</li><li>提前写了一道别人没有写的题目，在最后关头抢到了先机</li><li>意志坚定，没人摸鱼。</li></ol><p>当然了，这是我的第一场ACM，但肯定不是最后一场。未来，还有很长的路要走呐</p><p>加油吧OvO</p><hr><h2 id="花絮"><a href="#花絮" class="headerlink" title="花絮"></a>花絮</h2><p>顺便晒一下今天晚上Rank1的奖品<del>(故意挑事.jpg)</del></p><p><a href="https://imgchr.com/i/exAeTP"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/12/exAeTP.jpg" alt="exAeTP.jpg"></a></p><p><a href="https://imgchr.com/i/exAuY8"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/12/exAuY8.jpg" alt="exAuY8.jpg"></a><br><a href="https://imgchr.com/i/exAKfS"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/12/exAKfS.jpg" alt="exAKfS.jpg"></a></p><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 成长之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长之路 </tag>
            
            <tag> 灌水区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学】同余问题</title>
      <link href="2019/08/09/math1/"/>
      <url>2019/08/09/math1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>同余即余数相同，同余问题是OI中比较经典的问题。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的时候作者一直想要学习数论，可无奈……每一次都<del>咕掉了</del>没时间</p><p>而今天，作者终于抽出了一个晚上。</p><p>于是，便有了这篇博客。</p><hr><h2 id="基本概念-amp-定义"><a href="#基本概念-amp-定义" class="headerlink" title="基本概念&amp;定义"></a>基本概念&amp;定义</h2><p>在本文中，我们主要讲解同余问题。</p><p>在讲解之前，我们先来了解一点有关余数的基本概念。</p><h3 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h3><p>假设我们有两个整数 $a$ , $b$，若$ka = b$， 则我们称$b$整除$a$，记为$a|b$。</p><h3 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h3><p>模数即余数，在数学中，我们把整数$a$与整数$b$的模数记为$a\mod b$。</p><p>在这里，$mod$相当于C++中的$\%$运算。</p><p>根据定义，我们可以得出$a \mod b = a - ⌊\frac{a}{b}⌋ \times b$。</p><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>若$a \mod c = b \mod c$, 则称$a$与$b$在模$c$意义下同余，写作$a \equiv b (\mod c)$</p><h3 id="模运算的基本性质"><a href="#模运算的基本性质" class="headerlink" title="模运算的基本性质"></a>模运算的基本性质</h3><p>下面给出几个模运算的基本性质，请各位读者自行证明。</p><p>其中，第一个公式就是上面取模部分的公式</p><script type="math/tex; mode=display">a \mod b = a - ⌊\frac{a}{b}⌋ \times b</script><script type="math/tex; mode=display">a \equiv b(\mod m) \iff m | (a − b)</script><script type="math/tex; mode=display">b \equiv c \iff a + b \equiv a + c</script><p>以上的公式均满足$a , b , c , m ∈ Z$</p><hr><h2 id="Gcd-欧几里得算法"><a href="#Gcd-欧几里得算法" class="headerlink" title="Gcd(欧几里得算法)"></a>Gcd(欧几里得算法)</h2><p><code>gcd</code>是最大公约数的英文缩写<del>(也是某个红色政治组织的简称)</del>，$a$与$b$的最大公约数记为$gcd(a , b)$</p><p>而欧几里得算法专门用来求两个数的$gcd$，下面，我们就对其进行证明。</p><h3 id="求证"><a href="#求证" class="headerlink" title="求证"></a>求证</h3><script type="math/tex; mode=display">gcd(a , b) = gcd(b , a\mod b)</script><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>当$a &lt; b$时，我们交换$a$与$b$的位置，这样我们只需要考虑$a &gt; b$的情况.</p><p>当$a &gt; b$时，有</p><script type="math/tex; mode=display">a = kb + r (k , r ∈ Z)</script><p>其中，$r$为$a \mod b$，$k$为$⌊\frac{a}{b}⌋$。</p><p>现在我们移项，可得</p><script type="math/tex; mode=display">r = a - kb</script><script type="math/tex; mode=display">\because gcd(a , b) | a , gcd(a , b) | b</script><script type="math/tex; mode=display">\therefore gcd(a , b) | a - k \times b</script><script type="math/tex; mode=display">\therefore gcd(a , b) | r</script><script type="math/tex; mode=display">\because r = a \mod b</script><script type="math/tex; mode=display">\therefore gcd(a , b) | a \mod b</script><script type="math/tex; mode=display">\therefore gcd(a , b) = gcd(b , a\mod b)</script><p>大功告成啦ヾ(^∀^)ﾉ</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>直接递归实现，边界条件为$b = 0$，若$b = 0$，直接返回$a$即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b , a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>顺便求一下两个数的最小公倍数</p><script type="math/tex; mode=display">lcm(a , b) = \frac{a\times b}{gcd(a , b)}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / gcd(a , b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Exgcd-扩展欧几里得"><a href="#Exgcd-扩展欧几里得" class="headerlink" title="Exgcd(扩展欧几里得)"></a>Exgcd(扩展欧几里得)</h2><p><code>exgcd</code>相当于$Gcd$的升级版，它可以在求出$gcd(a , b)$的同时求出二元一次不定方程 $ax + by = gcd(a , b)$的一组整数解。</p><p>其中，$a$,$b$均为已知的，且$a , b , x , y ∈ Z$。</p><h3 id="举个栗砸"><a href="#举个栗砸" class="headerlink" title="举个栗砸"></a>举个栗砸</h3><p>在求$gcd(71 , 13)$时，我们得到了以下式子</p><script type="math/tex; mode=display">71 = 13 \times 5 + 6</script><script type="math/tex; mode=display">13 = 6 \times 2 + 1</script><p>现在我们移一下项，把余数都移到左边,就成了下面这个样子</p><script type="math/tex; mode=display">6 = 71 + 13\times (-5)</script><script type="math/tex; mode=display">1 = 13 + 6\times (-2)</script><p>从$gcd(71 , 13)$开始，把我们刚刚推出的式子一一带入，就成了下面的样子</p><p>$gcd(71 , 13)$<br>$= 1$<br>$= 13 + 6\times (-2)$<br>$= 13 + [71 + 13\times(-5)]\times(-2)$<br>$= 13 \times 11 + 71 \times (-2)$<br>$= 71 \times (-2) + 13 \times 11$</p><p>看最后一个式子，是不是就是$a = 71$ ,$b = 13$时的不定方程？</p><p>所以解为$x = -2$, $y = 11$。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b , <span class="keyword">int</span> g , <span class="keyword">int</span> &amp;x , <span class="keyword">int</span> &amp;y )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        g = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        exgcd(b , a % b , g , y , x);</span><br><span class="line">        y -= x * (a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="oi.men.ci">Menci’s Blog</a></p></li><li><p><a href="http://inspiral.coding.me/">Struct 瓶子’s Blog</a></p></li></ol><p>鸣谢上面两位dalao在数论学习方面给予我的帮助</p><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> Gcd </tag>
            
            <tag> 数论 </tag>
            
            <tag> Exgcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论算法】Tarjan(割点 &amp; 割边)</title>
      <link href="2019/08/04/Tarjan-point&amp;edge/"/>
      <url>2019/08/04/Tarjan-point&amp;edge/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://imgchr.com/i/eyhLF0"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/04/eyhLF0.jpg" alt="eyhLF0.jpg"></a></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在昨晚(2019/8/3)模拟赛爆炸后，作者没脸在$C$班混下去了……</p><p>于是，作者便滚回了$D$，开始了被吊打的生活……</p><hr><h2 id="浅谈Tarjan"><a href="#浅谈Tarjan" class="headerlink" title="浅谈Tarjan"></a>浅谈Tarjan</h2><p>在介绍Tarjan算法之前，我们先来看一下百度百科的解释：</p><blockquote><p>一种由Robert Tarjan提出的求解有向图强连通分量的线性时间的算法。   ——《百度百科》</p></blockquote><p><del>真心够短</del></p><p>还是来看下更加通俗易懂的解释吧</p><p>Tarjan算法是由美国计算机学家Robert Tarjan提出的一系列算法，并不是一种算法。</p><p>在OI中，我们经常会用到Tarjan算法求割点，割边以及强连通分量。</p><p>同时，Tarjan算法还可以用来进行缩点，以简便我们的运算。</p><p>在本篇博客中，我们主要介绍用Tarjan求割点，割边。<del>至于强连通分量什么的……就当我没带眼镜听不见好了o(´^｀)o</del></p><hr><h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><p>在介绍Tarjan求割点，割边之前，我们先来了解一些芝士</p><h3 id="DFS树"><a href="#DFS树" class="headerlink" title="DFS树"></a>DFS树</h3><p>顾名思义，$DFS$树即在$DFS$过程中形成的树</p><p>就像这张图</p><p><a href="https://imgchr.com/i/e6VBpq"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/04/e6VBpq.png" alt="e6VBpq.png"></a></p><p>如果以$0$为起始点进行$DFS$，它的$DFS$树是这样的(画法不唯一)</p><p><a href="https://imgchr.com/i/eyXI61"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/04/eyXI61.jpg" alt="eyXI61.jpg"></a></p><p>仔细看一下上图，不难看出<strong>一颗DFS树不存在重复节点，也不存在跨子树的边</strong></p><hr><h3 id="DFS序"><a href="#DFS序" class="headerlink" title="DFS序"></a>DFS序</h3><p>同理，$DFS$序即$DFS$经过点的顺序。</p><p>还是刚才的图</p><p><a href="https://imgchr.com/i/e6VBpq"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/04/e6VBpq.png" alt="e6VBpq.png"></a></p><p>如果以$0$为起始点进行$DFS$，它的$DFS$序为$0 , 1 , 2 , 3 , 4$</p><hr><h3 id="割点-amp-割边の定义"><a href="#割点-amp-割边の定义" class="headerlink" title="割点&amp;割边の定义"></a>割点&amp;割边の定义</h3><p>既然我们要求的是割点与割边，那么它们的定义又是什么呐？</p><p>别急，我们这就介绍</p><p><strong>割点</strong>就是<strong>把这个点在图中删去后，图中连通块的个数会增加</strong>的点</p><p>同理，<strong>割边</strong>就是<strong>把这条边在图中删去后，图中连通块个数会增加</strong>的边</p><p>还是用这张图</p><p><a href="https://imgchr.com/i/e6VBpq"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/04/e6VBpq.png" alt="e6VBpq.png"></a></p><p>在这张图中，割点为点$0 , 3$。</p><hr><h2 id="Tarjan求割边"><a href="#Tarjan求割边" class="headerlink" title="Tarjan求割边"></a>Tarjan求割边</h2><p>好，相信你现在<del>已经完全理解了上面的内容</del>，那么，我们现在开始介绍Tarjan求割边。</p><p>在想正解之前，我们先来想想暴力一点的做法</p><hr><h3 id="暴力删边"><a href="#暴力删边" class="headerlink" title="暴力删边"></a>暴力删边</h3><p>最暴力的想法应该就是每一次枚举一条边，将其删去，看是不是将原有的连通块拆分成多个连通块。</p><p>时间复杂度$O(n^2)$<del>妥妥的TLE</del></p><hr><h3 id="生成树删边"><a href="#生成树删边" class="headerlink" title="生成树删边"></a>生成树删边</h3><p>对于刚刚的做法，我们有什么可以优化的吗？</p><p>答案是肯定的。</p><p>我们可以先寻找任意一颗生成树，然后仅判断生成树上的边是不是割边</p><p>正确性也很显然：因为生成树已经连接了所有的节点（原来就不连通的节点除外）。所以我们只要判断是不是有另一条边能绕过它即可</p><p>时间复杂度$O(n\times m)$，在数据较大时还是会超时。</p><hr><h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><p>仔细观察，我们不难得出结论：<strong>环上的边绝对不是割边，即不是割边的边都在某个环上</strong></p><p>既然如此，我们就可以<del>大胆猜想</del>：<strong>不在任何一个环上的边为割边</strong></p><p>所以我们先跑一遍$DFS$，求出$DFS$树，然后我们把图中的非树边（即不在$DFS$树上的边）加入$DFS$树中，看哪一条边被覆盖了。</p><p>那些没有被覆盖的边，即为割边。</p><p>在写代码时，我们开一个名为$dfn$的数组记录$DFS$序，再开一个名为$low$的数组用于表示在DFS树的x的子树中，非树边往上指最小的DFS序。</p><p>之后直接模拟即可</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Tarjan_Edge&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> N 500001</span></span><br><span class="line">    <span class="keyword">int</span> dfn[N];</span><br><span class="line">    <span class="keyword">int</span> low[N];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> root , <span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">        dfn[root] = low[root] = cnt ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = end[root] ; i ; i = edge[i].last)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[to])&#123;</span><br><span class="line">                Tarjan(to , root);</span><br><span class="line">                low[root] = min(low[root] , low[to]);</span><br><span class="line">                <span class="keyword">if</span>(low[to] &gt; dfn[root])&#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; root &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; to &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(to != pre)&#123;</span><br><span class="line">                low[root] = min(low[root] , dfn[to]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Tarjan求割点"><a href="#Tarjan求割点" class="headerlink" title="Tarjan求割点"></a>Tarjan求割点</h2><p>首先，对于一个根节点，如果它DFS树中的子树数量大于等于2，则它一定为割点</p><p>那么对于一个非根节点呐？</p><p>对于非根节点，<strong>我们要满足有一条非树边指向其DFS树上的祖先，他才会是一个割点。</strong>也就是说对于一个节点$u$，如果它是割点，那么满足$low[v] &lt; dfn[u]$;</p><p>剩下的直接照抄即可</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Tarjan_point&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> N 500001</span></span><br><span class="line">    <span class="keyword">int</span> dfn[N];</span><br><span class="line">    <span class="keyword">int</span> low[N];</span><br><span class="line">    <span class="keyword">bool</span> cut[N];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        dfn[x] = low[x] = ++ cnt;</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = end[x] ; i; i = edge[i].last)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[to])&#123;</span><br><span class="line">                Tarjan(to , fa);</span><br><span class="line">                low[x] = min(low[x] , low[to]);</span><br><span class="line">                <span class="keyword">if</span>(low[to] &gt;= dfn[x] &amp;&amp; x != fa)&#123;</span><br><span class="line">                    cut[x] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(x == fa)&#123;</span><br><span class="line">                    child ++;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">            low[x] = min(low[x] , dfn[to]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(child &gt;= <span class="number">2</span> &amp;&amp; x == fa)&#123;</span><br><span class="line">            cut[x] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="附件-割点模板"><a href="#附件-割点模板" class="headerlink" title="附件[割点模板]"></a>附件[割点模板]</h2><p>代码描述：见<a href="https://www.luogu.org/problem/P3388">luoguP3388</a></p><p>Code:</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> end head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_number;</span><br><span class="line"><span class="keyword">int</span> end[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    edge[++ edge_number].to = to;</span><br><span class="line">    edge[edge_number].last = end[from];</span><br><span class="line">    end[from] = edge_number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tarjan_point&#123;</span><br><span class="line">    <span class="keyword">int</span> dfn[N];</span><br><span class="line">    <span class="keyword">int</span> low[N];</span><br><span class="line">    <span class="keyword">bool</span> cut[N];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        dfn[x] = low[x] = ++ cnt;</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = end[x] ; i; i = edge[i].last)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[to])&#123;</span><br><span class="line">                Tarjan(to , fa);</span><br><span class="line">                low[x] = min(low[x] , low[to]);</span><br><span class="line">                <span class="keyword">if</span>(low[to] &gt;= dfn[x] &amp;&amp; x != fa)&#123;</span><br><span class="line">                    cut[x] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(x == fa)&#123;</span><br><span class="line">                    child ++;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">            low[x] = min(low[x] , dfn[to]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(child &gt;= <span class="number">2</span> &amp;&amp; x == fa)&#123;</span><br><span class="line">            cut[x] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Tarjan_point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> a , b;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add_edge(a , b);</span><br><span class="line">        add_edge(b , a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dfn[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            Tarjan(i , i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i])&#123;</span><br><span class="line">            ans ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i])&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图论 </tag>
            
            <tag> Tarjan </tag>
            
            <tag> DFS序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【位运算】 &amp; 【NOI2014】起床困难综合症-题解</title>
      <link href="2019/08/02/Bit-operation/"/>
      <url>2019/08/02/Bit-operation/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>计算转化成位运算快如闪电，按位与或非异或还有左右移小数点。<br> ——《我们仍未知道那天所见算法的名字》</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SDSC刚刚结束，作者便踏上了前往浙江的旅程。结果……Day1就是状压DP</p><p>so……作者便开始疯狂补习位运算</p><hr><h2 id="何为位运算？"><a href="#何为位运算？" class="headerlink" title="何为位运算？"></a>何为位运算？</h2><p>位运算就是将一个十进制数转换为一个二进制数后，对其中每一位进行运算所得到的结果。</p><p>平时<del>爱颓废</del>对计算机原理感兴趣的同学们都知道，<strong>计算机中的内容是用二进制数表示的</strong>。</p><p>而我们平时所用的$+$，$-$，$\times$，$/$都是在十进制下进行的运算。</p><p>这样的话，在每次运算之前计算机都会把二进制转为十进制。造成时间上的浪费</p><p>而位运算则可以直接在二进制上进行操作，因此，<strong>位运算的时间效率是比较高的</strong>。<del>(卡常神器)</del></p><hr><h2 id="位运算的基本操作"><a href="#位运算的基本操作" class="headerlink" title="位运算的基本操作"></a>位运算的基本操作</h2><p>常用的位运算有$6$种，分别为与(<code>&amp;</code>) ， 或(<code>|</code>) ，异或(<code>^</code>) ，取反(<code>~</code>) ，左移(<code>&lt;&lt;</code>) ， 右移(<code>&gt;&gt;</code>)。</p><p>下面，我们就对这几种运算进行解读。</p><h3 id="与-amp-，或-，异或"><a href="#与-amp-，或-，异或" class="headerlink" title="与(&amp;)，或(|)，异或(^)"></a>与(&amp;)，或(|)，异或(^)</h3><p>这三种运算都是在两者间进行比较的运算。</p><p>它们的性质如下表</p><div class="table-container"><table><thead><tr><th>位运算符</th><th>英文</th><th>集合符号</th><th>性质</th></tr></thead><tbody><tr><td>与</td><td>$and$</td><td>$∩$</td><td>只有两个对应的位数均为1时才会为1</td></tr><tr><td>或</td><td>$or$</td><td>$∪$</td><td>两个对应位数中只要有一位为1就会为1           </td></tr><tr><td>异或</td><td>$xor$</td><td>无</td><td>两个对应位数的值相同时为0，不同时为1</td></tr></tbody></table></div><p>同时，<code>^</code>的逆运算是其本身，也就是说两次^同一个数的结果是不变的。比如<code>(a ^ b) ^ b = a</code></p><p>举个栗砸：</p><p><a href="https://imgchr.com/i/eBQQhR"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/02/eBQQhR.jpg" alt="eBQQhR.jpg"></a></p><hr><h3 id="取反"><a href="#取反" class="headerlink" title="取反(~)"></a>取反(~)</h3><p>取反就是对一个数进行取反运算。即对于每一位如果该位是$1$就变成$0$，是$0$就变成$1$.</p><p>但要注意，这并不是直接对其进行取反，而是对他的补码进行取反。</p><p>蛤，您不知道补码是蛤？</p><p>那我放一个关于补码的解释：</p><p>一个正数的补码是它本身，负数的补码是其取反后 $+ 1$</p><p>就像下图：</p><p><a href="https://imgchr.com/i/eB18eO"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/03/eB18eO.jpg" alt="eB18eO.jpg"></a></p><hr><h3 id="左移-lt-lt-，右移-gt-gt"><a href="#左移-lt-lt-，右移-gt-gt" class="headerlink" title="左移(&lt;&lt;)，右移(&gt;&gt;)"></a>左移(<code>&lt;&lt;</code>)，右移(<code>&gt;&gt;</code>)</h3><p>很显然，这两种操作是将一个数二进制位进行移动。</p><p>其中，左移(<code>num &lt;&lt; k</code>)是将$num$转为二进制后向左移动$k$位，右移(<code>num &gt;&gt; k</code>)是向右移动$k$位。</p><p>举个例子：</p><p><a href="https://imgchr.com/i/ercnVU"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/03/ercnVU.jpg" alt="ercnVU.jpg"></a></p><p>从上面的例子中不难看出，<code>5 &lt;&lt; 1</code>相当于$5 \times 2^1$，而<code>5 &gt;&gt; 1</code>就相当于$5 / 2 ^ 1$(向下取整).</p><p>事实上，在$num$为整数的情况下，<code>num &lt;&lt; k</code>等价于$num \times 2^k$ , <code>num &gt;&gt; k</code>等价于$num / 2 ^ k$。，</p><hr><h2 id="位运算的应用"><a href="#位运算的应用" class="headerlink" title="位运算的应用"></a>位运算的应用</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>对于每一个数，它的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。</p><p>比如集合 <code>&#123;1, 3, 4, 8&#125;</code> ，可以将其表示成 <code>100011010</code> ，十进制就是 $2^8 + 2^4 + 2^3 + 2^1 = 282$。</p><p>这样的话，位运算就代表了其对应集合的操作</p><div class="table-container"><table><thead><tr><th>操作</th><th>集合符号</th><th>位运算语句</th></tr></thead><tbody><tr><td>交集</td><td>$a ∩ b$</td><td><code>a &amp; b</code></td></tr><tr><td>并集</td><td>$a ∪ b$</td><td>`a</td><td>b`</td></tr><tr><td>补集</td><td>$ā$</td><td><code>~a</code></td></tr><tr><td>差集</td><td>$a$ <code>\</code> $b$</td><td><code>a &amp; (~b)</code></td></tr></tbody></table></div><hr><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>不多说，直接上代码。</p><h4 id="乘以2"><a href="#乘以2" class="headerlink" title="乘以2"></a>乘以2</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="除以2"><a href="#除以2" class="headerlink" title="除以2"></a>除以2</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line"></span><br><span class="line">#### 乘以<span class="number">2</span>的m次方</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="除以2的m次方"><a href="#除以2的m次方" class="headerlink" title="除以2的m次方"></a>除以2的m次方</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;&gt; m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="判断一个数的奇偶性"><a href="#判断一个数的奇偶性" class="headerlink" title="判断一个数的奇偶性"></a>判断一个数的奇偶性</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">1</span>;   <span class="comment">//奇数返回true，偶数返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="对2的n次方取模"><a href="#对2的n次方取模" class="headerlink" title="对2的n次方取模"></a>对2的n次方取模</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mod &amp; (n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="求两个整数的平均值"><a href="#求两个整数的平均值" class="headerlink" title="求两个整数的平均值"></a>求两个整数的平均值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="遍历一个集合中的子集"><a href="#遍历一个集合中的子集" class="headerlink" title="遍历一个集合中的子集"></a>遍历一个集合中的子集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s2 = S1; S2 &gt; <span class="number">0</span>; S2 = (S2 - <span class="number">1</span>) &amp; S1);</span><br></pre></td></tr></table></figure><hr><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>下面我们就以这道题目为例来讲解位运算的实际应用</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。</p><p>作为一名青春阳光好少年，$atm$一直坚持与起床困难综合症作斗争。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/08/03/7vH9NrpIkPWFl4q.jpg" alt="u=214682120,3059573823&amp;fm=26&amp;gp=0.jpg"></p><p>通过研究相关文献，他找到了该病的发病原因：</p><p>在深邃的太平洋海底中，出现了一条名为$drd$的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/08/03/ibQcKWIEFUACXav.jpg" alt="58477ba3d972fcd1dd9bff9b56354b95.jpg"></p><p>正是由于$drd$的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。</p><p>为了彻底消灭这种病，$atm$决定前往海底，消灭这条恶龙。</p><p>历经千辛万苦，$atm$终于来到了$drd$所在的地方，准备与其展开艰苦卓绝的战斗。</p><p>$drd$有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。</p><p>具体说来，$drd$的防御战线由$n$扇防御门组成。每扇防御门包括一个运算$op$和一个参数$t$，其中运算一定是$OR,XOR,AND$中的一种，参数则一定为非负整数。</p><p>如果还未通过防御门时攻击力为$x$，则其通过这扇防御门后攻击力将变为$x$ $op$ $t$。最终$drd$受到的伤害为对方初始攻击力$x$依次经过所有$n$扇防御门后转变得到的攻击力。</p><p>由于$atm$水平有限，他的初始攻击力只能为$0$到$m$之间的一个整数（即他的初始攻击力只能在 $0, 1, … , m$中任选，但在通过防御门之后的攻击力不受$m$的限制）。</p><p>为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让$drd$受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使$drd$受到多少伤害。</p><hr><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入文件的第 $1$ 行包含 $2$ 个整数，依次为$n, m$，表示 $drd$ 有$n$扇防御门，$atm$ 的初始攻击力为$0$到$m$之间的整数。</p><p>接下来$n$行，依次表示每一扇防御门。</p><p>每行包括一个字符串$op$和一个非负整数$t$，两者由一个空格隔开，且$op$在前，$t$在后，$op$表示该防御门所对应的操作，$t$表示对应的参数。</p><hr><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出一行一个整数，表示$atm$的一次攻击最多使$drd$受到多少伤害。</p><hr><h3 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h3><h4 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 10</span><br><span class="line">AND 5</span><br><span class="line">OR 6</span><br><span class="line">XOR 7</span><br></pre></td></tr></table></figure><h4 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><hr><h3 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/08/03/w6LzdS24lybkJ5U.png" alt="1246.png"></p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>不知道有没有人想到这张图<del>（反正我是想到了）</del></p><p><a href="https://imgchr.com/i/er4zNV"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/03/er4zNV.jpg" alt="er4zNV.jpg"></a></p><p>咳咳，回到正题。</p><p>首先我们设两个变量，分别为一个很大的数和$0$，然后我们把那些奇怪的门先过一遍，我们就可以得到每一位的真值表</p><p>对于每一位，真值表会有以下$4$种。</p><blockquote><p>0 -&gt; 0 ， 1 -&gt; 0<br>0 -&gt; 0 ， 1 -&gt; 1<br>0 -&gt; 1 ， 1 -&gt; 0<br>0 -&gt; 1 ,  1 -&gt; 1</p></blockquote><p>再根据贪心的原则，一个二进制数前边几位的$1$越多，造成的伤害也就越多。</p><p>所以我们就要让每一位尽量的变成$1$</p><p>无疑，对于可以从$0$变成$1$的情况，我们直接变$1$。而对于从$1$开始变的情况，我们要分两种情况讨论</p><p>如果是$1$变$1$，只要只要攻击力大于等于这一位需要的攻击力，就变</p><p>$1$变$0$的话就直接忽略就好啦</p><p><del>是不是很简单啊(逃)</del></p><hr><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="built_in">string</span> opt;</span><br><span class="line"><span class="keyword">int</span> a[N] , b[N];</span><br><span class="line"><span class="keyword">int</span> ans , tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>)&#123;</span><br><span class="line">            x = (x &amp; b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] == <span class="number">2</span>)&#123;</span><br><span class="line">            x = (x | b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            x = (x ^ b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; opt;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="string">&quot;AND&quot;</span>)&#123;</span><br><span class="line">            a[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="string">&quot;OR&quot;</span>)&#123;</span><br><span class="line">            a[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a[i] = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = calc(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; i ++)&#123;</span><br><span class="line">        f[i] = (calc(<span class="number">1</span> &lt;&lt; i) &amp; (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; i) &amp; t)&#123;</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((tot + (<span class="number">1</span> &lt;&lt; i) &lt;= m) &amp;&amp; f[i])&#123;</span><br><span class="line">            tot += f[i];</span><br><span class="line">            ans += f[i];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> NOI </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LYOI】LYOI Summer Round1题解&amp;命题总结</title>
      <link href="2019/07/20/LYOI-Summer-Round-1/"/>
      <url>2019/07/20/LYOI-Summer-Round-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一套超级简单而又神奇的题目<br>（Upd：文章部分转载，已署名）</p><a id="more"></a><h2 id="Grades"><a href="#Grades" class="headerlink" title="Grades"></a>Grades</h2><p>Liuzhe dalao出的<del>签到题</del></p><p>而且卡了冒泡排序这种朴素算法……</p><p>尽管如此，方法还是有很多。比如手打快排，手打归并……</p><p>但在这里，我们使用STL内置的$sort$函数。</p><p>另外需要注意的是，由于我们需要使用结构体进行交换，因此，我们需要手打$cmp$函数</p><p>基本没什么难度吧……</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">&#125;stu[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Student a , Student b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.grade &gt; b.grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; stu[i].num &gt;&gt; stu[i].grade;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(stu + <span class="number">1</span> , stu + <span class="number">1</span> + n , cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; stu[i].num &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; stu[i].grade &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Witten By Payphone-X</span></span><br></pre></td></tr></table></figure><hr><h2 id="Unturned"><a href="#Unturned" class="headerlink" title="Unturned"></a>Unturned</h2><p>Struct瓶子 julao出的数据结构题……</p><p>考的是一种极其基础的数据结构：<strong>栈</strong></p><p>我们重新读一遍题目，会发现上边有三种操作：</p><blockquote><ul><li><p>$1$，$s$，$a$，$b$ 表示从你现在的所在地前往到另一个名称为$s$，物资值为$a$，危险值为$b$的地方。</p></li><li><p>$2$ 表示从你现在的所在地返回到你上一次前往的地方(原路返回)。若现在在$Liberator$号上，则无视。</p></li><li><p>$3$ 表示查询你现在的所在地的名称、物资值和危险值。若现在在$Liberator$号上，则输出$-1$。</p></li></ul></blockquote><p>其中，三种操作分别对应了栈的操作中的<strong>入栈</strong>，<strong>弹出栈顶</strong>，<strong>获取栈顶元素</strong>。</p><p>所以我们可以写一个栈，直接进行模拟即可。</p><p>还有什么的话，就是</p><p><strong>注 意 细 节</strong></p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Place</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> thing;</span><br><span class="line">    <span class="keyword">int</span> danger;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;Place&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>  , <span class="built_in">string</span>&gt; Thing_max;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>  , <span class="built_in">string</span>&gt; Danger_max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p_num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    p[p_num].name = <span class="string">&quot;Liberator&quot;</span>;</span><br><span class="line">    p[p_num].thing = <span class="number">0</span>;</span><br><span class="line">    p[p_num].danger = <span class="number">0</span>;</span><br><span class="line">    S.push(p[p_num]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; opt;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">            p_num ++;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; p[p_num].name &gt;&gt; p[p_num].thing &gt;&gt; p[p_num].danger;</span><br><span class="line">            <span class="keyword">if</span>(p[p_num].thing &gt; Thing_max.first)&#123;</span><br><span class="line">                Thing_max.first = p[p_num].thing;</span><br><span class="line">                Thing_max.second = p[p_num].name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p[p_num].danger &gt; Danger_max.first)&#123;</span><br><span class="line">                Danger_max.first = p[p_num].danger;</span><br><span class="line">                Danger_max.second = p[p_num].name;</span><br><span class="line">            &#125;</span><br><span class="line">            S.push(p[p_num]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S.top().name == <span class="string">&quot;Liberator&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            S.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S.top().name == <span class="string">&quot;Liberator&quot;</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; S.top().name &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; S.top().thing &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; S.top().danger &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.top().name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Thing_max.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Danger_max.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Written By Payphone-X</span></span><br></pre></td></tr></table></figure><hr><h2 id="The-Best-String"><a href="#The-Best-String" class="headerlink" title="The Best String"></a>The Best String</h2><p>这题是作者菜鸡出的一道字符串问题……</p><p>如果 这道题的题意如果使用一句话总结出来的话就是：</p><p><strong>将一个01字符串拆分成多个01子串，要求其中每一个子串中0与1的数量不同。</strong></p><p>既然如此，我们就从子串的长度入手进行分析。</p><p>一个字符串的长度必定是<strong>奇数</strong>或<strong>偶数</strong><del>（废话）</del></p><p>若是奇数的话，0与1的数量本来就不可能相等，所以我们也就不需要拆分，直接输出即可。</p><p>若是偶数的话，我们可以考虑偶数可以由两个奇数组成，比如$26 = 11 + 15$</p><p>所以说我们的任务就是要找到这两个奇数。</p><p>题目里又有另一句话</p><ul><li>但Herself32是个左撇子，so……她希望拆分后左边的字符串的长度尽量的短</li></ul><p>不难看出，左边的字符串最短时长度为$1$，即我们只需要把该字符串的第一位单独拆分出来即可。</p><p>最后<strong>别忘了特判长度为偶数且输入的字符串就不需拆分</strong>的状况</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> a;</span><br><span class="line"><span class="keyword">int</span> num0 , num1; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">num0 ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">num1 ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num0 != num1)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Written By Payphone-X</span></span><br></pre></td></tr></table></figure><hr><h2 id="TarjanLusa"><a href="#TarjanLusa" class="headerlink" title="TarjanLusa"></a>TarjanLusa</h2><p>（本部分转载于<a href="https://herself32.github.io/2019/01/29/QBXTDay3Sol/">Herself32’s Blog</a>，之前转载时忘记署名，实在抱歉。望原作者原谅。）</p><p><del>毒瘤Herself32，出题粘PDF</del></p><p>咳咳，这是一道大模拟题目。</p><p>首先，我们开一个数组直接模拟球位，然后直接把题目中的左右调换，这样更便于操作。</p><p>然后观察题意，我们发现，如果激发一个球之后，它将从数组第一个位置消失（弹出），而如果生成球，就要从后面加入数组。</p><p>这不就是一个队列嘛！</p><p>但是我们这里并不需要循环队列，直接用$head$指针操作即可。</p><p>顺便提醒大家几个小细节：</p><ol><li>当球位不够时不能直接添加，而是要激发队首的几个球。</li><li>被动和技能不一样，触发被动并不会使球消失。</li><li>在生成球的时候，如果球位不够，则激发队首球1次</li></ol><p>好了，那么$80+$行代码也就写出来了。</p><p>(由于作者比较菜，所以作者并没有重写这道题，直接使用的$std$。<del>这说明我实在是菜爆了啊</del>)</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="keyword">int</span> damage, block;</span><br><span class="line"><span class="keyword">int</span> energe[N];</span><br><span class="line"><span class="keyword">char</span> q[N], str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> front = <span class="number">1</span>, tail = <span class="number">1</span>, size = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activate</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q[p] == <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">        damage = (damage + <span class="number">1l</span>l * max(<span class="number">8</span> + s, <span class="number">0</span>) * x) % mo;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (q[p] == <span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">        block = (block + <span class="number">1l</span>l * max(<span class="number">5</span> + s, <span class="number">0</span>) * x) % mo;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (q[p] == <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">        damage = (damage + <span class="number">1l</span>l * energe[p] * x) % mo;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        front--;</span><br><span class="line">    front++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q[p] == <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">        damage = (damage + <span class="number">1l</span>l * max(<span class="number">3</span> + s, <span class="number">0</span>) * x) % mo;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (q[p] == <span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">        block = (block + <span class="number">1l</span>l * max(<span class="number">2</span> + s, <span class="number">0</span>) * x) % mo;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (q[p] == <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">        energe[p] = (energe[p] + <span class="number">1l</span>l * max(s + <span class="number">6</span>, <span class="number">0</span>) * x) % mo;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    q[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= n; a++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> opt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;opt);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> l = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= l; b++)</span><br><span class="line">            &#123;</span><br><span class="line">                q[++tail] = str[b];</span><br><span class="line">                <span class="keyword">if</span> (str[b] == <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">                    energe[tail] = <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (tail - front + <span class="number">1</span> &gt; size)</span><br><span class="line">                activate(front, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            activate(front, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i, x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;x);</span><br><span class="line">            use(front + i - <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            s += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            size += x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, damage, block);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>今天的比赛题目并没有特别难，但每一个题都需要无限的细心，特别是$T2$与$T4$</p><p>$T3$表面上是一道字符串题，但主要考察的是同学们的数学思想与分析能力。需要冷静分析。</p><p>$T1$是对最最基础的算法进行考察，属于签到题。这种题在考场上绝对不能出错!!!</p><p>综上，这次考试的高分秘诀就在于：<strong>细心</strong> ，<strong>冷静</strong> ， <strong>坚持</strong>。</p><p>最后祝大家在今后的考试中能够取得更好的成绩</p><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 命题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 递推 </tag>
            
            <tag> LYOI </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOIP2018】货币系统-题解</title>
      <link href="2019/07/15/luoguP5020/"/>
      <url>2019/07/15/luoguP5020/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。</p><p>为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$</p><p>在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。</p><p>然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。</p><p>例如在货币系统 $n=3$, $a=[2,5,9]$中，金额 $1,3$ 就无法被表示出来。</p><p>两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。</p><p>现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且$m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。</p><hr><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件的第一行包含一个整数 $T$，表示数据的组数。</p><p>接下来按照如下格式分别给出 $T$ 组数据。 每组数据的第一行包含一个正整数 $n$。接下来一行包含 $n$ 个由空格隔开的正整数 $a[i]$。</p><hr><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件共有 $T$ 行，对于每组数据，输出一行一个正整数，表示所有与 $(n,a)$ 等价的货币系统 $(m,b)$ 中，最小的 $m$。</p><hr><h2 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h2><h3 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h3><blockquote><p>2<br>4<br>3 19 10 6<br>5<br>11 29 13 19 17 </p></blockquote><h4 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h4><blockquote><p>2<br>5  </p></blockquote><hr><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>在第一组数据中，货币系统 $(2,[3,10])$ 和给出的货币系统 $(n,a)$ 等价，并可以验证不存在 $m &lt; 2$ 的等价的货币系统，因此答案为 $2$。 </p><p>在第二组数据中，可以验证不存在 $m &lt; n$ 的等价的货币系统，因此答案为 $5$。</p><hr><h2 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h2><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/15/ZTBMdK.png" alt="ZTBMdK.png"></p><p>对于$100\%$的数据，$1≤T≤20$,$n,a[i]≥1$。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>第一眼看到这题只想到了某凯的疑惑……</p><p>但当我们多读了几遍题后，就能提取出以下信息</p><blockquote><ol><li>一个货币系统是由n种不同的面额货币组成的。</li><li>如果这两个货币系统是等价的，那么对于一个数，它要么都可以被两个货币系统表示出来，要么不能被任何一个表示出来。</li><li>每一次询问，都会给我们一套货币系统，我们可以删掉其中的任意面额。但要求删掉该面额后的货币系统与原系统等价。<strong>即被删除的面额必须能用其他的面额表示出来</strong></li><li>问该系统中最少需留下多少纸币。</li></ol></blockquote><p>还不懂吗？那我们来看一下样例。</p><p>在样例$3$ , $19$ , $10$ , $6$中，$3\times3 + 10 = 19$，即$19$可以被$3$张$3$元和$1$张$10$元表示出来。</p><p>同时，$6$也可以被$2$张$3$元表示出来。因此，$19$与$6$都可以被筛掉。</p><p>所以我们利用埃氏筛的思想，先建立一个数组$flag$，用其下标来记录这个钱数是否可以被表示出来。</p><p>筛到最后再跑一边$flag$，看一下货币系统之中还有几个无法凑出的钱数。<strong>这些无法凑出的钱数与原货币系统的交集就是最后的答案</strong>。</p><hr><h2 id="Code-Accepted"><a href="#Code-Accepted" class="headerlink" title="Code[Accepted]"></a>Code[Accepted]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 50001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 201</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];   <span class="comment">//原数组</span></span><br><span class="line"><span class="keyword">int</span> flag[M];</span><br><span class="line"><span class="comment">/*flag为筛选数组，0表示无法凑出，1表示可以凑出，2表示原来就有*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;   <span class="comment">//初始化变量</span></span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a , <span class="number">0</span> , <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(flag , <span class="number">0</span> , <span class="keyword">sizeof</span>(flag));</span><br><span class="line">&#125;<span class="comment">//多测不清空，爆零两行泪</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> qwq = <span class="number">1</span>; qwq &lt;= t; qwq ++)&#123;</span><br><span class="line">        start();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            flag[a[i]] = <span class="number">2</span>;     <span class="comment">//原来有的，就标2</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(a + <span class="number">1</span> , a + <span class="number">1</span> + n);        <span class="comment">//先排序，方便求解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[n]; i ++)&#123;    </span><br><span class="line">            <span class="keyword">if</span>(flag[i] &gt; <span class="number">0</span>)&#123;    <span class="comment">//如果钱数i可以被凑出来，那么i + 其他可以被凑出来的货币也可以被凑出来</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j] + i &lt;= a[n])&#123;</span><br><span class="line">                        flag[a[j] + i] = <span class="number">1</span>; <span class="comment">//能凑出来，就标1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[n]; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i] == <span class="number">2</span>)&#123;       <span class="comment">//看到最后还有哪些货币无法替代</span></span><br><span class="line">                ans ++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Written By Payphone-X</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Luogu </tag>
            
            <tag> NOIP </tag>
            
            <tag> 埃氏筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】左偏树(可并堆)</title>
      <link href="2019/07/05/left-tree/"/>
      <url>2019/07/05/left-tree/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一颗向左偏的树？一只可合并的堆？</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天，作者被同机房的$Logey$吊打了……然后$Logey$扔给了我一份目录</p><p><a href="https://imgchr.com/i/ZaMDhR"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/05/ZaMDhR.jpg" alt="ZaMDhR.jpg"></a></p><p>于是乎，作者便开始学习左偏树……</p><hr><h2 id="何为左偏树？"><a href="#何为左偏树？" class="headerlink" title="何为左偏树？"></a>何为左偏树？</h2><p>在学习左偏树之前，我们先来看看百度百科的解释</p><blockquote><p>左偏树，也可称为左倾堆，可并堆，是计算机科学中的一种树，是一种优先队列实现方式，在信息学中十分常见，在统计问题、最值问题、贪心问题等类型的题目中，左偏树都有着广泛的应用。<br>                                                                                                                                    ——《百度百科》              </p></blockquote><p>嗯……</p><p>应该没人看懂吧<del>（滑稽</del></p><p><del>毕竟您要看懂了，我就该退役了</del></p><p>还是来看看更加通俗一点的解释吧</p><p>左偏树是一种<strong>具有左偏性质的堆状二叉树</strong>，因此，左偏树是基于堆的（如果您不知道堆是什么请戳<a href="https://payphone-x.github.io/2019/01/22/Heap/#more">这里</a></p><p>可以看一下左偏树与普通二叉堆的对比：</p><div class="table-container"><table><thead><tr><th></th><th style="text-align:right">插入</th><th style="text-align:center">得到堆顶元素</th><th style="text-align:center">弹出</th><th>合并</th></tr></thead><tbody><tr><td>堆</td><td style="text-align:right">$O(log n)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">$O(log n)$</td><td>$O((n1+n2)log(n1+n2))$</td></tr><tr><td>左偏树</td><td style="text-align:right">$O(log n)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">$O(log n)$</td><td>$O(log n_1 + log n_2)$</td></tr></tbody></table></div><p>可以看出，<strong>在合并操作时，左偏树更胜一筹</strong></p><p>那么左偏树又是如何高效地实现合并两棵左偏树的呢？下面我们将对此展开探讨。</p><hr><h2 id="左偏树的概念-amp-性质"><a href="#左偏树的概念-amp-性质" class="headerlink" title="左偏树的概念 &amp; 性质"></a>左偏树的概念 &amp; 性质</h2><p>在具体探讨左偏树之前，我们先来看一下它的几条概念与性质</p><h3 id="概念篇"><a href="#概念篇" class="headerlink" title="概念篇"></a>概念篇</h3><ol><li><p>对于左偏树的任意一个节点，<strong>只要它的左子树或右子树为空，则称它是一个外节点</strong></p></li><li><p>对于左偏树的任意节点$s$，到它的子节点中，<strong>距离它最近的一个外节点经过的边数称为它的距离，记为</strong>$far[x]$。特别地，外节点的距离为0，空节点得距离为-1</p></li></ol><hr><h3 id="性质篇"><a href="#性质篇" class="headerlink" title="性质篇"></a>性质篇</h3><ol><li><p><strong>堆性质</strong>：左偏树的每一个节点均满足堆的性质，即每一个点的权值（不是距离）必须大于或小于它的每一个子节点。</p></li><li><p><strong>左偏性质</strong>：对于左偏树中的任意节点，满足其左子树的距离大于其右子树的距离，即$far[left] &gt; far[right]$。</p></li><li><p>对于左偏树的任意节点，满足它的左右子树（如果有的话）均为左偏树。</p></li><li><p>左偏树的节点距离总是满足$far[s] = far[right(s)] + 1$， 即一个节点的距离等于其右节点的距离+1</p></li><li><p>所有根节点距离为$k$的左偏树中，节点最少的是满二叉树，且节点数为$2^{k+1}−1$。</p></li></ol><p>根据上面的性质我们也可以推出左偏树的定义：<strong>左偏树是具有左偏性质的堆状二叉树</strong>。</p><hr><h2 id="左偏树的操作"><a href="#左偏树的操作" class="headerlink" title="左偏树的操作"></a>左偏树的操作</h2><p>左偏树一共有3种操作，分别是合并，插入，删除。</p><p>下面我们就来探讨基于大根堆的左偏树的这几种操作<del>（小根堆请读者自行脑补）</del></p><h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p>为什么最先讨论合并操作？？因为它是左偏树最基础的操作。插入与删除两种操作都离不开它。</p><p>左偏树的操作的原理是把一颗根节点较小的左偏树插入一颗根节点较大的左偏树中。</p><p>因此，函数的两个参数为两颗子树的根节点。</p><p>在合并，我们需要特别判断是否存在空树，如果有的话，直接合并即可。</p><p>如果没有的话，我们就要确定应该使用哪一个节点做为根节点。所以我们会将两个根节点的权值相比较，用权值大的节点作为根节点。</p><p>之后我们将根节点的右子树与之前比较的另一个节点合并，并比较合并后左右子树的大小。如果右子树偏大的话，就将左右子树交换。</p><p>最后，运用性质4计算一下根节点的距离即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x || !y)&#123;</span><br><span class="line"><span class="keyword">return</span> x + y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node[x].dis &gt; node[y].dis)&#123;</span><br><span class="line">swap(x , y);</span><br><span class="line">&#125;</span><br><span class="line">node[x].right = merge(node[x].right , y);</span><br><span class="line">node[node[x].right].pre = x;</span><br><span class="line"><span class="keyword">if</span>(node[node[x].left].far &lt; node[node[x].right].far)&#123;</span><br><span class="line">swap(node[x].left , node[x].right);</span><br><span class="line">&#125;</span><br><span class="line">node[x].far = node[node[x].right].far + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>现在我们已经可以以一只$log$的时间复杂度合并两颗左偏树了</p><p>so……</p><p>插入一个节点就等于将被插入的节点作为一颗子树合并啊</p><p>直接套上边模板吧</p><hr><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>删除操作就相当于合并被删除点的两棵子树。</p><p>当然，在此之前，我们要先把被删除的点<del>续掉</del></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = node[x].left;</span><br><span class="line"><span class="keyword">int</span> r = node[x].right;</span><br><span class="line">node[x].dis = <span class="number">-1</span>;</span><br><span class="line">node[l].pre = l;</span><br><span class="line">node[r].pre = r;</span><br><span class="line">node[x].pre = merge(l , r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="附件-左偏树模板"><a href="#附件-左偏树模板" class="headerlink" title="附件[左偏树模板]"></a>附件[左偏树模板]</h2><p><strong>代码描述</strong> ：见<a href="https://www.luogu.org/problemnew/show/P3377">洛谷P3337</a></p><p><strong>源代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) cout &lt;&lt; <span class="meta-string">&quot;----------------------&quot;</span> &lt;&lt; endl;\</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; <span class="built_in">endl</span>;\</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;\</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> pre;<span class="comment">//父节点</span></span><br><span class="line"><span class="keyword">int</span> dis;<span class="comment">//点权</span></span><br><span class="line"><span class="keyword">int</span> far;<span class="comment">//距离</span></span><br><span class="line"><span class="keyword">int</span> left;<span class="comment">//左子树</span></span><br><span class="line"><span class="keyword">int</span> right;<span class="comment">//右子树</span></span><br><span class="line">&#125;node[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;<span class="comment">//寻找父节点</span></span><br><span class="line"><span class="keyword">if</span>(node[root].pre == root)&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> node[root].pre = find(node[root].pre);</span><br><span class="line"><span class="comment">//在这里的话有人说不能路径压缩，但作者路径压缩之后是没有错的。具体境况具体对待吧</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x || !y)&#123;<span class="comment">//特判，如果有一棵空树，就直接合并</span></span><br><span class="line"><span class="keyword">return</span> x + y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node[x].dis &gt; node[y].dis)&#123;<span class="comment">//决定谁来当根节点</span></span><br><span class="line">swap(x , y);</span><br><span class="line">&#125;</span><br><span class="line">node[x].right = merge(node[x].right , y);<span class="comment">//将根节点的右子树与另一颗子树合并</span></span><br><span class="line">node[node[x].right].pre = x;<span class="comment">//使根节点右子树的父节点等于根节点</span></span><br><span class="line"><span class="keyword">if</span>(node[node[x].left].far &lt; node[node[x].right].far)&#123;<span class="comment">//判断左右子树大小，维护左偏性质</span></span><br><span class="line">swap(node[x].left , node[x].right);<span class="comment">//如果右偏，则交换左右子树</span></span><br><span class="line">&#125;</span><br><span class="line">node[x].far = node[node[x].right].far + <span class="number">1</span>;<span class="comment">//利用性质4维护距离</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = node[x].left;<span class="comment">//替代变量</span></span><br><span class="line"><span class="keyword">int</span> r = node[x].right;</span><br><span class="line">node[x].dis = <span class="number">-1</span>;<span class="comment">//续掉要删除的节点</span></span><br><span class="line">node[l].pre = l;</span><br><span class="line">node[r].pre = r;</span><br><span class="line">node[x].pre = merge(l , r);<span class="comment">//将两棵子树合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> read;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> a , b , c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; read;</span><br><span class="line">node[i].pre = i;</span><br><span class="line">node[i].dis = read;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(node[b].dis == <span class="number">-1</span> || node[c].dis == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">b = find(b);</span><br><span class="line">c = find(c);</span><br><span class="line"><span class="keyword">if</span>(b != c)&#123;</span><br><span class="line">merge(b , c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line"><span class="keyword">if</span>(node[b].dis == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; node[b = find(b)].dis &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pop(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Written By Payphone-X</span></span><br></pre></td></tr></table></figure><p>如果觉得这份模板不好记忆的话，作者还有一份更好记忆的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000001 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x)\</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;\</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;\</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> pre;</span><br><span class="line"><span class="keyword">int</span> left;</span><br><span class="line"><span class="keyword">int</span> right;</span><br><span class="line"><span class="keyword">int</span> dis;</span><br><span class="line"><span class="keyword">int</span> far;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pre(x) node[x].pre</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> left(x) node[x].left</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> right(x) node[x].right</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dis(x) node[x].dis</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> far(x) node[x].far</span></span><br><span class="line">&#125;node[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pre(root) == root)&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> pre(root) = find(pre(root));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x || !y)&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dis(x) &gt; dis(y) || dis(x) == dis(y) &amp;&amp; x &gt; y)&#123;</span><br><span class="line">swap(x , y);</span><br><span class="line">&#125;</span><br><span class="line">right(x) = merge(right(x) , y);</span><br><span class="line">pre(right(x)) = x;</span><br><span class="line"><span class="keyword">if</span>(far(left(x)) &lt; far(right(x)))&#123;</span><br><span class="line">swap(left(x) , right(x));</span><br><span class="line">&#125;</span><br><span class="line">far(x) = far(right(x)) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = left(root);</span><br><span class="line"><span class="keyword">int</span> r = right(root);</span><br><span class="line">dis(root) = <span class="number">-1</span>;</span><br><span class="line">pre(l) = l;</span><br><span class="line">pre(r) = r;</span><br><span class="line">pre(root) = merge(l , r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> read;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> a , b , c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; read;</span><br><span class="line">node[i].pre = i;</span><br><span class="line">node[i].dis = read;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(node[b].dis == <span class="number">-1</span> || node[c].dis == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">b = find(b);</span><br><span class="line">c = find(c);</span><br><span class="line"><span class="keyword">if</span>(b != c)&#123;</span><br><span class="line">merge(b , c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line"><span class="keyword">if</span>(node[b].dis == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; node[b = find(b)].dis &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pop(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Written By Payphone-X</span></span><br></pre></td></tr></table></figure><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 可并堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漫画】什么是动态规划？</title>
      <link href="2019/06/30/cartoon/"/>
      <url>2019/06/30/cartoon/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如果累了的话，不妨看一下超可爱的漫画吖</p><a id="more"></a><blockquote><p>来源：伯乐专栏作者/玻璃猫，微信公众号 - 梦见</p><p>主页君小提示：图文有点长，慢慢看，<del>做好防查颓措施</del></p></blockquote><p><a href="https://imgchr.com/i/Z16pa8"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z16pa8.jpg" alt="Z16pa8.jpg"></a><br><a href="https://imgchr.com/i/Z169IS"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z169IS.jpg" alt="Z169IS.jpg"></a><br><a href="https://imgchr.com/i/Z16mZV"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z16mZV.jpg" alt="Z16mZV.jpg"></a><br><a href="https://imgchr.com/i/Z16QG4"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z16QG4.jpg" alt="Z16QG4.jpg"></a><br><a href="https://imgchr.com/i/Z168MR"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z168MR.jpg" alt="Z168MR.jpg"></a><br><a href="https://imgchr.com/i/Z16NdK"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z16NdK.jpg" alt="Z16NdK.jpg"></a><br><a href="https://imgchr.com/i/Z16Bzd"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z16Bzd.jpg" alt="Z16Bzd.jpg"></a></p><p><strong>问题</strong></p><p>现在有$10$级台阶，要求从第一阶向上走，每一次可以走一步或走两步，求有多少种不同走法。</p><p>比如说我们可以一阶一阶的走，一共走10步。这是一种走法。</p><p>就像这样：</p><p><a href="https://imgchr.com/i/Z1gu34"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1gu34.jpg" alt="Z1gu34.jpg"></a></p><p>再或者我们可以两步两步的走，一共5步。就像这样：<br><a href="https://imgchr.com/i/Z1g28g"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1g28g.jpg" alt="Z1g28g.jpg"></a></p><p>当然啦，除此之外，还有很多种走法……</p><p><a href="https://imgchr.com/i/Z121zQ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z121zQ.jpg" alt="Z121zQ.jpg"></a></p><p><a href="https://imgchr.com/i/Z12Gss"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z12Gss.jpg" alt="Z12Gss.jpg"></a></p><p><a href="https://imgchr.com/i/Z12tZq"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z12tZq.jpg" alt="Z12tZq.jpg"></a></p><p><a href="https://imgchr.com/i/Z12Nd0"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z12Nd0.jpg" alt="Z12Nd0.jpg"></a></p><p><a href="https://imgchr.com/i/Z12diT"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z12diT.jpg" alt="Z12diT.jpg"></a></p><p><a href="https://imgchr.com/i/Z12rQJ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z12rQJ.jpg" alt="Z12rQJ.jpg"></a><br><a href="https://imgchr.com/i/Z1TJOS"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1TJOS.jpg" alt="Z1TJOS.jpg"></a><br><a href="https://imgchr.com/i/Z1T8Qf"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1T8Qf.jpg" alt="Z1T8Qf.jpg"></a><br><a href="https://imgchr.com/i/Z1T3SP"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1T3SP.jpg" alt="Z1T3SP.jpg"></a><br><a href="https://imgchr.com/i/Z1TlWt"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1TlWt.jpg" alt="Z1TlWt.jpg"></a><br><a href="https://imgchr.com/i/Z1TGy8"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1TGy8.jpg" alt="Z1TGy8.jpg"></a><br><a href="https://imgchr.com/i/Z1TyOU"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1TyOU.jpg" alt="Z1TyOU.jpg"></a><br><a href="https://imgchr.com/i/Z1Tteg"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1Tteg.jpg" alt="Z1Tteg.jpg"></a></p><p><strong>第一种情况</strong></p><p><a href="https://imgchr.com/i/Z1TNwQ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1TNwQ.jpg" alt="Z1TNwQ.jpg"></a></p><p><strong>第二种情况</strong></p><p><a href="https://imgchr.com/i/Z1blWR"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1blWR.jpg" alt="Z1blWR.jpg"></a><br><a href="https://imgchr.com/i/Z1bdFH"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1bdFH.jpg" alt="Z1bdFH.jpg"></a><br><a href="https://imgchr.com/i/Z1b3S1"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1b3S1.jpg" alt="Z1b3S1.jpg"></a><br><a href="https://imgchr.com/i/Z1bQY9"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1bQY9.jpg" alt="Z1bQY9.jpg"></a><br><a href="https://imgchr.com/i/Z1bMFJ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1bMFJ.jpg" alt="Z1bMFJ.jpg"></a><br><a href="https://imgchr.com/i/Z1b8Qx"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1b8Qx.jpg" alt="Z1b8Qx.jpg"></a><br><a href="https://imgchr.com/i/Z1bJOK"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1bJOK.jpg" alt="Z1bJOK.jpg"></a><br><a href="https://imgchr.com/i/Z1bGy6"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1bGy6.jpg" alt="Z1bGy6.jpg"></a><br><a href="https://imgchr.com/i/Z1bHmT"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1bHmT.jpg" alt="Z1bHmT.jpg"></a><br><a href="https://imgchr.com/i/Z1bo60"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1bo60.jpg" alt="Z1bo60.jpg"></a><br><a href="https://imgchr.com/i/Z1bTXV"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1bTXV.jpg" alt="Z1bTXV.jpg"></a><br><a href="https://imgchr.com/i/Z1bb0U"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1bb0U.jpg" alt="Z1bb0U.jpg"></a></p><p>$F(0) = 0;$<br>$F(1) = 1;$<br>$F(2) = 2;$<br>$F(i) = F(i - 1) + F(i - 2)$</p><p><a href="https://imgchr.com/i/Z1qMB8"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1qMB8.jpg" alt="Z1qMB8.jpg"></a><br><a href="https://imgchr.com/i/Z1qQHS"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1qQHS.jpg" alt="Z1qQHS.jpg"></a><br><a href="https://imgchr.com/i/Z1qKnf"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1qKnf.jpg" alt="Z1qKnf.jpg"></a><br><a href="https://imgchr.com/i/Z1qnjP"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1qnjP.jpg" alt="Z1qnjP.jpg"></a><br><a href="https://imgchr.com/i/Z1qmct"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1qmct.jpg" alt="Z1qmct.jpg"></a><br><a href="https://imgchr.com/i/Z1q1Ag"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1q1Ag.jpg" alt="Z1q1Ag.jpg"></a><br><a href="https://imgchr.com/i/Z1q3NQ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1q3NQ.jpg" alt="Z1q3NQ.jpg"></a><br><a href="https://imgchr.com/i/Z1q8hj"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1q8hj.jpg" alt="Z1q8hj.jpg"></a><br><a href="https://imgchr.com/i/Z1qHgI"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1qHgI.jpg" alt="Z1qHgI.jpg"></a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> work(i - <span class="number">1</span>) + work(i - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/Z1LMx1"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1LMx1.jpg" alt="Z1LMx1.jpg"></a><br><a href="https://imgchr.com/i/Z1LK2R"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1LK2R.jpg" alt="Z1LK2R.jpg"></a><br><a href="https://imgchr.com/i/Z1L1r6"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1L1r6.jpg" alt="Z1L1r6.jpg"></a><br><a href="https://imgchr.com/i/Z1LuG9"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1LuG9.jpg" alt="Z1LuG9.jpg"></a><br><a href="https://imgchr.com/i/Z1LnPJ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1LnPJ.jpg" alt="Z1LnPJ.jpg"></a><br><a href="https://imgchr.com/i/Z1LlKx"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1LlKx.jpg" alt="Z1LlKx.jpg"></a><br><a href="https://imgchr.com/i/Z1L3qK"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1L3qK.jpg" alt="Z1L3qK.jpg"></a><br><a href="https://imgchr.com/i/Z1LydS"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1LydS.jpg" alt="Z1LydS.jpg"></a><br><a href="https://imgchr.com/i/Z1LsZ8"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1LsZ8.jpg" alt="Z1LsZ8.jpg"></a><br><a href="https://imgchr.com/i/Z1L6Ig"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1L6Ig.jpg" alt="Z1L6Ig.jpg"></a><br><a href="https://imgchr.com/i/Z1LBsP"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1LBsP.jpg" alt="Z1LBsP.jpg"></a><br><a href="https://imgchr.com/i/Z1LDqf"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1LDqf.jpg" alt="Z1LDqf.jpg"></a><br><a href="https://imgchr.com/i/Z1L2Gj"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1L2Gj.jpg" alt="Z1L2Gj.jpg"></a><br><a href="https://imgchr.com/i/Z1LgiQ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1LgiQ.jpg" alt="Z1LgiQ.jpg"></a><br>(其实备忘录算法在OI上一般叫记忆化搜索)</p><p><a href="https://imgchr.com/i/Z1jDqx"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1jDqx.jpg" alt="Z1jDqx.jpg"></a><br><a href="https://imgchr.com/i/Z1Omef"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1Omef.jpg" alt="Z1Omef.jpg"></a><br><a href="https://imgchr.com/i/Z1OlWj"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1OlWj.jpg" alt="Z1OlWj.jpg"></a><br><a href="https://imgchr.com/i/Z1Onw8"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1Onw8.jpg" alt="Z1Onw8.jpg"></a><br><a href="https://imgchr.com/i/Z1OZOP"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1OZOP.jpg" alt="Z1OZOP.jpg"></a><br><a href="https://imgchr.com/i/Z1OMFg"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1OMFg.jpg" alt="Z1OMFg.jpg"></a><br><a href="https://imgchr.com/i/Z1O3Ss"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1O3Ss.jpg" alt="Z1O3Ss.jpg"></a><br><a href="https://imgchr.com/i/Z1OQYQ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1OQYQ.jpg" alt="Z1OQYQ.jpg"></a></p><p><a href="https://imgchr.com/i/Z1jLWQ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1jLWQ.jpg" alt="Z1jLWQ.jpg"></a><br><a href="https://imgchr.com/i/Z1jqJg"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1jqJg.jpg" alt="Z1jqJg.jpg"></a><br><a href="https://imgchr.com/i/Z1j7o8"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1j7o8.jpg" alt="Z1j7o8.jpg"></a><br><a href="https://imgchr.com/i/Z1jbFS"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1jbFS.jpg" alt="Z1jbFS.jpg"></a><br><a href="https://imgchr.com/i/Z1jOzj"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1jOzj.jpg" alt="Z1jOzj.jpg"></a><br><a href="https://imgchr.com/i/Z1jjQs"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1jjQs.jpg" alt="Z1jjQs.jpg"></a><br><a href="https://imgchr.com/i/Z1jvyn"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1jvyn.jpg" alt="Z1jvyn.jpg"></a><br><a href="https://imgchr.com/i/Z1vnw6"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1vnw6.jpg" alt="Z1vnw6.jpg"></a><br><a href="https://imgchr.com/i/Z1vmex"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1vmex.jpg" alt="Z1vmex.jpg"></a><br><a href="https://imgchr.com/i/Z1vuTK"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1vuTK.jpg" alt="Z1vuTK.jpg"></a><br><a href="https://imgchr.com/i/Z1vZO1"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1vZO1.jpg" alt="Z1vZO1.jpg"></a><br><a href="https://imgchr.com/i/Z1vMFO"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1vMFO.jpg" alt="Z1vMFO.jpg"></a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10001</span>]</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">temp = a + b;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/Z1xkAf"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1xkAf.jpg" alt="Z1xkAf.jpg"></a><br><a href="https://imgchr.com/i/Z1xCnI"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1xCnI.jpg" alt="Z1xCnI.jpg"></a><br><a href="https://imgchr.com/i/Z1xScd"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1xScd.jpg" alt="Z1xScd.jpg"></a><br><a href="https://imgchr.com/i/Z1vz1H"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1vz1H.jpg" alt="Z1vz1H.jpg"></a><br><a href="https://imgchr.com/i/Z1xpjA"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1xpjA.jpg" alt="Z1xpjA.jpg"></a><br><a href="https://imgchr.com/i/Z1xiHP"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1xiHP.jpg" alt="Z1xiHP.jpg"></a><br><a href="https://imgchr.com/i/Z1xPBt"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Z1xPBt.jpg" alt="Z1xPBt.jpg"></a></p><p><strong>问题</strong></p><p>有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。</p><p>参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。</p><p>要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？</p><p><a href="https://imgchr.com/i/ZGHN1s"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHN1s.jpg" alt="ZGHN1s.jpg"></a><br><a href="https://imgchr.com/i/ZGHaXq"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHaXq.jpg" alt="ZGHaXq.jpg"></a><br><a href="https://imgchr.com/i/ZGHtpj"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHtpj.jpg" alt="ZGHtpj.jpg"></a><br><a href="https://imgchr.com/i/ZGHJhQ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHJhQ.jpg" alt="ZGHJhQ.jpg"></a><br><a href="https://imgchr.com/i/ZGHUcn"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHUcn.jpg" alt="ZGHUcn.jpg"></a></p><p>每一座金矿都有挖与不挖两种选择，如果有N座金矿，排列组合起来就有2^N种选择。</p><p>对所有可能性做遍历，排除那些使用工人数超过10的选择，在剩下的选择里找出获得金币数最多的选择。</p><p>代码比较简单就不展示了，时间复杂度也很明显，就是O(2^N)。</p><p><a href="https://imgchr.com/i/ZGH2cR"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGH2cR.jpg" alt="ZGH2cR.jpg"></a><br><a href="https://imgchr.com/i/ZGHIAO"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHIAO.jpg" alt="ZGHIAO.jpg"></a><br><a href="https://imgchr.com/i/ZGHc9J"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHc9J.jpg" alt="ZGHc9J.jpg"></a><br><a href="https://imgchr.com/i/ZGHhB6"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHhB6.jpg" alt="ZGHhB6.jpg"></a><br><a href="https://imgchr.com/i/ZGHg39"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHg39.jpg" alt="ZGHg39.jpg"></a><br><a href="https://imgchr.com/i/ZGHRj1"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHRj1.jpg" alt="ZGHRj1.jpg"></a><br><a href="https://imgchr.com/i/ZGHfnx"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHfnx.jpg" alt="ZGHfnx.jpg"></a><br><a href="https://imgchr.com/i/ZGH4HK"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGH4HK.jpg" alt="ZGH4HK.jpg"></a></p><p><a href="https://imgchr.com/i/ZGHT4e"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHT4e.jpg" alt="ZGHT4e.jpg"></a><br><a href="https://imgchr.com/i/ZGHXut"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHXut.jpg" alt="ZGHXut.jpg"></a><br><a href="https://imgchr.com/i/ZGHqgA"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHqgA.jpg" alt="ZGHqgA.jpg"></a><br><a href="https://imgchr.com/i/ZGHH9H"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHH9H.jpg" alt="ZGHH9H.jpg"></a><br><a href="https://imgchr.com/i/ZGHb3d"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHb3d.jpg" alt="ZGHb3d.jpg"></a><br><a href="https://imgchr.com/i/ZGHLjI"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHLjI.jpg" alt="ZGHLjI.jpg"></a><br><a href="https://imgchr.com/i/ZGHjDP"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHjDP.jpg" alt="ZGHjDP.jpg"></a><br><a href="https://imgchr.com/i/ZGHvHf"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGHvHf.jpg" alt="ZGHvHf.jpg"></a></p><p><a href="https://imgchr.com/i/ZGbAuq"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbAuq.jpg" alt="ZGbAuq.jpg"></a><br><a href="https://imgchr.com/i/ZGbFvn"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbFvn.jpg" alt="ZGbFvn.jpg"></a><br><a href="https://imgchr.com/i/ZGbP3j"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbP3j.jpg" alt="ZGbP3j.jpg"></a><br><a href="https://imgchr.com/i/ZGbCCQ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbCCQ.jpg" alt="ZGbCCQ.jpg"></a><br><a href="https://imgchr.com/i/ZGbigs"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbigs.jpg" alt="ZGbigs.jpg"></a></p><p><strong>F(n,w) = 0 (n&lt;=1, w &lt; p[0]);</strong></p><p><strong>F(n,w) = g[0] (n==1, w &gt;= p[0]);</strong></p><p><strong>F(n,w) = F(n-1,w) (n&gt;1, w &lt; p[n-1])</strong></p><p><strong>F(n,w) = max(F(n-1,w), F(n-1,w-p[n-1])+g[n-1]) (n&gt;1, w &gt;= p[n-1])</strong></p><p><a href="https://imgchr.com/i/ZGb8Dx"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGb8Dx.jpg" alt="ZGb8Dx.jpg"></a><br><a href="https://imgchr.com/i/ZGbGb6"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbGb6.jpg" alt="ZGbGb6.jpg"></a><br><a href="https://imgchr.com/i/ZGb3K1"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGb3K1.jpg" alt="ZGb3K1.jpg"></a></p><p><a href="https://imgchr.com/i/ZGbtUO"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbtUO.jpg" alt="ZGbtUO.jpg"></a><br><a href="https://imgchr.com/i/ZGbN5D"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbN5D.jpg" alt="ZGbN5D.jpg"></a><br><a href="https://imgchr.com/i/ZGbaPe"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbaPe.jpg" alt="ZGbaPe.jpg"></a><br><a href="https://imgchr.com/i/ZGbYVK"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbYVK.jpg" alt="ZGbYVK.jpg"></a><br><a href="https://imgchr.com/i/ZGbd8H"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbd8H.jpg" alt="ZGbd8H.jpg"></a><br><a href="https://imgchr.com/i/ZGbDKI"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbDKI.jpg" alt="ZGbDKI.jpg"></a><br><a href="https://imgchr.com/i/ZGbw2d"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbw2d.jpg" alt="ZGbw2d.jpg"></a><br><a href="https://imgchr.com/i/ZGb0xA"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGb0xA.jpg" alt="ZGb0xA.jpg"></a></p><p><a href="https://imgchr.com/i/ZGbIrq"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbIrq.jpg" alt="ZGbIrq.jpg"></a><br><a href="https://imgchr.com/i/ZGbRPg"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbRPg.jpg" alt="ZGbRPg.jpg"></a><br><a href="https://imgchr.com/i/ZGbgIS"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbgIS.jpg" alt="ZGbgIS.jpg"></a><br><a href="https://imgchr.com/i/ZGb5Mn"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGb5Mn.jpg" alt="ZGb5Mn.jpg"></a><br><a href="https://imgchr.com/i/ZGbca8"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbca8.jpg" alt="ZGbca8.jpg"></a><br><a href="https://imgchr.com/i/ZGbf2j"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbf2j.jpg" alt="ZGbf2j.jpg"></a><br><a href="https://imgchr.com/i/ZGbhxs"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbhxs.jpg" alt="ZGbhxs.jpg"></a><br><a href="https://imgchr.com/i/ZGboq0"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGboq0.jpg" alt="ZGboq0.jpg"></a></p><p><a href="https://imgchr.com/i/ZGbbIU"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbbIU.jpg" alt="ZGbbIU.jpg"></a><br><a href="https://imgchr.com/i/ZGbHaT"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbHaT.jpg" alt="ZGbHaT.jpg"></a><br><a href="https://imgchr.com/i/ZGbXRJ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbXRJ.jpg" alt="ZGbXRJ.jpg"></a><br><a href="https://imgchr.com/i/ZGbLiF"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbLiF.jpg" alt="ZGbLiF.jpg"></a><br><a href="https://imgchr.com/i/ZGb7ZV"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGb7ZV.jpg" alt="ZGb7ZV.jpg"></a><br><a href="https://imgchr.com/i/ZGbxMR"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbxMR.jpg" alt="ZGbxMR.jpg"></a><br><a href="https://imgchr.com/i/ZGbOG4"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbOG4.jpg" alt="ZGbOG4.jpg"></a><br><a href="https://imgchr.com/i/ZGbjz9"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGbjz9.jpg" alt="ZGbjz9.jpg"></a></p><p><a href="https://imgchr.com/i/ZGqPIO"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqPIO.jpg" alt="ZGqPIO.jpg"></a><br><a href="https://imgchr.com/i/ZGq9Z6"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGq9Z6.jpg" alt="ZGq9Z6.jpg"></a><br><a href="https://imgchr.com/i/ZGqCdK"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqCdK.jpg" alt="ZGqCdK.jpg"></a><br><a href="https://imgchr.com/i/ZGqkJe"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqkJe.jpg" alt="ZGqkJe.jpg"></a><br><a href="https://imgchr.com/i/ZGqFiD"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqFiD.jpg" alt="ZGqFiD.jpg"></a><br><a href="https://imgchr.com/i/ZGqZQA"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqZQA.jpg" alt="ZGqZQA.jpg"></a><br><a href="https://imgchr.com/i/ZGqARH"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqARH.jpg" alt="ZGqARH.jpg"></a><br><a href="https://imgchr.com/i/ZGqEzd"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqEzd.jpg" alt="ZGqEzd.jpg"></a></p><p><a href="https://imgchr.com/i/ZGqMo8"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqMo8.jpg" alt="ZGqMo8.jpg"></a><br><a href="https://imgchr.com/i/ZGqueP"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqueP.jpg" alt="ZGqueP.jpg"></a><br><a href="https://imgchr.com/i/ZGq8zj"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGq8zj.jpg" alt="ZGq8zj.jpg"></a><br><a href="https://imgchr.com/i/ZGqmLt"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqmLt.jpg" alt="ZGqmLt.jpg"></a><br><a href="https://imgchr.com/i/ZGqKdf"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqKdf.jpg" alt="ZGqKdf.jpg"></a><br><a href="https://imgchr.com/i/ZGqlFS"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqlFS.jpg" alt="ZGqlFS.jpg"></a><br><a href="https://imgchr.com/i/ZGq1Jg"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGq1Jg.jpg" alt="ZGq1Jg.jpg"></a><br><a href="https://imgchr.com/i/ZGq3WQ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGq3WQ.jpg" alt="ZGq3WQ.jpg"></a></p><p><a href="https://imgchr.com/i/ZGqtLq"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqtLq.jpg" alt="ZGqtLq.jpg"></a><br><a href="https://imgchr.com/i/ZGqYyn"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/07/02/ZGqYyn.jpg" alt="ZGqYyn.jpg"></a></p>]]></content>
      
      
      <categories>
          
          <category> 灌水 &amp; 摸鱼区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 灌水区 </tag>
            
            <tag> 超可爱哒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【News】关于2019年中考物理的一点个人看法</title>
      <link href="2019/06/30/zhongkaoBUG/"/>
      <url>2019/06/30/zhongkaoBUG/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>曾有研究生考试发答案，今有中考物理算错分</del></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="note warning">**本文仅为作者的个人看法，无任何政治立场。****因此，请读者不要去试图摸索任何“深层意思”或发表人身攻击等不适当言论****同时，阅读本文产生的一切后果，与作者无关。**</div><h2 id="事情经过-amp-本人看法"><a href="#事情经过-amp-本人看法" class="headerlink" title="事情经过 &amp; 本人看法"></a>事情经过 &amp; 本人看法</h2><p>随着昨天下午4:00(2019/6/29)中考成绩公布，2019年中考正式落下帷幕。各位2016级的考生们也都已经放下了担子，开始准备填报志愿等相关事情</p><p>但是，不少考生发现，自己的物理成绩实在是出乎意料。许多原本预估可以考到65，67分的考生却仅仅拿到了58，,59分，甚至有的班级出现了全班没有一个$A$的惨烈状况。</p><p><a href="https://imgchr.com/i/ZlHtkd"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/ZlHtkd.jpg" alt="ZlHtkd.jpg"></a></p><p>作者当时也在查询分数，也亲眼见证了大部分考生(包括作者自己)的物理成绩确实全部偏低。在之后的2小时内，作者多次给河东、罗庄区的同学打了电话，却发现他们的物理成绩好像一切正常。</p><p>那么，<strong>究竟是发生了什么才导致了这种状况呐？？？</strong></p><p>到了晚上7:30左右，校长忽然开始开始统计成绩，说要上报教育局。</p><p><a href="https://imgchr.com/i/ZlH8mD"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/ZlH8mD.jpg" alt="ZlH8mD.jpg"></a></p><p>随后，各路家长群中也出现了各种不一样的看法。晚上9:40，作者回家路过八中，发现八中门口早已经被家长与考生们围的水泄不通，要求给一个合理的解释。</p><p>到了晚上10点左右，教育局内部找到了错误原因：在第一天改卷时，有一道13分的大题没有记入总分。折合后是9分。因此导致了得分区间为[-9  , 61]的乌龙</p><p><a href="https://imgchr.com/i/Zlbi4A"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/Zlbi4A.jpg" alt="Zlbi4A.jpg"></a></p><p>随后，教育局内部人员便开始连夜修复错误。截止至今天早上(2019/6/30)7时，中考成绩查询已经恢复正常。</p><p><a href="https://imgchr.com/i/ZlboxP"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/30/ZlboxP.jpg" alt="ZlboxP.jpg"></a></p><p>但是，<strong>恢复正常后这件事就这样结束了吗？？？</strong></p><p><strong>这背后的原因又是什么？？？</strong></p><p><strong>审核组都是一群饭桶？？？</strong></p><p><strong>今后的大考中，还会出现这样的错误吗？？？</strong></p><p>这是值得深思的问题。</p><p><strong>毕竟，中高考中的一点小错误，都会有成千上万莘莘学子用一生为之买单。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 灌水 &amp; 摸鱼区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 灌水区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOIP2013/2018】铺设道路-题解</title>
      <link href="2019/06/26/luoguP5019/"/>
      <url>2019/06/26/luoguP5019/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>CCF : <strong>我 抄 我 自 己 ， 你 来 打 我 啊</strong></p></blockquote><a id="more"></a><p>详见<a href="https://payphone-x.github.io/2019/06/26/luoguP1969/#more">【NOIP2013/2018】积木大赛-题解</a></p><p><del>反正是原题，写不写无所谓的啦</del></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 玄学 </tag>
            
            <tag> Luogu </tag>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOIP2013/2018】积木大赛-题解</title>
      <link href="2019/06/26/luoguP1969/"/>
      <url>2019/06/26/luoguP1969/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>原 题 警 告</strong></p><a id="more"></a><h3 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h3><p>春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为$n$的大厦，</p><p>大厦可以看成由$n$块宽度为$1$的积木组成，第i块积木的最终高度需要是$h_i$</p><p>在搭建开始之前，没有任何积木（可以看成$n$块高度为$0$的积木）。</p><p>接下来每次操作，小朋友们可以选择一段连续区间$[l, r]$，然后将第第 $L$块到第 $R$ 块之间（含第 $L$ 块和第 $R$ 块）所有积木的高度分别增加$1$。</p><p>小$M$是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。</p><p>但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。</p><hr><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>包含两行，第一行包含一个整数$n$，表示大厦的宽度。</p><p>第二行包含$n$个整数，第$i$个整数为$h_i$</p><hr><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>一个整数，表示建造所需的最少操作数。</p><hr><h3 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h3><h4 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h4><blockquote><p>5<br>2 3 4 1 2</p></blockquote><h4 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h4><blockquote><p>5</p></blockquote><hr><h3 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h3><p>对于 $30\% $ 的数据，有$1 ≤ n ≤ 10 $；</p><p>对于 $70\% $的数据，有$1 ≤ n ≤ 1000 $；</p><p>对于 $100\% $的数据，有$1 ≤ n ≤ 100000,0 ≤ h_i≤ 10000 $</p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><del><strong>原 题 警 告</strong></del></p><p>其实是一道很水的模拟题……</p><p>连数组都不用开……<del>（反正我是没开</del></p><p>不难看出，小朋友们搭积木时是从下向上一排排的搭建。</p><p>因此小朋友们搭建的次数完全取决于最高的那一块。</p><p>也就是说，只要第$n$块积木没有第$n - 1$块积木高，就可以在搭第$n - 1$块时顺带处理掉。</p><p>反之，则要多搭几次。多搭的次数就等于这两块积木的高度差</p><p>18年的铺设道路也是如此，只要前一个坑够深，就可以顺带处理掉后边的坑。</p><p><del>所以才说是原题嘛</del></p><p>是不是很简单啊（逃</p><hr><h3 id="附件（AC标程）"><a href="#附件（AC标程）" class="headerlink" title="附件（AC标程）"></a>附件（AC标程）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line"><span class="keyword">int</span> now;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ans;</span><br><span class="line">now = ans;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; next;</span><br><span class="line"><span class="keyword">if</span>(next &gt; now)&#123;</span><br><span class="line">ans = ans + (next  - now);</span><br><span class="line">&#125;</span><br><span class="line">now = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//Writtrn By Payphone-X</span></span><br></pre></td></tr></table></figure><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 玄学 </tag>
            
            <tag> Luogu </tag>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【玄学篇】模拟退火 &amp; 【JSOI2004】平衡点 / 吊打XXX-题解</title>
      <link href="2019/06/19/Simulate-Anneal/"/>
      <url>2019/06/19/Simulate-Anneal/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>模拟退火，参数难调，<del>急需欧皇</del><br>                              ——《AK杀》</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天（2019/6/19），$Payphone-X$想要学习最小生成树，结果翻到了模拟退火……</p><p>于是乎</p><p>就有了今天这篇博客</p><hr><h2 id="何为模拟退火"><a href="#何为模拟退火" class="headerlink" title="何为模拟退火"></a>何为模拟退火</h2><p>先来看看百度百科对于模拟退火的解释</p><blockquote><p>模拟退火的出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性。模拟退火算法是一种通用的优化算法，其物理退火过程由加温过程、等温过程、冷却过程这三部分组成。</p><p>——百度百科</p></blockquote><p>嗯……</p><p>看起来有点玄学的气息……</p><p>还是来看看通俗的解释吧。</p><p>简单的说，模拟退火是一种随机化搜索算法。<del>（所有除了机惨的算法里需要用到rand与random_shuffle的算法</del></p><p>它<strong>可以求得一段多峰函数的极值</strong><del>（也可能求不出来</del></p><p>也就是说，当我们面对一个方案数极大（甚至是无穷大）的题目时，可以使用模拟退火</p><p><del>是一个<strong>比较看脸</strong>的算法</del></p><hr><h2 id="爬山算法"><a href="#爬山算法" class="headerlink" title="爬山算法"></a>爬山算法</h2><p>在讲模拟退火之前，我们先来看看它的基础算法——爬山算法</p><p>爬山算法是一种基于贪心的暴力搜索，可以求得一个单峰函数的极值。</p><p>它的原理是每一次寻找一个比当前更优的解，一旦找不出，就结束。</p><p>就像这样：</p><p><a href="https://imgchr.com/i/VORKEt"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/19/VORKEt.jpg" alt="VORKEt.jpg"></a></p><p>当爬到顶峰，即无法继续向上爬时，即停止搜索。就像这样：</p><p><a href="https://imgchr.com/i/VORRV1"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/19/VORRV1.jpg" alt="VORRV1.jpg"></a></p><p>嗯……</p><p>现在为止，一切好像都很正常</p><p>但……如果整张图是这样的</p><p><a href="https://imgchr.com/i/VOfw1U"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/19/VOfw1U.jpg" alt="VOfw1U.jpg"></a></p><p>就自闭了……</p><p>而<strong>模拟退火会在寻找到一个非局部最优解时，赋予一个接受他的概率。从而继续向下寻找，直到找到全局最优解</strong>。<br>（ps.即在爬山时，模拟退火会有一定概率下降当前高度去寻找是否可以有别的路到达更高的高度。）</p><hr><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>要想了解模拟退火，就必须了解<a href="https://baike.baidu.com/item/%E9%80%80%E7%81%AB/1039313?fr=aladdin">金属的退火原理</a></p><p>简单来说，就是将金属加热到一定温度，保持足够时间，然后以适宜速度冷却。</p><p>而OI上，就是每次随机出一个新解。如果这个解更优，就接受它，否则以一个与温度和与最优解的差相关的概率接受它。</p><p>设这个新的解与最优解的差为 $\Delta E$ ，温度为 $T$ ， $k$ 为一个随机数，那么这个概率为 $\displaystyle e^{\frac{\Delta E}{kT}}$</p><hr><p>​    </p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="降温"><a href="#降温" class="headerlink" title="降温"></a>降温</h3><p>模拟退火时有3个参数，分别为初始温度$T_0$，降温系数$Δ$，终止温度$T_k$。</p><p>其中，$T_0$的值会很大，$Δ$是一个略小于$1$的正数，$T_k$是一个略大于$0$的数</p><p>我们先把初始温度$T_0$的值赋给$T$，每一次降温时让$T = T * Δ$，直到$T ≤ T_k$为止</p><p>伪代码如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> start = <span class="number">120</span>, s = <span class="number">0.96</span> , finish = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">double</span> tem = start;</span><br><span class="line"><span class="keyword">while</span>(tem &gt; finish)&#123;</span><br><span class="line">    tem = tem * s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果转换成图片，大概是这样的</p><p><a href="https://i.loli.net/2019/06/19/5d09f8b0e056657108.gif"><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/06/19/5d09f8b0e056657108.gif" alt="Hill_Climbing_with_Simulated_Annealing.gif"></a></p><p>可以看出，随着温度的不断降低，解也不断稳定下来，并集中在最优解附近。</p><hr><h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><p>不多说，直接看表。</p><blockquote><ol><li><p>首先，我们在程序开始时需要srand(一个常数)来随机化，这个常数可以是任意的常数，比如$23333$ , $1212121$ <del>或古老东方的某个神秘的八位信仰质数</del></p></li><li><p>一遍退火一般不能直接得到最优解，所以要在不TLE的情况下多跑几遍。</p></li><li><p>模拟退火的时间复杂度比较玄学，一般降温系数 $Δ$ 与 $1$ 的差减少一个数量级, 耗时大约多 $10$ 倍；但$T_0$ 和 $T_k$ 如果变化一个数量级, 耗时却不会变化很大。</p></li><li><p>最近有的出题人卡常数随机化，针对此种状况，我们可以    srand((unsigned)time(NULL));</p></li></ol></blockquote><hr><h3 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h3><p>众所周知，调参是一门<del>极其玄学</del>的艺术</p><p>不信可以看我的提交记录：</p><p><a href="https://imgchr.com/i/Vvi79I"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/20/Vvi79I.jpg" alt="Vvi79I.jpg"></a></p><p>在调参过程中，不同的$Δ$，$T_0$，$T_k$，$srand$常数甚至退火的次数都会影响最后的答案。</p><p>下面，我们就来探讨一下如何调参</p><blockquote><p>Q：答案不是最优的怎么办？</p><p>A：<strong>以下几种方法：调大 $Δ$ ，调大 $T_0$ ，调小 $T_k$ ，以及多跑几遍。</strong>其中，如果您的程序跑的比较快，可以尝试多跑几遍或调大$Δ$，调大 $T_0$ 与调小 $T_k$对运行时间影响较小，但可能效果不会很明显。</p><p>Q：还是跑不出最优解怎么办？</p><p>A：可以尝试更换随机数种子，或者 srand(rand())srand(rand());总有可能跑过。</p><p>Q：那我提交了两页都没有$AC$，咋办啊？</p><p>A：<del>那您还是写正解吧</del></p></blockquote><hr><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>现在，我们以这道题为例来讲解模拟退火的应用。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如图：有$n$个重物，每个重物系在一条足够长的绳子上。</p><p>每条绳子自上而下穿过桌面上的洞，然后系在一起，图中$X$处就是公共的绳结。</p><p>假设绳子是完全弹性的（不会造成能量损失），桌子足够高（因而重物不会垂到地上），且忽略所有的摩擦。</p><p>问绳结$X$最终平衡于何处。</p><p><a href="https://i.loli.net/2019/06/19/5d0a0022c7f3325675.jpg"><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/06/19/5d0a0022c7f3325675.jpg" alt="148.jpg"></a></p><p>（注意：桌面上的洞都比绳结$X$小得多，所以即使某个重物特别重，绳结$X$也不可能穿过桌面上的洞掉下来，最多是卡在某个洞口处。）</p><hr><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行为一个正整数$n$，表示重物和洞的数目。</p><p>接下来的$n$行，每行是3个整数：$X_i.Y_i.W_i$，分别表示第$i$个洞的坐标以及第 $i$个重物的重量。</p><hr><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出两个浮点数（保留小数点后三位）分别表示处于最终平衡状态时绳结$X$的横坐标和纵坐标。两个数以一个空格隔开。</p><hr><h3 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h3><h4 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h4><blockquote><p>3<br>0 0 1<br>0 2 1<br>1 1 1</p></blockquote><h4 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h4><blockquote><p>0.577 1.000</p></blockquote><hr><h3 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h3><p>对于$100\%$数据 ，$1≤n≤1000$，$-10000≤x,y≤10000, 0&lt; w ≤ 1000$ </p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>恐怕这是OI上为数不多的物理题了……<del>（看不懂题的话先补物理去吧）</del></p><p>根据<del>初中</del>物理的知识，当系统处于平衡状态时，系统的总能量最小。<del>（有人说初中不学这玩意，但老宋确实讲了，而且创客转OI的同学们应该觉得这是基础</del></p><p>又因为物体静止,不用考虑动能与弹性势能，则此时系统的总能量是等于各个物体的重力势能之和。</p><p>由公式$E_重 = mgh$可得，物体的重力势能取决于物体的质量与高度，</p><p>由于每个物体的质量是固定的（题目给出），我们能调整的，只有物体的高度。</p><p>为了让系统的重力势能尽可能小，我们需要尽量每一个物体的高度更小，即使每一个$h$更小，也就是让桌子下面的绳子长度更长。</p><p>也就是说，我们要让在桌子上边的绳子长度尽量的短。</p><p>当桌子上边的绳子长度最短时，就达到了平衡状态。</p><p>所以我们用模拟退火跑出桌上绳子的最短长度，然后找出此时绳结的坐标即可。</p><hr><h3 id="附件-AC标程"><a href="#附件-AC标程" class="headerlink" title="附件[AC标程]"></a>附件[AC标程]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include&lt;iomanip&gt;*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x)&#123;\</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----------------------------\n&quot;</span>);\</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;DEBUG: There is no bug /n&quot;</span>,x);\</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dai 0.996<span class="comment">//降温系数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C 4<span class="comment">//模拟退火的执行次数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Things</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;<span class="comment">//物体横坐标</span></span><br><span class="line"><span class="keyword">int</span> y;<span class="comment">//物体纵坐标</span></span><br><span class="line"><span class="keyword">int</span> w;<span class="comment">//物体重量</span></span><br><span class="line">&#125;t[N];     </span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ansx , ansy , answ;<span class="comment">//答案</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">energy</span><span class="params">(<span class="keyword">double</span> x , <span class="keyword">double</span> y)</span></span>&#123;<span class="comment">//公式模拟</span></span><br><span class="line"><span class="keyword">double</span> r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> dx , dy;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">dx = x - t[i].x;</span><br><span class="line">dy = y - t[i].y;</span><br><span class="line">r = r + <span class="built_in">sqrt</span>(dx * dx + dy * dy) * t[i].w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span></span>&#123;<span class="comment">//模拟退火</span></span><br><span class="line"><span class="keyword">double</span> tem = <span class="number">3000</span>;<span class="comment">//初始温度调高</span></span><br><span class="line"><span class="keyword">while</span>(tem &gt; <span class="number">1e-15</span>)&#123;</span><br><span class="line"><span class="keyword">double</span> ex = ansx + (rand() * <span class="number">2</span> - RAND_MAX) * tem;</span><br><span class="line"><span class="keyword">double</span> ey = ansy + (rand() * <span class="number">2</span> - RAND_MAX) * tem;</span><br><span class="line"><span class="keyword">double</span> ew = energy(ex , ey);</span><br><span class="line"><span class="keyword">double</span> ac = ew - answ;</span><br><span class="line"><span class="keyword">if</span>(ac &lt; <span class="number">0</span>)&#123;<span class="comment">//如果答案比当前答案更优，则接受</span></span><br><span class="line">ansx = ex;</span><br><span class="line">ansy = ey;</span><br><span class="line">answ = ew;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span> (-(ew - answ) / tem) * RAND_MAX &gt; rand())&#123;</span><br><span class="line">ansx = ex;</span><br><span class="line">ansy = ey;<span class="comment">//否则以一定概率接受</span></span><br><span class="line">&#125;</span><br><span class="line">tem = dai * tem;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;<span class="comment">//多跑几遍才能跑出最优解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; i ++)&#123;</span><br><span class="line">        SA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t[i].x &gt;&gt; t[i].y &gt;&gt; t[i].w;</span><br><span class="line">ansx = ansx + t[i].x;</span><br><span class="line">ansy = ansy + t[i].y;</span><br><span class="line">&#125;</span><br><span class="line">ansx = ansx / n;<span class="comment">//取平均值作为初始答案</span></span><br><span class="line">ansy = ansy / n;</span><br><span class="line">answ = energy(ansx , ansy);</span><br><span class="line">work();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; ansx &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; ansy &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> Algorithm </tag>
            
            <tag> 暴力 </tag>
            
            <tag> 各省省选 </tag>
            
            <tag> 玄学 </tag>
            
            <tag> 模拟退火 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷精选】灾后重建-题解</title>
      <link href="2019/06/18/luoguP1119/"/>
      <url>2019/06/18/luoguP1119/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 西蒙·弗洛伊德曾经说过一句很有哲理的话，叫做：</p><script type="math/tex; mode=display">f[i][j] = min(f[i][j] , f[i][k] + f[k][j]);</script><a id="more"></a><h3 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h3><p>B地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。</p><p>但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。</p><p>换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。</p><p>现在，给出$B$地区的村庄数$N$，村庄编号从$0$到$N-1$，和$M$条公路的长度。</p><p>公路是双向的。并给出第$i$个村庄重建完成的时间$t[i]$ </p><p>若$t[i]$为$0$则说明地震未对此地区造成损坏，一开始就可以通车。</p><p>之后有$Q$个询问$(x, y, t)$</p><p>对于每个询问你要回答在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少。</p><p>如果无法找到从$x$村庄到$y$村庄的路径，或者村庄$x$或村庄$y$在第$t$天仍未重建完成 ，则输出$-1$。</p><hr><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行包含两个正整数$N$ , $M$，表示了村庄的数目与公路的数量。</p><p>第二行包含$N$个非负整数$t$表示了每个村庄重建完成的时间.</p><p>接下来$M$行，每行$3$个非负整数$i, j, w$,表示了有一条连接村庄$i$与村庄$j$的道路</p><p>接下来一行包含一个正整数$Q$，表示$Q$个询问。</p><p>接下来$Q$行，每行$3$个非负整数$x, y, t$询问在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少.</p><hr><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>共$Q$行，对每一个询问$(x, y, t)$输出对应的答案。</p><p>如果在第$t$天无法找到从$x$村庄到$y$村庄的路径，或者村庄$x$或村庄$y$在第$t$天仍未修复完成，则输出$-1$。</p><hr><h3 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h3><h4 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h4><blockquote><p>4 5<br>1 2 3 4<br>0 2 1<br>2 3 1<br>3 1 2<br>2 1 4<br>0 3 5<br>4<br>2 0 2<br>0 1 2<br>0 1 3<br>0 1 4 </p></blockquote><h4 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h4><blockquote><p>-1<br>-1<br>5<br>4</p></blockquote><hr><h3 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h3><p>对于$ 30\% $的数据，有$N≤50$；</p><p>对于另外$ 30\% $的数据，$有t[i] = 0$ </p><p>对于$ 50\% $的数据，有$Q≤100$</p><p>对于$ 100$$\% $的数据，有$N≤200$，$Q≤50000$，所有输入数据均为$int$型整数且均不超过$100000$。</p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一道$Floyd$好题</p><p>彻底刷新了我对$Floyd$的看法。</p><p>首先，我们认真读一遍题目，不难发现以下几点</p><blockquote><ol><li><p><strong>$n$的取值范围极小，只有200.</strong>（疯狂暗示</p></li><li><p><strong>$t$不下降</strong>（即$t$是按时间顺序从小到大给出的）</p></li><li><p>本题<strong>可以在线求解</strong></p></li><li><p><strong>村庄标号从0开始</strong><del>（坑了我一次提交机会）</del></p></li></ol></blockquote><p>现在我们一起看一下$Floyd$算法的主要思想。</p><p>$Floyd$算法基于DP，说白了，就是<strong>用最外层循环不停的枚举每两个点之间的中间点来进行松弛操作</strong>。</p><p>而在本题中，每一个村庄是否可以作为中间点取决于它是否重建完成。<strong>也就是说，在村庄重建完成之前，它不可以作为中间点进行枚举</strong></p><p>所以我们只需要将最外层用来枚举中间点的循环加一个特判，判断该点能否被用来中转即可。</p><p>但要注意，<strong>如果起点或终点没有完成重建，需要输出-1</strong></p><p>因此，我们还需要进行一次特判，用于判断起点与重点是否重建完成。</p><blockquote><p>一个$Floyd$ + 两个特判 = 一道蓝题</p></blockquote><p>是不是很简单啊（逃）~</p><hr><h3 id="附件（AC标程，防作弊已开启）"><a href="#附件（AC标程，防作弊已开启）" class="headerlink" title="附件（AC标程，防作弊已开启）"></a>附件（AC标程，防作弊已开启）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 201 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> l , r , w;</span><br><span class="line"><span class="keyword">int</span> f[N][N];<span class="comment">//由于本题数据范围较小，作者采用邻接矩阵存图 </span></span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="keyword">int</span> x , y , t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//Floyd主体函数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - <span class="number">1</span>; j ++)&#123;</span><br><span class="line">f[i][j] = min(f[i][j] , f[i][k] + f[k][j]); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - <span class="number">1</span>; j ++)&#123;</span><br><span class="line">f[i][j] = <span class="number">1e9</span>;<span class="comment">//初始化邻接矩阵 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">f[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m - <span class="number">1</span>; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; w;</span><br><span class="line">f[l][r] = w;<span class="comment">//由于是双向道路，所以需要建两次边 </span></span><br><span class="line">f[r][l] = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;<span class="comment">//now代表今天是第几天，用于枚举天数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= q - <span class="number">1</span>; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; t;</span><br><span class="line"><span class="keyword">if</span>(a[x] &gt; t || a[y] &gt; t)&#123;<span class="comment">//特判，如果起点或终点就没有重建，直接跳过循环 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(a[now] &lt;= t &amp;&amp; now &lt; n)&#123;</span><br><span class="line">floyd(now);</span><br><span class="line">now ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f[x][y] == <span class="number">1e9</span>)&#123;<span class="comment">//如果没有联通路，输出-1 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[x][y] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Written By Payphone-X </span></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 图论 </tag>
            
            <tag> Floyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】并查集</title>
      <link href="2019/06/17/unionfind/"/>
      <url>2019/06/17/unionfind/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>Too Young Too Simple</del></p><p><del>Naive</del></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天（2019/6/16）作者中考结束，回到机房发现自己竟然<del>不会写并查集</del></p><p>于是乎……</p><p>就有了今天的这篇博客……</p><hr><h2 id="何为并查集？"><a href="#何为并查集？" class="headerlink" title="何为并查集？"></a>何为并查集？</h2><blockquote><p>并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。<br>                                                                                          ——百度百科</p></blockquote><p>嗯……</p><p>我知道你看不懂。<del>（你要是看懂了，我就该退役了）</del></p><p>还是来看看通俗一点的解释吧。</p><p>江湖上有许多大侠，它们彼此之间结交朋友，同时也互相打斗。</p><p>但是，他们绝对不会打自己的朋友，同时本着“朋友的朋友就是我的朋友”的原则，他们也不会打朋友的朋友。</p><p>这样，整个江湖就能通过朋友关系而串联起来，形成一个个帮派。</p><p>就像这样：</p><p><a href="https://imgchr.com/i/V7LIKS"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/06/17/V7LIKS.png" alt="V7LIKS.png"></a></p><p>但现在问题来了：大侠们只认识自己的朋友，那两个互不认识的人如何辨别是否属于一个帮派呐？</p><p>其实也很简单。</p><p>我们可以在每个帮派内推举出一个比较有名望的人，作为该圈子的代表人物。</p><p>这样，两人只要互相对一下自己帮派的代表是不是同一个人，就可以确定敌友关系了。</p><p>这样，每个帮派就是一个<strong>并查集</strong></p><hr><h2 id="并查集的操作"><a href="#并查集的操作" class="headerlink" title="并查集的操作"></a>并查集的操作</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>继续接着刚刚的故事讲起……</p><p>现在每一个帮派都有了一个代表，但不是所有人都认识代表，那么如何寻找自己的代表呐？</p><p><strong>直接递归搜索啊</strong></p><p>我们开一个名为pre的一维数组，用于存储每个人的上级。</p><p>比如pre[1] = 3;这就代表1的上级是3。</p><p>如果说一个人的上级是他自己，那么他就是代表了。</p><p>于是我们可以得到一个查找函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[root] == root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(pre[root]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>通过上面的结构可知，门派的组成，除了代表之外都不重要。</p><p>所以说，最后形成的门派关系结构无法预知，甚至变成一字长蛇阵也有可能。</p><p>这样的话，会大大降低查找效率。</p><p>最理想的状态就是一共只有两层结构，这样的话，每个人都可以只寻找一次就找到代表。</p><p>这样，就产生了路径压缩。</p><p>路径压缩的原理在于让每一个人都与代表交朋友，领导都直接是代表。因此，只需要把代码进行一点改动</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[root] == root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre[root] = find(pre[root]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>要查询两个人是否在同一个帮派内，只需要判断他们的代表是不是同一个人就好了</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(find(a) == find(b))&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>每一次打架，都会有战胜的一方与战败的一方。</p><p>而被打败之后，他们就会找自己的上级来打架。</p><p>因此，每一个人打架实质上都是代表来打架。</p><p>而战败的一方，就会被吞并。</p><p>这样，两个帮派就合并成了一个帮派。</p><p>代码如下:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merger</span><span class="params">(<span class="keyword">int</span> root1 , <span class="keyword">int</span> root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = find(root1);</span><br><span class="line">    <span class="keyword">int</span> b = find(root2);</span><br><span class="line">    pre[a] = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="附件：并查集-手写模板"><a href="#附件：并查集-手写模板" class="headerlink" title="附件：并查集[手写模板]"></a>附件：并查集[手写模板]</h2><p><strong>描述</strong>：见<a href="https://www.luogu.org/problemnew/show/P3367">洛谷P3367</a></p><p><strong>源代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pre[root] == root)&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> pre[root] = find(pre[root]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> x , y , z;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; z &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="keyword">if</span>(z == <span class="number">1</span>)&#123;</span><br><span class="line">pre[find(x)] = find(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(find(x) == find(y))&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Y&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;N&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Written By Payphone-X</span></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论算法】最短路（总结篇）</title>
      <link href="2019/05/01/path/"/>
      <url>2019/05/01/path/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一篇<del>迟到了三个多星期的</del>博客</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>咳咳……</p><p>现在，$Payphone-X$终于学完了最短路 <del>（其实三周前就已经学完了的个说）</del></p><p>现在，他要<del>胡扯</del>一篇最短路总结</p><hr><h2 id="定义篇"><a href="#定义篇" class="headerlink" title="定义篇"></a>定义篇</h2><p>可以先看看<del>维基百科</del>对于最短路的解释</p><blockquote><p>最短路问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。<br>                                  ——维基百科</p></blockquote><p>是不是听起来很像废话……</p><p>还是来看看通俗一点的解释吧</p><p>最短路算法，即在一个加权图中求某两点相距的最短路程的长度的算法。</p><p>分为<strong>单源最短路</strong>与<strong>多元最短路</strong>两种。</p><p>其中</p><ul><li><p>多源最短路求的是图中<strong>所有点之间</strong>的最短路。</p></li><li><p>单源最短路求的是图中任意一点到其他点之间的最短路。</p></li></ul><hr><h2 id="松弛操作"><a href="#松弛操作" class="headerlink" title="松弛操作"></a>松弛操作</h2><p>在讲松弛操作之前，我们要先明确一个事实</p><p>那就是<strong>在计算两点间的最短路时，通常不仅仅会算出两点间的最短路，而会把许多点之间的最短路一同算出来</strong></p><p>那……</p><p>这是为什么呐？？？</p><p>就是为了松弛操作。</p><p>松弛操作，从字面上解释就是指将两点间较长的路径进行替换，换为一条较短的路径。</p><p>换句话说，就是当你发现这两个地方之间还有更短的路可以走时，用这条路径来替换已知的较短路径，直到不能替换为止。</p><p>这时的“已知的较短路径”，就是我们要求解的最短路。</p><p>松弛操作的基本模式是这样的</p><ul><li><p>对于任意两点 $u$，$v$目前的最短路，我们可以用$u$，$w$与$w$，$v$之间的最短路去更新$u$，$v$的最短路，即<script type="math/tex">s(u,v) = min(s(u,v) , s(u,w) + s(w,v))</script></p></li><li><p>在计算单源最短路时，若$u$，$v$目前的最短路为$s(u,v)$， 则对于$v$所直接连到的节点$w$，有<script type="math/tex">s(u,v) = min(s(u,v) , s(u,w) + s(w,v))</script></p></li></ul><p>至于为什么这样做，原因还是在于单源——因为我们在计算单源最短路时，只关心$u$到其他点的最短路，因此$w$到$v$的最短路就极不易求。因此，我们换为两点间的直接距离来减小时间复杂度。</p><p>这就是我们为什么要计算其他点最短路——为了<strong>松弛操作</strong>的顺利进行。</p><hr><h2 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h2><blockquote><p>三层循环，意味着邻接矩阵可行。<br>                          ——Wei_taming</p></blockquote><p>众所周知，Floyd算法是一种<del>极其简单的</del>算法</p><p>但同时，它也是最快的<strong>多元最短路</strong>算法</p><p>Floyd算法基于DP，说白了，就是枚举中间点，不停地进行松弛操作来更新最短路。</p><p>代码实现也很容易，但时间复杂度比较高，为$O(n^3)$</p><p><strong>模板如下</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---Floyd---*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a , b , c;</span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">map</span> , <span class="number">0x3f</span> , <span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"><span class="built_in">map</span>[a][b] = c ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line"><span class="built_in">map</span>[i][j] = min(<span class="built_in">map</span>[i][j] , <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">map</span>[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Written By Payphone-X</span></span><br></pre></td></tr></table></figure><hr><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>众所周知，Dijkstra是一种<strong>单源最短路</strong>算法，可以用于没有负边权的最短路问题。</p><p>而且Dijkstra基于贪心，相对来说比较好想一些。</p><p>它的实现流程如下：</p><blockquote><ol><li><p>选一个点做起始点。</p></li><li><p>遍历与起始点相连的所有边，寻找出一条最短的记录下来。</p></li><li><p>把这条边的另一个端点作为起始点，然后循环。</p></li></ol></blockquote><h3 id="举个栗砸"><a href="#举个栗砸" class="headerlink" title="举个栗砸"></a>举个栗砸</h3><p>就像下图<del>（点不开的请自觉滚回长城里边）</del></p><p><a href="https://imgchr.com/i/EYx2z4"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/05/02/EYx2z4.gif" alt="EYx2z4.gif"></a></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">第一次循环，发现d[1]=0为最小值，于是标记结点1为已访问，对2，3，5进行松弛操作：</span><br><span class="line">第二次循环，发现d[2]=4为最小值，于是标记结点2为已访问，对1，3进行松弛操作：</span><br><span class="line">第三次循环，发现d[3]=5为最小值，于是标记结点3为已访问，对1，2，4进行松弛操作：</span><br><span class="line">第四次循环，发现d[5]=6为最小值，于是标记结点5为已访问，对1，4，6进行松弛操作：</span><br><span class="line">第五次循环，发现d[4]=7为最小值，于是标记结点4为已访问，对3，5，7，8进行松弛操作：</span><br><span class="line">第六次循环，发现d[8]=13为最小值，于是标记结点8为已访问，对4，7进行松弛操作：</span><br><span class="line">第七次循环，发现d[6]=14为最小值，于是标记结点6为已访问，对5，7进行松弛操作：</span><br><span class="line">第八次循环，发现d[7]=15为最小值，于是标记结点7为已访问，对4，6，8进行松弛操作：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正因如此，Dijkstra的时间复杂度较高，为$O(n^2)$</p><p>但Dijkstra的算法稳定性比较强，也就是说，<strong>Dijkstra很难被卡</strong>。</p><p>而且不难看出我们在dis数组中选择最小值时，可以用一些数据结构来进行优化。<del>线段树？平衡树？</del></p><p>下面，我们就来研究一下这些优化。</p><h3 id="Dijkstra-priority-queue"><a href="#Dijkstra-priority-queue" class="headerlink" title="Dijkstra + priority_queue"></a>Dijkstra + priority_queue</h3><ul><li><p>不难发现，当我们在dis数组中寻找最小值时，需要一个个进行遍历。</p></li><li><p>因此，我们可以将其放入优先队列（堆）中，直接弹出。</p></li><li><p>优化后的时间复杂度为$O(nlogn)$</p></li></ul><p><strong>模板如下</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---Dijkstra + Heap---*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> last;</span><br><span class="line"><span class="keyword">int</span> dis;</span><br><span class="line">&#125;edge[<span class="number">500001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge_number;</span><br><span class="line"><span class="keyword">int</span> end[<span class="number">500001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++ edge_number].to = to;</span><br><span class="line">edge[edge_number].dis  = dis;</span><br><span class="line">edge[edge_number].last = end[from];</span><br><span class="line">end[from] = edge_number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">500001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt; <span class="built_in">pair</span>&lt;<span class="keyword">int</span> , <span class="keyword">int</span>&gt; , <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span> , <span class="keyword">int</span>&gt; &gt; , greater&lt;<span class="built_in">pair</span> &lt;<span class="keyword">int</span> , <span class="keyword">int</span>&gt; &gt; &gt; Q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i != s)&#123;</span><br><span class="line">dis[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) Q.push(<span class="built_in">make_pair</span>(dis[i], i));</span><br><span class="line"><span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> v = Q.top().second;</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">if</span>(vis[v] == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line">vis[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = end[v]; i != <span class="number">0</span>;i = edge[i].last)&#123;</span><br><span class="line"><span class="keyword">int</span> to = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(dis[to] &gt; dis[v] + edge[i].dis)&#123;</span><br><span class="line">dis[to] = dis[v] + edge[i].dis; </span><br><span class="line">Q.push(<span class="built_in">make_pair</span>(dis[to],to));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m , s;</span><br><span class="line"><span class="keyword">int</span> a , b , c; </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b  &gt;&gt; c;</span><br><span class="line">add_edge(a , b , c);</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Written By Payphone-X</span></span><br></pre></td></tr></table></figure><hr><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>SPFA与Dijkstra一样，是一种<strong>单源最短路</strong>算法</p><p>而且……</p><p>SPFA<strong>可以处理负边权</strong></p><p>那么</p><p>为什么SPFA可以处理负边权呐？？？</p><p><del>众所周知</del>，SPFA是一个基于队列的算法，它的实现流程大概是这样的</p><blockquote><ol><li><p>初始化dis数组，将其全部赋值为一个很大的数</p></li><li><p>选一个点做起始点，并将起始点丢入队列。 </p></li><li><p>改变所有与起始点相连点的最短路，并做出标记</p></li><li><p>弹出起始点，把刚刚标记的所有点作为起始点丢进队列，并循环，直到队列为空为止。</p></li></ol></blockquote><p>还不懂？</p><h3 id="举个栗砸-1"><a href="#举个栗砸-1" class="headerlink" title="举个栗砸"></a>举个栗砸</h3><p>就像下图，我们以点$a$为起始点</p><p><a href="https://imgchr.com/i/EtKaSH"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/05/02/EtKaSH.jpg" alt="EtKaSH.jpg"></a></p><p>首先我们建立从点$a$到各点的最短路数组，建出来后就像这样。</p><p><a href="https://imgchr.com/i/EtK6k8"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/05/02/EtK6k8.jpg" alt="EtK6k8.jpg"></a></p><p>然后我们把起始点$a$放入队列，对以$a$为起始点的所有边进行松弛操作，并更新最短路。完成后表格如下</p><p><a href="https://imgchr.com/i/EtMl9g"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/05/02/EtMl9g.jpg" alt="EtMl9g.jpg"></a></p><p>在松弛时三个点的最短路径变小了，而这些点队列中都没有出现，因此这些点需要入队.此时，队列中新入队了三个结点$b,c,d$</p><p>之后节点$b$出队，把以$b$为起始点的所有边进行松弛操作，并更新最短路。完成后表格变成了这个样子</p><p><a href="https://imgchr.com/i/EtMDgJ"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/05/02/EtMDgJ.jpg" alt="EtMDgJ.jpg"></a></p><p>现在$e$点的最短路径也已经改变，因此，我们把它也扔进队列中。依次循环……</p><p><del>以下省略3000字……</del></p><p>最后，我们算出了所有点的最短路。表格如下</p><p><a href="https://imgchr.com/i/EtMIvd"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/05/02/EtMIvd.jpg" alt="EtMIvd.jpg"></a></p><p>是不是很简单吖<del>（逃</del></p><p>由此可以看出，SPFA在面对负边权时，不会像Dijkstra一样进行<del>无脑循环</del>，而是加入队列。</p><p>因此，SPFA是可以处理负边权的。但<strong>SPFA不能处理负权回路</strong></p><p>时间复杂度为$O(km)$， 其中，$m$为边数，而$k$为每个节点的平均入队次数，一般为2。<del>至于为啥我也不会证</del></p><p><strong>模板如下</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---SPFA---*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> dis;</span><br><span class="line"><span class="keyword">int</span> last;</span><br><span class="line">&#125;edge[<span class="number">500001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> end[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">int</span> edge_number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++edge_number].to = to;</span><br><span class="line">edge[edge_number].dis = dis;</span><br><span class="line">edge[edge_number].last = end[from];</span><br><span class="line">end[from] = edge_number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt; Q;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">500001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , s;</span><br><span class="line"><span class="keyword">int</span> a , b , c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        dis[i] = <span class="number">0x3f3f3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        first = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        visited[first] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = end[first]; i ; i = edge[i].last)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[edge[i].to] &gt; dis[first] + edge[i].dis)&#123;</span><br><span class="line">            dis[edge[i].to] = dis[first] + edge[i].dis;</span><br><span class="line">                <span class="keyword">if</span>(visited[edge[i].to] == <span class="literal">false</span>)&#123;</span><br><span class="line">                    visited[edge[i].to] = <span class="literal">true</span>;</span><br><span class="line">                    Q.push(edge[i].to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">add_edge(a , b , c);</span><br><span class="line">&#125;</span><br><span class="line">SPFA(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i] == <span class="number">0x3f3f3f</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2147483647&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//Written By Payphone-X</span></span><br></pre></td></tr></table></figure><h3 id="SPFA的算法优化"><a href="#SPFA的算法优化" class="headerlink" title="SPFA的算法优化"></a>SPFA的算法优化</h3><p>由于SPFA过于优秀<del>太容易卡</del>，因此SPFA有许多算法优化。</p><p><del>可以帮死去的SPFA做心肺复苏</del></p><p>下面，我们就来具体看一下SPFA的优化</p><h4 id="SLF（Small-Label-First）"><a href="#SLF（Small-Label-First）" class="headerlink" title="SLF（Small Label First）"></a>SLF（Small Label First）</h4><p>SLF的思路其实很简单：</p><p>我们把朴素算法下SPFA的队列改为双端队列（即deque）。</p><p>对于每一个加入队列的节点$s$，如果$dis[s]$ &lt; 队首的$dis[first]$， 则$u$被加入队首。</p><p>否则的话，$u$被加入队尾。</p><p><strong>模板如下</strong>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---SPFA + SLF---*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> dis;</span><br><span class="line"><span class="keyword">int</span> last;</span><br><span class="line">&#125;edge[<span class="number">500001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> end[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">int</span> edge_number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++edge_number].to = to;</span><br><span class="line">edge[edge_number].dis = dis;</span><br><span class="line">edge[edge_number].last = end[from];</span><br><span class="line">end[from] = edge_number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span> &gt; Q;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">500001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , s;</span><br><span class="line"><span class="keyword">int</span> a , b , c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        dis[i] = <span class="number">0x3f3f3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    Q.push_back(s);</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        first = Q.front();</span><br><span class="line">        Q.pop_front();</span><br><span class="line">        visited[first] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = end[first]; i ; i = edge[i].last)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[edge[i].to] &gt; dis[first] + edge[i].dis)&#123;</span><br><span class="line">            dis[edge[i].to] = dis[first] + edge[i].dis;</span><br><span class="line">                Q.front() = first;</span><br><span class="line"><span class="keyword">if</span>(visited[edge[i].to] == <span class="literal">false</span>)&#123;</span><br><span class="line">                    visited[edge[i].to] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dis[edge[i].to] &lt; dis[Q.front()])&#123;</span><br><span class="line">                    Q.push_front(edge[i].to);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                    Q.push_back(edge[i].to);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">add_edge(a , b , c);</span><br><span class="line">&#125;</span><br><span class="line">SPFA(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i] == <span class="number">0x3f3f3f</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2147483647&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//Written By Payphone-X</span></span><br></pre></td></tr></table></figure></p><h4 id="LLL（Large-Label-Last）"><a href="#LLL（Large-Label-Last）" class="headerlink" title="LLL（Large Label Last）"></a>LLL（Large Label Last）</h4><p>LLL的思路也很简单。</p><p>对于每一个要入队的节点$s$，我们把$dis[s]$与$dis$的平均值比较。</p><p>若$dis[s]$更大，就把其放入队尾，再取队首元素进行比较。直到队首的$dis[s]$ &lt; $dis$的平均值为止。</p><p><strong>模板如下</strong>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---SPFA + LLL---*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> dis;</span><br><span class="line"><span class="keyword">int</span> last;</span><br><span class="line">&#125;edge[<span class="number">500001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> end[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">int</span> edge_number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++edge_number].to = to;</span><br><span class="line">edge[edge_number].dis = dis;</span><br><span class="line">edge[edge_number].last = end[from];</span><br><span class="line">end[from] = edge_number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt; Q;</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">int</span> n , m , s;</span><br><span class="line"><span class="keyword">int</span> a , b , c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = s , sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; i ++)&#123;</span><br><span class="line">dis[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">Q.push(s);</span><br><span class="line">visited[s] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> first;</span><br><span class="line"><span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">first = Q.front();</span><br><span class="line"><span class="keyword">while</span>(dis[first]*cnt &gt; sum)&#123;</span><br><span class="line">Q.pop();</span><br><span class="line">Q.push(first);</span><br><span class="line">first = Q.front();</span><br><span class="line">&#125;</span><br><span class="line">Q.pop();</span><br><span class="line">cnt--;</span><br><span class="line">sum = sum - dis[first];</span><br><span class="line">visited[first]  = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = end[first]; i != <span class="number">0</span>; i = edge[i].last)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[edge[i].to] &gt; dis[first] + edge[i].dis)&#123;</span><br><span class="line">dis[edge[i].to] = dis[first] + edge[i].dis;</span><br><span class="line"><span class="keyword">if</span>(visited[edge[i].to] == <span class="literal">false</span>)&#123;</span><br><span class="line">sum = sum + dis[edge[i].to];</span><br><span class="line">cnt ++;</span><br><span class="line">Q.push(edge[i].to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">add_edge(a , b , c);</span><br><span class="line">&#125;</span><br><span class="line">SPFA(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i] == <span class="number">0x3f3f3f</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2147483647&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Written By Payphone-X</span></span><br></pre></td></tr></table></figure></p><h4 id="SLF-LLL"><a href="#SLF-LLL" class="headerlink" title="SLF + LLL"></a>SLF + LLL</h4><p>不多说，直接上代码</p><p><strong>模板如下</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---SPFA + SLF + LLL---*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> last;</span><br><span class="line"><span class="keyword">int</span> dis;</span><br><span class="line">&#125;edge[<span class="number">500001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> end[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">int</span> edge_number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++edge_number].to = to;</span><br><span class="line">edge[edge_number].dis = dis;</span><br><span class="line">edge[edge_number].last = end[from];</span><br><span class="line">end[from] = edge_number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">int</span> n , m , s;</span><br><span class="line"><span class="keyword">int</span> a , b , c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span> &gt;Q;</span><br><span class="line">    <span class="keyword">int</span> cnt = s , sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        dis[i] = <span class="number">0x3f3f3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    Q.push_back(s);</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        first = Q.front();</span><br><span class="line">        <span class="keyword">while</span>(dis[first]*cnt &gt; sum)&#123;</span><br><span class="line">            Q.pop_back();</span><br><span class="line">            Q.push_back(first);</span><br><span class="line">            first = Q.front();</span><br><span class="line">        &#125;</span><br><span class="line">        Q.pop_front();</span><br><span class="line">        cnt--;</span><br><span class="line">        sum-= dis[first];</span><br><span class="line">        visited[first] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = end[first]; i != <span class="number">0</span> ; i = edge[i].last)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[edge[i].to] &gt; dis[first] + edge[i].dis)&#123;</span><br><span class="line">                dis[edge[i].to] = dis[first] + edge[i].dis;</span><br><span class="line">                <span class="keyword">if</span>(visited[edge[i].to] == <span class="literal">false</span>)&#123;</span><br><span class="line">                    sum+=dis[edge[i].to];</span><br><span class="line">                    cnt ++;</span><br><span class="line">                    <span class="keyword">if</span>(dis[edge[i].to] &lt; dis[Q.front()])&#123;</span><br><span class="line">                    Q.push_front(edge[i].to);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> Q.push_back(edge[i].to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">add_edge(a , b , c);</span><br><span class="line">&#125;</span><br><span class="line">SPFA(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i] == <span class="number">0x3f3f3f</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2147483647&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Written By Payphone-X</span></span><br></pre></td></tr></table></figure></p><p>综合来说，在使用SLF优化时可以使SPFA的运行效率提升 15% ~ 20% ，而SLF + LLL可以使SPFA效率提高 50% 以上。</p><p><del>但还是能卡掉哒QAQ</del></p><h3 id="卡SPFA"><a href="#卡SPFA" class="headerlink" title="卡SPFA"></a>卡SPFA</h3><p>不知道你们有没有在luogu上看到这么一句话</p><blockquote><p>关于SPFA， 它死了。</p></blockquote><p>事情其实是这样的</p><p><strong>在NOI 2018 Day1 T1归程 中，出题人卡了SPFA，导致使用SPFA求最短路的OIer们从$100-&gt; 60$ , $Ag-&gt;Cu$.</strong></p><p>很多选手，都因此没能与理想的大学签约……（下图为NOI 2018时出题人讲评时的照片）</p><p><a href="https://imgchr.com/i/ENfx8P"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/05/03/ENfx8P.jpg" alt="ENfx8P.jpg"></a></p><p>或者说，你们可以看一下某乎上的<a href="https://www.zhihu.com/question/292283275">一篇文章</a></p><p>作者在这篇文章里找到了一位用户的回答：</p><blockquote><p>SPFA 的受到怀疑和最终消亡，是 OI 界水平普遍提高、命题规范完善和出题人的使命感和责任心增强的最好见证。<br>                                                                                   ——一位知乎用户</p></blockquote><p>作者不对这位用户做出任何评价，因为作者也没有这个资格。</p><p>但作者认为，<strong>如果一昧的在存在负边权的图中丧心病狂的卡SPFA，也没有什么意思。</strong></p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ol><li><p><a href="https://herself32.github.io">Herself32’s Github Blog</a></p></li><li><p><a href="https://sshwy.gitee.io">Sshwy’s Blog</a></p></li><li><p><a href="https://www.luogu.org/blog/xhhkwy/spfa-hacker-orzorz">洛谷日报第111期-SPFA算法的玄学方法</a></p></li><li><p><a href="https://blog.csdn.net/muxidreamtohit/article/details/7894298">muximuxi525’s博客园</a></p></li></ol></blockquote><p>鸣谢上面的几位dalao在最短路方面给予我的帮助</p><hr><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul><li><p>2019.5.2 更新了SPFA， SPFA + SLF代码，并修改少量错别字。</p></li><li><p>2019.5.3 更新了SPFA + LLL， SPFA + SLF + LLL 代码，卡SPFA， 参考资料部分.</p></li></ul><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图论 </tag>
            
            <tag> Floyd </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> Algorithm </tag>
            
            <tag> SPFA </tag>
            
            <tag> 总结篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【文化课专栏】历史篇(1)</title>
      <link href="2019/04/13/history/"/>
      <url>2019/04/13/history/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>我本以为那个时代已经过去，殊不知当你歌唱时，属于那个时代的一切都在归来。<br>                               ——《繁华唱遍》</p></blockquote><a id="more"></a><h3 id="Hello-history"><a href="#Hello-history" class="headerlink" title="Hello,history"></a>Hello,history</h3><p>Hi，文化课选手们</p><p>Payphone-X又回来啦 <del>（虽说两个多月都没有更新了的个说</del></p><p>咳咳……</p><p>现在我们说正事。</p><p>这次更新，Payphone-X带来了一套<strong>历史模拟题</strong></p><p>难度嘛……</p><p>也不是很大 <del>有点自闭</del></p><p>更重要的是</p><p>试卷80%以上都是Payphone-X原创而成，也有很多是Payphone-X平时做错过的题目</p><p>所以说……</p><p>还是具有一定代表性哒 》-《</p><p>下载地址留在这了</p><p>需要的话自行下载哦</p><blockquote><p>链接：链接：<a href="https://pan.baidu.com/s/17Sb4LP3XH7mcvXcDt-F2QA">https://pan.baidu.com/s/17Sb4LP3XH7mcvXcDt-F2QA</a><br>提取码：7asy </p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><ul><li>2019.4.30 重新上传了答案，并修复了无法提取的问题</li></ul><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 文化课专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文化课专栏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【福建省历届夏令营】封锁阳光大学-题解</title>
      <link href="2019/03/20/luoguP1330/"/>
      <url>2019/03/20/luoguP1330/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>读书人的事情，那能叫刷街吗？<br>                      ——《孔乙己》</p></blockquote><a id="more"></a><h3 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h3><p><del>（唐）</del>曹是一只爱刷街的老<del>（唐）</del>曹……</p><p>暑假期间，他每天都欢快地在阳光大学的校园里刷街。</p><p>河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹<del>（唐）</del>刷街。</p><p>阳光大学的校园是一张由N个点构成的无向图，N个点之间由M条道路连接。</p><p>每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹<del>（唐）</del>就无法在与这些道路上刷街了。</p><p>但非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。</p><p>现在问题来了：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。</p><hr><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行：两个整数N，M</p><p>接下来M行，每行两个整数A，B，表示点A到点B之间有道路相连。</p><hr><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>仅输出一行</p><p>如果河蟹无法封锁所有道路，则输出一个字符串“Impossible”</p><p>否则输出一个整数，表示最少需要多少只河蟹</p><hr><h3 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h3><h4 id="Input-‘s-eg-1"><a href="#Input-‘s-eg-1" class="headerlink" title="Input ‘s eg 1"></a>Input ‘s eg 1</h4><blockquote><p>3 3<br>1 2<br>1 3<br>2 3</p></blockquote><h4 id="Output-‘s-eg-1"><a href="#Output-‘s-eg-1" class="headerlink" title="Output ‘s eg 1"></a>Output ‘s eg 1</h4><blockquote><p>Impossible</p></blockquote><h4 id="Input-‘s-eg-2"><a href="#Input-‘s-eg-2" class="headerlink" title="Input ‘s eg  2"></a>Input ‘s eg  2</h4><blockquote><p>3 3<br>1 2<br>2 3</p></blockquote><h4 id="Output-‘s-eg-2"><a href="#Output-‘s-eg-2" class="headerlink" title="Output ‘s eg 2"></a>Output ‘s eg 2</h4><blockquote><p>1</p></blockquote><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一道好题，如果有思路的话还是很好写的。</p><p>下面，我们就来分析几种做法。</p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>首先，你可能本着<del>枚举法无敌论</del>的原则选择枚举</p><p>但是……</p><p><del>超高的时间复杂度会让你呕吐的</del></p><p>我们可以分析一下，假设这张图是有解的，那么枚举一定会枚举出所有Impossible的情况才能确定有解。</p><p>而Impossible的数量与点数有关，如果大一点，就可能有上百万种……（这就是为什么暴力比正解还难写）</p><p>因此，<strong>枚举是不可以的</strong></p><h4 id="直接dfs-amp-bfs"><a href="#直接dfs-amp-bfs" class="headerlink" title="直接dfs &amp; bfs"></a>直接dfs &amp; bfs</h4><p>同理，会被卡死在时间复杂度上，不多解释<del>（其实是作者太懒了……）</del></p><h4 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h4><p>很显然，这是一个非连通图，所以我们可以把它<strong>拆成许多个连通子图</strong>来做</p><p>多读几遍题目，不难发现两个关键点：</p><blockquote><p>1.每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了<br>2.当两只河蟹封锁了相邻的两个点时，他们会发生冲突。</p></blockquote><p>翻译成人话就是</p><p><strong>一条边的两个端点上 必须有 且 只有一个端点 上有河蟹</strong></p><p>是不是明白了什么？</p><p>这就是一道二分图染色题啊！（ps.即把相邻的两个点染成不同的颜色）</p><p>对于一张连通子图，只有三种染色情况，分别是color1 ，color2和Impossible</p><p>所以，我们把所有子图染一遍色，如果有一个为Impossible就输出答案，如果没有，就把结果加起来取min即可</p><p>是不是很简单啊（逃）~</p><hr><h3 id="附件（AC标程，防作弊已开启）"><a href="#附件（AC标程，防作弊已开启）" class="headerlink" title="附件（AC标程，防作弊已开启）"></a>附件（AC标程，防作弊已开启）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> last;<span class="comment">//一只可爱的链式前向星 </span></span><br><span class="line">&#125;edge[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> end[N];</span><br><span class="line"><span class="keyword">int</span> edge_number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">edge[++edge_number].to = to;</span><br><span class="line">edge[edge_number].last = end[from];</span><br><span class="line">end[from] = edge_number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;<span class="comment">//最后的答案 </span></span><br><span class="line"><span class="keyword">int</span> color[N];<span class="comment">//表示该点的颜色 </span></span><br><span class="line"><span class="keyword">bool</span> visit[N];<span class="comment">//表示该点是否染过色</span></span><br><span class="line"><span class="keyword">int</span> number[<span class="number">2</span>];<span class="comment">//表示该颜色的点的数量 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> color2)</span></span>&#123;<span class="comment">//color2表示该点染成的颜色,返回的如果为false，则为Impossible </span></span><br><span class="line"><span class="keyword">if</span>(visit[s])&#123;</span><br><span class="line"><span class="keyword">if</span>(color[s] == color2)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="comment">//特判，如果该点染过色，就判断染得颜色是否与本次的一致 </span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visit[s] = <span class="literal">true</span>;</span><br><span class="line">color[s] = color2;<span class="comment">//给该点染色 </span></span><br><span class="line">number[color2] ++;<span class="comment">//该颜色的点数量+1 </span></span><br><span class="line"><span class="keyword">bool</span> p = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = end[s]; i != <span class="number">0</span> &amp;&amp; p != <span class="number">0</span>; i = edge[i].last)&#123;</span><br><span class="line">p = p &amp;&amp; draw(edge[i].to , !color2);<span class="comment">//判断与另一端点是否冲突 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> ans)</span></span>&#123;</span><br><span class="line">ans+= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a , b;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">add_edge(a , b);</span><br><span class="line">add_edge(b , a);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[i] == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">number[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//每次清空该颜色的数量 </span></span><br><span class="line">number[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!draw(i , <span class="number">0</span>))&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = ans + min(number[<span class="number">0</span>] , number[<span class="number">1</span>]);</span><br><span class="line">&#125; </span><br><span class="line">work(ans);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 图论 </tag>
            
            <tag> Luogu </tag>
            
            <tag> 染色法 </tag>
            
            <tag> 夏令营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论算法】链式前向星(邻接表)</title>
      <link href="2019/03/16/linjiebiao/"/>
      <url>2019/03/16/linjiebiao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于摆脱$O(n^2)$的空间复杂度啦</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本周三(2019.3.13)，Payphone-X学完了Dijkstra，他要继续向SPFA前进。但是，他不会邻接表……于是便有了这篇Blog</p><hr><h3 id="初始约定"><a href="#初始约定" class="headerlink" title="初始约定"></a>初始约定</h3><p>在下文的邻接表讲解以及代码实现中，很多时候会出现(from , to , number)</p><p>这表示一条边，从from到to ，编号为number。</p><p>就像下图，为(1 , 2 , 0)：</p><p><a href="https://imgchr.com/i/AV0bxs"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/03/16/AV0bxs.png" alt="AV0bxs.png"></a></p><hr><h3 id="何为邻接表？"><a href="#何为邻接表？" class="headerlink" title="何为邻接表？"></a>何为邻接表？</h3><blockquote><p>邻接表，存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的存储结构。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。<br>                                                                              ——百度百科</p></blockquote><p>emm……</p><p>算了……</p><p>以后不能再用百度百科了……</p><p>还是听听通俗的解释吧。</p><p>顾名思义，邻接表是一种特殊的链表，用来表示一条边。</p><p>无权图上，每一张链表存储了两个信息：</p><p><strong>这条边的到达的节点 与 从出发点出发的上一条边</strong>。</p><p>而有权图上，则存储了三个：</p><p><strong>这条边的到达的节点 与 从出发点出发的上一条边 以及 边权</strong></p><p>也就是说，邻接表是用边来存图，而邻接矩阵使用点来存图。</p><hr><h3 id="邻接表的实现"><a href="#邻接表的实现" class="headerlink" title="邻接表的实现"></a>邻接表的实现</h3><p>看到这，有的同学可能要问了：既然邻接表使用来存图的，那怎么实现它呐？</p><p>别急……</p><p>继续向下看就知道啦……</p><p>邻接表存储的信息有两到三个<del>（不知道是哪几个的自觉面壁）</del>，并且每一条边都需要一张链表。</p><p>所以说……</p><p><strong>开结构体模拟啊</strong></p><p>但一个结构体还不够，我们还需要开一个一维数组记录当前边的上一条边的编号，开一个int变量记录边数。</p><p>代码实现是这样的(ps.无权图)：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> last;</span><br><span class="line">&#125;edge[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> end[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> edge_number;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="add-edge"><a href="#add-edge" class="headerlink" title="add_edge"></a>add_edge</h4><p>现在，我们已经会建立邻接表了。</p><p>那……</p><p>我们如何加边呐？</p><p>想想看，我们输入的是不是这条边的from与to？</p><p>所以结构体的to就已经解决了啊。</p><p>如果有变权的话就把输入的边权赋值给结构体中的边权就好啦</p><p>所以边权也解决啦</p><p>而上一条边，就是end数组中以from为下标的点啊</p><p>所以last也解决了。</p><p>最后<strong>别忘了更新一下end数组</strong>，使上一条边的编号变成刚刚加入的这条边。</p><p>代码实现是这样的(ps.有向无权图)：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">edge[++edge_number].to = to;</span><br><span class="line">edge[edge_number].last = end[from];</span><br><span class="line">end[from] = edge_number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="附件（邻接表模板，有向有权图）"><a href="#附件（邻接表模板，有向有权图）" class="headerlink" title="附件（邻接表模板，有向有权图）"></a>附件（邻接表模板，有向有权图）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> last;</span><br><span class="line"><span class="keyword">int</span> longg;</span><br><span class="line">&#125;edge[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> end[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> edge_number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , <span class="keyword">int</span> longg)</span></span>&#123;</span><br><span class="line">edge[++edge_number].to = to;</span><br><span class="line">edge[edge_number].last = end[from];</span><br><span class="line">edge[edge_number].longg = longg;</span><br><span class="line">end[from] = edge_number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Written By Payphone-X</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 链式前向星 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论算法】Dijkstra</title>
      <link href="2019/02/27/Dijkstra/"/>
      <url>2019/02/27/Dijkstra/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>谁能告诉我这到底叫迪杰斯特拉还是叫迪杰克斯特拉？？？</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>周末(2019/2/23)，Payphone-X学完了唯一的多元最短路，现在，他开始向单元最短路进击啦（给自己一个小小的鼓励）</p><hr><h3 id="何为Dijkstra"><a href="#何为Dijkstra" class="headerlink" title="何为Dijkstra"></a>何为Dijkstra</h3><p>先看看百度百科对于Dijkstra的解释</p><blockquote><p>迪杰斯特拉算法是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题。主要特点是以起始点为中心向外层扩展，直到扩展到终点为止。<br>                                                                                              ——百度百科</p></blockquote><p>……</p><p>先不看了……</p><p>度娘装高冷的毛病什么时候能改改啊……</p><p>还是看看通俗点的解释吧</p><p>在前边，我们已经学习了唯一的多元最短路，现在我们学习的<strong>Dijkstra是一种单元最短路算法</strong>。</p><p>（不知道啥是单元最短路的请自觉滚回<a href="https://payphone-x.github.io/2019/02/23/Floyd/#more">Floyd</a>）</p><p>时间复杂度为$O(n^2)$，比Floyd的暴力三循环快了好多的。</p><p>但要注意，<strong>Dijkstra只适用于没有负边权的情况</strong>。也就是说，如果图中有一条边的边权为负数，就不可以使用Dijkstra了。</p><hr><h3 id="Dijkstra的算法实现"><a href="#Dijkstra的算法实现" class="headerlink" title="Dijkstra的算法实现"></a>Dijkstra的算法实现</h3><p>在讲算法实现之前，先上一组数据。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 6    // 5个点，6条边</span><br><span class="line">1 2 4     //1与2之间有一条边权为4的边</span><br><span class="line">2 3 2     //同上</span><br><span class="line">3 5 6</span><br><span class="line">1 4 1</span><br><span class="line">2 4 2</span><br><span class="line">3 4 4</span><br><span class="line">1   //初始点为1</span><br></pre></td></tr></table></figure><p>把图建出来大概是这样的</p><p><a href="https://imgchr.com/i/kqm14s"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/03/02/kqm14s.png" alt="kqm14s.png"></a></p><p>现在我们开始讲Dijkstra的算法实现。</p><p>Dijkstra是一种类似于贪心的算法，步骤大概是下边这样：</p><pre><code>1.选一个点做起始点。2.遍历与起始点相连的所有边，寻找出一条最短的记录下来。3.把这条边的另一个端点作为起始点，然后循环。</code></pre><p>下面我们来用数据模拟一下。</p><p>首先，我们开一个number数组，用来存储1到点n的估计值。（说估计值是因为<strong>当前不一定是最短路</strong>，不理解的话一会就知道为什么了）</p><p>之后，我们用一个邻接矩阵map存储点i到j的距离，并把map的所有元素初始化为无穷大。</p><p>再定义一个start，表示下一个起始点，一个minn，表示下一个起始点到原点的最短距离。</p><p>先从1号点开始，得到map[1][2] = 4, map[1][4] = 1，则number[2] = 4, number[4] = 1，3与5两个点没有搜索到，不更新，还是无穷大。</p><p>很显然，现在的number数组还不是最终的答案。所以我们要进行第二次更新。</p><p>那……</p><p>为什么我们要把最短边的另一端点作为下一个起始点呐？</p><p>想想看，如果我们把另一端点作为下一次搜索的起始点，就可以得到每一个点到该点的最短路。再加上从这一个端点到初始点的最短路，就可以得到初始点到所有点的最短路啦</p><p>之后不断循环，直到循环过所有数据为止 <del>（其实是作者太懒，不想推了）</del></p><p>最后答案是0 4 6 1 12</p><p>主体代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;<span class="comment">//s为初始点编号 </span></span><br><span class="line"><span class="built_in">memset</span>(number , <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(number));<span class="comment">//初始化估计值数组 </span></span><br><span class="line"><span class="keyword">int</span> start = s;<span class="comment">//从初始点搜索 </span></span><br><span class="line">bj[start] = <span class="literal">true</span>;<span class="comment">//标记已被搜索 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">number[i] = min(number[i] , <span class="built_in">map</span>[start][i]);<span class="comment">//先更新一遍 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line"><span class="keyword">int</span> minn = <span class="number">9999999</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(bj[j] == <span class="literal">false</span> &amp;&amp; number[j] &lt; minn)&#123;<span class="comment">//找到最近的点，并记录编号，便于下次搜索。 </span></span><br><span class="line">minn = number[j];</span><br><span class="line">start = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bj[start] = <span class="literal">true</span>; <span class="comment">//注意这句话一定在for循环外，不然会有点搜不到 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">number[j] = min(number[j] , number[start] + <span class="built_in">map</span>[start][j]); </span><br><span class="line">&#125;   <span class="comment">//最后更新一遍 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>是不是很简单吖（逃）</p><hr><h3 id="附件（Dijkstra模板，邻接矩阵实现）"><a href="#附件（Dijkstra模板，邻接矩阵实现）" class="headerlink" title="附件（Dijkstra模板，邻接矩阵实现）"></a>附件（Dijkstra模板，邻接矩阵实现）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number[<span class="number">10001</span>];<span class="comment">//存储估计值 </span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">1001</span>][<span class="number">1001</span>];<span class="comment">//存储邻接矩阵 </span></span><br><span class="line"><span class="keyword">int</span> m , n;</span><br><span class="line"><span class="keyword">int</span> bj[<span class="number">10001</span>];<span class="comment">//用来标记该点是否搜索过 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;<span class="comment">//s为初始点编号 </span></span><br><span class="line"><span class="built_in">memset</span>(number , <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(number)); <span class="comment">//初始化估计值数组 </span></span><br><span class="line"><span class="keyword">int</span> start = s;<span class="comment">//从初始点搜索 </span></span><br><span class="line">bj[start] = <span class="literal">true</span>;<span class="comment">//标记已被搜索 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">number[i] = min(number[i] , <span class="built_in">map</span>[start][i]);<span class="comment">//先更新一遍 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line"><span class="keyword">int</span> minn = <span class="number">9999999</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(bj[j] == <span class="literal">false</span> &amp;&amp; number[j] &lt; minn)&#123;<span class="comment">//找到最近的点，并记录编号，便于下次搜索。 </span></span><br><span class="line">minn = number[j];</span><br><span class="line">start = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bj[start] = <span class="literal">true</span>; <span class="comment">//注意这句话一定在for循环外，不然会有点搜不到 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">number[j] = min(number[j] , number[start] + <span class="built_in">map</span>[start][j]); </span><br><span class="line">&#125;<span class="comment">//最后更新一遍 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">map</span> , <span class="number">0x3f</span> , <span class="keyword">sizeof</span>(<span class="built_in">map</span>));<span class="comment">//初始化邻接矩阵 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a , b , c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">map</span>[a][b] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">     <span class="built_in">map</span>[i][j] = <span class="number">0</span>;<span class="comment">//自己到自己的距离为0 </span></span><br><span class="line">    &#125;               </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> yuan;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; yuan;</span><br><span class="line">    Dijkstra(yuan);<span class="comment">//输入源点。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; number[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Written By Payphone-X</span></span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图论 </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论算法】Floyd</title>
      <link href="2019/02/23/Floyd/"/>
      <url>2019/02/23/Floyd/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>知道Floyd的精神分析吗？</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>经过一个假期的集训，Payphone-X发现自己太菜了。他想要变强！于是乎，他开始学习最短路。</p><hr><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在开始最短路的学习之前，我们不妨看一道题目</p><p><a href="https://imgchr.com/i/khGAf0"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/02/23/khGAf0.jpg" alt="khGAf0.jpg"></a></p><p>暑假，小哼准备去一些城市旅游。</p><p>在他旅行之前，他提前查了一下地图，发现有些城市之间有公路，有些城市之间则没有，城市之间的公路长度也不一样。</p><p>地图如下</p><p><a href="https://imgchr.com/i/khG3fx"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/02/23/khG3fx.png" alt="khG3fx.png"></a></p><p>为了节省经费以及方便计划，小哼希望在出发之前知道<strong>任意两个城市之间的最短路程</strong>。</p><p>聪明的你，能帮帮可爱的小哼吗？</p><p>（ps.最短路的所有题目不遵循三角不等式，so不要讽刺作者的数学了）</p><hr><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>看完地图之后，是不是有了点想法。</p><p>是不是觉得对每两个点跑dfs一遍就行了？</p><p>嗯……</p><p><del>你会TLE到飞起</del></p><p>所以，还有别的办法吗？</p><p>想一想……</p><p>如果我们想让两个点的路径更短，是不是可以尝试一下引入第三个点？</p><p>就像下图</p><p><a href="https://imgchr.com/i/khJlDg"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/02/23/khJlDg.png" alt="khJlDg.png"></a></p><p>如果我们从A到C，再从 C到B，是不是比直接从A到B的距离更短。</p><p>这，就是Floyd算法的核心。</p><hr><h3 id="Floyd的算法实现"><a href="#Floyd的算法实现" class="headerlink" title="Floyd的算法实现"></a>Floyd的算法实现</h3><p>Floyd算法的强大之处在于它是四大最短路算法中唯一一个求<strong>多元最短路</strong>的算法 </p><p>额……</p><p>好像忘了科普多元最短路了。</p><p>最短路算法分为<strong>单元最短路</strong>与<strong>多元最短路</strong></p><p>单元最短路指<strong>从一个点到除它以外所有点的最短路</strong>，而多元最短路指<strong>从每个点到除它以外所有点的最短路</strong></p><p>而Floyd是唯一一个求多元最短路的算法。</p><p>并且Floyd算法实现难度很低，只有3个循环与一个if语句。</p><p>代码如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k =  <span class="number">1</span>; k &lt;= n; k++)&#123;   <span class="comment">//枚举中间的城市</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">//枚举起点城市</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;    <span class="comment">//枚举终点城市</span></span><br><span class="line">            <span class="keyword">if</span>(w[i][j] &gt; w[i][k] + w[k][j])&#123;    <span class="comment">//w[i][j]表示从i到j的最短路</span></span><br><span class="line">                w[i][j] = w[i][k] + w[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然，Floyd也可以用来判断两个点是否连通，只需要稍加修改一下if之中的语句即可。</p><p>时间复杂度为$O(n^3)$</p><hr><h3 id="附件-Floyd模板"><a href="#附件-Floyd模板" class="headerlink" title="附件(Floyd模板)"></a>附件(Floyd模板)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a, b,chang;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; chang;</span><br><span class="line"> w[a][b] = chang;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(w[i][j] &gt; w[i][k] + w[k][j])&#123;</span><br><span class="line">w[i][j] = w[i][k] + w[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; w[i][j] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图论 </tag>
            
            <tag> Floyd </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【国家集训队】阿狸和桃子的游戏-题解</title>
      <link href="2019/02/17/luoguP4643/"/>
      <url>2019/02/17/luoguP4643/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>如果你相信洛谷的难度评级，你还不如去买彩票。<br>                                  ——zhx长者</p></blockquote><a id="more"></a><h3 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h3><p>阿狸和桃子正在玩一个游戏，游戏是在一个带权图 $G=(V, E)$ 上进行的，设节点权值为$w(v)$，边权为$c(e)$。</p><p>游戏规则如下：</p><p>1.阿狸和桃子轮流将图中的顶点染色，阿狸会将顶点染成红色，桃子会将顶点染成粉色。已经被染过色的点不能再染了，而且每一轮都必须给一个且仅一个顶点染色。</p><p>2.为了保证公平性，节点的个数N为偶数。</p><p>3.经过 N/2 轮游戏之后，两人都会得到一个顶点集合。对于顶点集合S，得分计算方式为:</p><script type="math/tex; mode=display">\sum_{v \in S}w(v) + \sum_{e=(u,v)\in E \land u,v\in S}c(e)</script><p>由于阿狸石头剪子布输给了桃子，所以桃子先染色。两人都想要使自己的分数比对方多，且多得越多越好。如果两人都是采用最优策略的，求最终桃子的分数减去阿狸的分数。</p><hr><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行包含两个正整数N和M，分别表示图G的节点数和边数，保证N一定是偶数。</p><p>　　接下来N+M行。</p><p>　　前N行，每行一个整数w，其中第k行为节点k的权值。</p><p>　　后M行，每行三个用空格隔开的整数a b c，表示一条连接节点a和节点b的边，权值为c。</p><hr><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>　输出仅包含一个整数ans，为桃子的得分减去阿狸的得分。</p><hr><h3 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h3><h5 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h5><blockquote><p>4 4<br>6<br>4<br>-1<br>-2<br>1 2 1<br>2 3 6<br>3 4 3<br>1 4 5</p></blockquote><h5 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h5><blockquote><p>3</p></blockquote><hr><h3 id="数据范围和约定："><a href="#数据范围和约定：" class="headerlink" title="数据范围和约定："></a>数据范围和约定：</h3><p>对于40%的数据，1 ≤ N ≤ 16。<br>对于100%的数据，1 ≤ N ≤ 10000，1 ≤ M ≤ 100000，-10000 ≤ w , c ≤ 10000。</p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>蓝题的思维难度 + 橙题的代码量 = 一道黑题<br>                               ——<em>Herself32</em>   </p></blockquote><p>简单的博弈论问题（逃）</p><p>而且一定有人看不懂公式（逃 X2）</p><p>那……</p><p>我们就先来解释一下公式吧。</p><p>下面是公式翻译机：</p><p>经过 N/2 轮游戏之后，两人都会得到一个顶点集合。对于顶点集合S，得分计算方式为:</p><p><strong>他们染色的顶点点权 + 他们同种颜色的顶点组成线段的边权</strong></p><p>还不会做？</p><p>好吧……</p><p>画个图解释下<del>(你们绝对看不出我是用画图手绘的)</del></p><p>这是两个点，点权为A &amp; B，中间的边权为C，答案记为ans</p><p><a href="https://imgchr.com/i/khAUeO"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/02/23/khAUeO.png" alt="khAUeO.png"></a></p><p>如果两个点都被桃子染了，就像这样</p><p><a href="https://imgchr.com/i/khATlq"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/02/23/khATlq.png" alt="khATlq.png"></a></p><p>那么，ans = 桃子的得分 - 阿狸的得分 = A + B + C</p><p>但，如果我们吧边权二分，分给每个节点</p><p>ans = (A + C / 2) + (B + C / 2) = A + B + C</p><p>答案是不变的</p><p>同理，阿狸也是这样。但如果他们一人染了一个点，就像下图这样</p><p><a href="https://imgchr.com/i/khAopn"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/02/23/khAopn.png" alt="khAopn.png"></a></p><p>边权二分还可以吗？</p><p>答案是肯定的。</p><p>在不二分的情况下，中间边权可以忽略，则ans = B - A</p><p>如果二分，则答案为ans =  (B + C / 2) - (A + C / 2) = B - A</p><p>综上所述，二分边权是可行的。</p><p>是不是很简单(逃 X3)</p><hr><h3 id="附件（AC标程，防作弊已开启）"><a href="#附件（AC标程，防作弊已开启）" class="headerlink" title="附件（AC标程，防作弊已开启）"></a>附件（AC标程，防作弊已开启）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> point[<span class="number">100001</span>],w[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">point[i] = <span class="number">2</span> * w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">point[a] = point[a] + c;</span><br><span class="line">point[b] = point[b] + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">sort(point + <span class="number">1</span>, point + <span class="number">1</span> + n);</span><br><span class="line"><span class="keyword">while</span>(n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">ans = point[n--] - point[n--] + ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> Luogu </tag>
            
            <tag> WC/CTSC/集训队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【文化课专栏】英语篇(1)</title>
      <link href="2019/02/12/English-1/"/>
      <url>2019/02/12/English-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学不好英语，怎么看代码？</p><p><del>好像没啥关系吧……</del></p><a id="more"></a><hr><p>前几天Payphone-X做英语时看到了这么一句话：</p><p><strong>English is the most interesting language!</strong></p><p><strong><del>我信你个鬼啊</del></strong></p><p>咳咳……</p><p>以下是Payphone-X做试卷时犯过的一些错误，希望能给中考党们一些提醒吧</p><h3 id="Lie-amp-Lay"><a href="#Lie-amp-Lay" class="headerlink" title="Lie &amp; Lay"></a>Lie &amp; Lay</h3><p>不多说，直接上表</p><div class="table-container"><table><thead><tr><th>单词原型</th><th style="text-align:right">过去式</th><th style="text-align:center">过去分词</th></tr></thead><tbody><tr><td>lie</td><td style="text-align:right">lay</td><td style="text-align:center">lain</td></tr><tr><td>lay</td><td style="text-align:right">laid</td><td style="text-align:center">laid</td></tr></tbody></table></div><p>当时作者因为没弄懂这几个单词，活生生的被扣了2pts （T^T）</p><hr><h3 id="It的用法"><a href="#It的用法" class="headerlink" title="It的用法"></a>It的用法</h3><blockquote><p>it可放于宾语的位置，做形式宾语，代替后面真正的宾语。<br>                                              ——百度百科</p></blockquote><p><strong>For eample</strong>：</p><blockquote><p>I find it easy to get on well with him</p></blockquote><p>其中，it为形式宾语，而easy to get on well with him才是真正的宾语。</p><p>又是2pts啊……</p><hr><h3 id="Beside-amp-Except"><a href="#Beside-amp-Except" class="headerlink" title="Beside &amp; Except"></a>Beside &amp; Except</h3><p>可能你看到这俩词会觉得作者很菜<del>（虽然确实很菜）</del></p><p>但不得不说，这俩词确实是有区别的。</p><p>beside和except的意思都是除了，</p><p>但<strong>beside指除了这个之外，还有别的东西</strong>，而<strong>except指除了这个就没有了</strong></p><p>2pts X3……</p><hr><h3 id="定语从句中的复合不定代词"><a href="#定语从句中的复合不定代词" class="headerlink" title="定语从句中的复合不定代词"></a>定语从句中的复合不定代词</h3><p>在定语从句中，如果<strong>先行词为复合不定代词</strong>，则用关系代词<strong>that</strong>引导<del>（全用that准没错 逃）</del></p><p><strong>For example</strong></p><blockquote><p>I really did not know angthing that happened to Jim yesterday.</p></blockquote><p>句子中的先行词为anything，所以要用that引导。</p><p>2pts X4</p><hr><h3 id="路程？时间！"><a href="#路程？时间！" class="headerlink" title="路程？时间！"></a>路程？时间！</h3><p><strong>车程不是时间，不是时间，不是时间</strong></p><p>好像只能怪我太菜了吧<br><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/02/13/k07mWj.jpg" alt="k07mWj.jpg"><br>还是把原题放出来吧</p><blockquote><p>How far is it from the New City to the Old City?<br>Less than 30 minutes ride by car.</p></blockquote><p>所以我太菜了啊</p><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>英语其实并不太难，只要努力一定可以提升的</p><p>加油吧,中考党们QvQ</p><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 文化课专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文化课专栏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文化课 GO</title>
      <link href="2019/02/12/wen-hua-ke-start/"/>
      <url>2019/02/12/wen-hua-ke-start/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>学好OI的基础是文化课<br>                  ——唐sir</p></blockquote><a id="more"></a><hr><h1 id="文化课-GO"><a href="#文化课-GO" class="headerlink" title="文化课 GO"></a>文化课 GO</h1><p>咳咳……</p><p>从今天开始，<em>Payphone-X</em>的文化课专栏要开始啦 <del>（虽然半个月前就该开始的个说）</del></p><p>从此，作者的 <em>Blog</em>将要加入一部分文化课知识</p><p>难度大概是<strong>初三复习中比较容易错的题目</strong>，<del>应该不会太难吧</del></p><p>喜欢颓文化课的中考党们看过来啊</p><p>当然了，也不要把本栏想的太过于正经了，很多毒瘤题目or题解也会一并刊登于文化课专栏中。</p><p>更新时间嘛……尽量做到一周一更吧（机房有唐，班里有宋，在家还不让碰电脑QAQ）</p><p>最后，祝大家文化课成绩像下面的代码一样<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> score;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    score ++;</span><br><span class="line">&#125;</span><br><span class="line">（没有<span class="keyword">return</span> <span class="number">0</span>哦）</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 文化课专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文化课专栏 </tag>
            
            <tag> 灌水区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HNOI2006】 鬼谷子的钱袋-题解</title>
      <link href="2019/01/27/HNOI2006/"/>
      <url>2019/01/27/HNOI2006/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>钱？钱是什么？我对钱不感兴趣。我就没碰过钱。<br>                                         ——马云</p></blockquote><a id="more"></a><h3 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h3><p>鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。</p><p>有一天，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。</p><p>但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。</p><p>于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。</p><p>鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。</p><p>假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？</p><hr><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>包含一个整数，表示鬼谷子现有的总的金币数目m。</p><hr><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>两行，第一行一个整数h，表示所用钱袋个数</p><p>第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开。</p><hr><h3 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h3><h5 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h5><blockquote><p>3</p></blockquote><h5 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h5><blockquote><p>2<br>1 2</p></blockquote><hr><h3 id="数据范围和约定："><a href="#数据范围和约定：" class="headerlink" title="数据范围和约定："></a>数据范围和约定：</h3><p>对于$100%$的数据，$1 \leq m \leq 1000000000$(ps.10的9次方)。</p><hr><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p><del>一道二分水题（逃）</del></p><p>可以脑补一下，如果m为40，我们需要表示哪些数呐？</p><p>是不是只用表示0 ~ 20就可以啦！</p><p>你看</p><p>40可以表示为20 + 10 + 9 + 1（当然还可以表示成别的……）</p><p>39可以表示为20 + 10 + 8 + 1</p><p>……</p><p>21可以表示为20 + 1</p><p>那……</p><p>如果要表示0 ~ 20，我们是不是只用表示0 ~ 10就可以啦！</p><p>同理 0 ~ 10可以用0 ~ 5表示 ; 0 ~ 5可以用0 ~ 3表示。</p><p>所以，<strong>n以内的数字可以用 1 到n / 2的数字表示 ，n / 2以内的数字又可以用到n / 4以内的数字表示……</strong></p><p>是不是很简单啊（逃）</p><hr><h3 id="附件（AC标程，防作弊已开启）"><a href="#附件（AC标程，防作弊已开启）" class="headerlink" title="附件（AC标程，防作弊已开启）"></a>附件（AC标程，防作弊已开启）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algirothm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000001</span>];</span><br><span class="line"><span class="keyword">int</span> m, h = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span>(m &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(m % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">m = m / <span class="number">2</span>;</span><br><span class="line">a[h] = m;</span><br><span class="line">h ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">a[h] = m / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">m = m / <span class="number">2</span>; </span><br><span class="line">h ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">h --</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; h &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">sort(a + <span class="number">1</span>, a + <span class="number">1</span> + h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 二分 </tag>
            
            <tag> 各省省选 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】线段树</title>
      <link href="2019/01/24/Tree/"/>
      <url>2019/01/24/Tree/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>高斯费马，树上开花</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在昨天(2019/1/23)晚上的数论 &amp; 图论爆炸后，作者开始接受线段树的洗礼……</p><hr><h2 id="初始约定："><a href="#初始约定：" class="headerlink" title="初始约定："></a>初始约定：</h2><p>在本文中，很多时候会出现[begin , end]</p><p>这表示一段数组上的区间：从begin 到 end</p><p>其中，begin为开头，end为结尾。</p><p>就像下图：</p><p><a href="https://imgse.com/i/5jEGTp"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/23/5jEGTp.png" alt="5jEGTp.png"></a></p><p>但值得一提的是，<strong>begin在这个区间内，但end不在</strong>。</p><hr><h2 id="何为线段树？"><a href="#何为线段树？" class="headerlink" title="何为线段树？"></a>何为线段树？</h2><p>老惯例，先看百度百科：</p><blockquote><p>线段树(Segment Tree)是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。<br>                                                                                      ——百度百科</p></blockquote><p>算了……</p><p>不看了……</p><p>还是看下通俗点的解释吧。</p><p>线段树就是一种有点特殊的二叉树<del>（废话）</del>。</p><p>说它特殊，是因为他的每一个结点不只代表一个数，而是代表一段区间。</p><p>就像下图：</p><p><a href="https://imgchr.com/i/kZgrhd"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/24/kZgrhd.png" alt="kZgrhd.png"></a></p><p>在上图中，树上的根节点代表整个序列之和（ps. [0 , 12]）</p><p>树上每一个结点下面的[begin , end]代表下面的黄色点中相应区间的和。</p><p>每一层向下分裂时，都把本层的区间拆为两部分，直到拆到不能再拆为止，不能再拆的部分就成了树的叶子结点，叶子结点代表单个元素。</p><p>（ps.这就是为什么树上的叶子结点与下面的黄色点一一对应。）</p><p>同样，线段树的每一颗子树也是一颗线段树。</p><hr><h2 id="线段树的建立"><a href="#线段树的建立" class="headerlink" title="线段树的建立"></a>线段树的建立</h2><p>在使用线段树之前，我们需要先种一颗线段树。</p><p>但……</p><p>我们如何把像下图一样的数列搬到树上呐？</p><p><a href="https://imgchr.com/i/eLADCd"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/10/eLADCd.jpg" alt="eLADCd.jpg"></a></p><p>很简单</p><p>首先我们需要一个结构体，来表示线段树的每一个节点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> add_tag;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，$num$代表的是节点的值，而$tag$指的是该节点的标记。</p><p>标记的类型有很多种，比如add_tag , mul_tag，每种标记都有不同的作用。</p><p>现在仔细观察一下，我们可以很容易的发现<strong>最底层的叶子节点的值就是原数列上的值，而叶子节点的$begin = end$。</strong></p><p>所以我们可以直接修改叶子节点啊！</p><p>就像下图：</p><p><a href="https://imgchr.com/i/eLA5Cj"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/10/eLA5Cj.jpg" alt="eLA5Cj.jpg"></a></p><p>之后我们进行同样的操作，建立$4$节点的另外一颗子树，而$4$号节点就是这两颗子树的和</p><p>就像这样：</p><p><a href="https://imgchr.com/i/eLEpx1"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/10/eLEpx1.jpg" alt="eLEpx1.jpg"></a></p><p>继续循环建立子树，直到种好一整颗线段树为止</p><p><a href="https://imgchr.com/i/eLEBZT"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/08/10/eLEBZT.jpg" alt="eLEBZT.jpg"></a></p><p>这样，我们就建好了一整颗线段树啦OvO</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lson</span><span class="params">(x)</span></span>&#123;     <span class="comment">//快速求左子节点</span></span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rson</span><span class="params">(x)</span></span>&#123;     <span class="comment">//快速求右子节点</span></span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">2</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;     <span class="comment">//父节点的值等于两个子节点的和</span></span><br><span class="line">    node[x].num = node[lson(x)].num + node[rson(x)].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        node[x].nun = a[l]  <span class="comment">//a为原数组</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson(x) , l ,  mid);</span><br><span class="line">    build(rson(x) , mid + <span class="number">1</span> , r);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="线段树的基本操作："><a href="#线段树的基本操作：" class="headerlink" title="线段树的基本操作："></a>线段树的基本操作：</h2><p>跟其他数据结构一样，线段树也有它的基本操作。下面，我们就来看看。</p><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>在前面我们已经说过，线段树的每一个节点代表的不仅仅是一个数，而是一段区间</p><p>那么……</p><p>我们如何去查找一段区间的和呐？</p><p>或者说……</p><p>我们是不是<strong>不用遍历区间内的每一个叶子节点</strong>就能查找到区间之和呐？</p><p>答案是肯定的。</p><p>因为线段树中一个节点代表的是一段区间</p><p>因此……</p><p>如果两个节点都包含在所要搜索的区间之内，仅仅<strong>搜到它们的父节点</strong>即可得出答案。</p><p>之后把所有搜到的节点的值相加，即可得出答案</p><p>可以证明，拆分出区间的数量为$O(log n)$</p><p>来看这个图：</p><p><a href="https://imgchr.com/i/kZgrhd"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/24/kZgrhd.png" alt="kZgrhd.png"></a></p><p>下面我们要查找[1 , 6]的区间范围和</p><p>首先，我们从根节点开始遍历，在遍历[1 , 1]时，需要遍历到叶子结点。</p><p><a href="https://imgchr.com/i/keXl8I"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/25/keXl8I.png" alt="keXl8I.png"></a></p><p>但之后在遍历[2 , 3]时，就没那么麻烦了，直接到父节点遍历即可</p><p><a href="https://imgchr.com/i/keX4R1"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/25/keX4R1.png" alt="keX4R1.png"></a></p><p>[4 , 6]更加快捷，直接遍历到第三层即可</p><p><a href="https://imgchr.com/i/kmpys1"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/25/kmpys1.png" alt="kmpys1.png"></a></p><p>之后把每一次的结果加起来，就是最后的结果了。</p><p><strong>最后提醒一句，查询之前一定要下放标记，即pushdown。</strong>下放的解释见代码注释</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  pushdown为标记下放函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node[x].add_tag)&#123;   <span class="comment">//没有标记就直接return </span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">//求出左右子树分界，即中间点。</span></span><br><span class="line">    node[lson(x)].add_tag += node[x].add_tag;   <span class="comment">//为左子节点下放标记</span></span><br><span class="line">    node[lson(x)].num += node[x].add_tag * (mid - l + <span class="number">1</span>);   <span class="comment">//更改左子节点的值</span></span><br><span class="line">    node[rson(x)].add_tag += node[x].add_tag;   <span class="comment">//同上</span></span><br><span class="line">    node[rson(x)].num += node[x].add_tag * (r - mid); </span><br><span class="line">    node[x].add_tag = <span class="number">0</span>     <span class="comment">//不要忘记清空标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> range_query(<span class="keyword">int</span> x, <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)&#123;     <span class="comment">//如果要查询的区间已经包含这个节点，直接return </span></span><br><span class="line">        <span class="keyword">return</span> node[x].num; </span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(x , l , r);     <span class="comment">//否则，下放标记</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">//左右子树分界</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid)&#123;          <span class="comment">//如果需要查询的区间在左子树中</span></span><br><span class="line">        ans += range_query(lson(x) , l , mid , ql , qr);</span><br><span class="line">        <span class="comment">//就在左子树中进行查询</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(qr &gt;= mid + <span class="number">1</span>)&#123;      <span class="comment">//如果需要查询的区间在右子树中</span></span><br><span class="line">        ans += range_query(rson(x) , mid + <span class="number">1</span> , r , ql , qr);</span><br><span class="line">        <span class="comment">//就在右子树中进行查询</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><del>是不是很简单啊（逃）</del></p><hr><h3 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h3><p>线段树每个节点表示的是一段区间，因此，像普通二叉树那样直接修改节点是不行的。</p><p>但是……</p><p>线段树的每一个叶子节点仅代表了一个数啊QvQ</p><p>所以，我们可以<strong>从最简单的叶子节点入手</strong>，修改后更新它的每一个父节点，再继续更新父节点的父节点，再继续更新他的父节点的父节点的父节点 …… 直到更新到根节点为止。</p><p>每一次修改，更新的节点数最多为树高。</p><p>很显然，时间复杂度为$O(log n)$</p><p>来看这个图：</p><p><a href="https://imgchr.com/i/kZgrhd"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/24/kZgrhd.png" alt="kZgrhd.png"></a></p><p>现在我们来把[3 , 3]的值改成5。</p><p>首先， 我们先遍历到[3 , 3]，并把它改为5</p><p><a href="https://imgchr.com/i/km8RTf"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/25/km8RTf.png" alt="km8RTf.png"></a></p><p>之后回溯，到它的父节点[2 , 3]，并把父节点的值改为71</p><p><a href="https://imgchr.com/i/km820P"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/25/km820P.png" alt="km820P.png"></a></p><p>继续回溯，直到改完根节点为止。下面是成品图：</p><p><a href="https://imgchr.com/i/km8gmt"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/25/km8gmt.png" alt="km8gmt.png"></a></p><p>代码的话<del>……就先不写了</del>。</p><p>直接把下面区间修改的代码搬来用吧。</p><p><del>好像也不难吧（逃 X2）</del></p><hr><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><p>现在，我们已经知道如何修改线段树中单个叶子节点的值了</p><p>那……</p><p>如果给你一个<em>begin</em>和一个<em>end</em>，要求将[begin , end]中的每个元素都+2，你怎样修改这整个区间的值呐？（ps.一个个修改会TLE哦）</p><p>其实……</p><p>我们可以<strong>把要修改的区间拆分成少量的节点，把修改的数直接修改在这些节点上</strong>就可以了。</p><p>就像下图：</p><p><a href="https://imgchr.com/i/kZgrhd"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/24/kZgrhd.png" alt="kZgrhd.png"></a></p><p>现在，我们把区间[0 , 5]的值全部改为 1</p><p>首先，在第二层，我们把代表[0 , 3]区间的点变成 1</p><p><a href="https://imgchr.com/i/kmtzUx"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/25/kmtzUx.png" alt="kmtzUx.png"></a></p><p>之后，在第三层，我们把代表[4 , 5]区间的点变成 1</p><p><a href="https://imgchr.com/i/kmtXr9"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/25/kmtXr9.png" alt="kmtXr9.png"></a></p><p>最后我们向上回溯，更新上面的节点，直到回溯至根节点。</p><p><a href="https://imgchr.com/i/kmtxV1"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/25/kmtxV1.png" alt="kmtxV1.png"></a></p><p>这样，我们就完成了对线段树区间的修改。</p><p><strong>同样，在修改时也一定不要忘了下放与上传标记，即pushdown</strong></p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//区间加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_add</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr , <span class="keyword">long</span> <span class="keyword">long</span> add)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= ql)&#123;     <span class="comment">//如果查询区间直接包含该节点</span></span><br><span class="line">        node[x].add_tag += add; <span class="comment">//直接叠加标记</span></span><br><span class="line">        node[x].num = add * (r - l + <span class="number">1</span>);    <span class="comment">//加上值</span></span><br><span class="line">        <span class="keyword">return</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(x , l , r);    <span class="comment">//否则，下放标记</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">//求出左右子树的分界</span></span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid)&#123;          <span class="comment">//如果需要加的区间在左子树中</span></span><br><span class="line">        range_add(lson(x) , l , mid , ql , qr , add);   <span class="comment">//就加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(qr &gt;= mid + <span class="number">1</span>)&#123;<span class="comment">//同上</span></span><br><span class="line">        range_add(rson(x) , mid + <span class="number">1</span> , r , ql , qr , add);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(x);<span class="comment">//上传标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><del>应该不算多难吧(逃 X3)</del></p><hr><h2 id="附件-Segment-Tree"><a href="#附件-Segment-Tree" class="headerlink" title="附件[Segment Tree]"></a>附件[Segment Tree]</h2><h3 id="线段树-1"><a href="#线段树-1" class="headerlink" title="线段树 1"></a>线段树 1</h3><p>代码描述：见<a href="https://www.luogu.org/problem/P3372">LuoguP3372</a></p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I_int inline int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Segtree&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll num;</span><br><span class="line">ll add_tag;</span><br><span class="line">&#125;node[(N &lt;&lt; <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">I_int <span class="title">lson</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">I_int <span class="title">rson</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">node[x].num = node[lson(x)].num + node[rson(x)].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!node[x].add_tag)&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">node[lson(x)].add_tag += node[x].add_tag;</span><br><span class="line">node[rson(x)].add_tag += node[x].add_tag;</span><br><span class="line">node[lson(x)].num += node[x].add_tag * (mid - l + <span class="number">1</span>);</span><br><span class="line">node[rson(x)].num += node[x].add_tag * (r - mid);</span><br><span class="line">node[x].add_tag = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">node[x].num = a[r];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(lson(x) , l ,  mid);</span><br><span class="line">build(rson(x) , mid + <span class="number">1</span> , r);</span><br><span class="line">pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_add</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr , ll v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)&#123;</span><br><span class="line">node[x].add_tag += v;</span><br><span class="line">node[x].num += v * (r - l + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(x , l , r);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">range_add(lson(x) , l , mid , ql , qr , v);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(qr &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">range_add(rson(x) , mid + <span class="number">1</span>  , r , ql , qr , v);</span><br><span class="line">&#125;</span><br><span class="line">pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">range_query</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)&#123;</span><br><span class="line"><span class="keyword">return</span> node[x].num;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(x , l , r);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">ans += range_query(lson(x) , l , mid , ql , qr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(qr &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">ans += range_query(rson(x) , mid + <span class="number">1</span> , r , ql , qr);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Segtree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line">ll x , y , k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">build(<span class="number">1</span> , <span class="number">1</span> , n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; opt;</span><br><span class="line"><span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">range_add(<span class="number">1</span> , <span class="number">1</span> , n , x , y , k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; range_query(<span class="number">1</span> , <span class="number">1</span> , n , x , y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线段树-2"><a href="#线段树-2" class="headerlink" title="线段树 2"></a>线段树 2</h3><p>代码描述：见<a href="https://www.luogu.org/problem/P3373">LuoguP3373</a></p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I_int inline int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , p;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Segtree&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        ll num;</span><br><span class="line">        ll add_tag;</span><br><span class="line">        ll mul_tag;</span><br><span class="line">    &#125;node[(N &lt;&lt; <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lson</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rson</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        node[x].num = node[lson(x)].num + node[rson(x)].num;</span><br><span class="line">        node[x].num %= p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(node[x].mul_tag != <span class="number">1</span>)&#123;</span><br><span class="line">            node[lson(x)].mul_tag *= node[x].mul_tag;</span><br><span class="line">            node[lson(x)].mul_tag %= p;</span><br><span class="line">            node[lson(x)].add_tag *= node[x].mul_tag;</span><br><span class="line">            node[lson(x)].add_tag %= p;</span><br><span class="line">            node[lson(x)].num *= node[x].mul_tag;</span><br><span class="line">            node[lson(x)].num %= p;</span><br><span class="line"></span><br><span class="line">            node[rson(x)].mul_tag *= node[x].mul_tag;</span><br><span class="line">            node[rson(x)].mul_tag %= p;</span><br><span class="line">            node[rson(x)].add_tag *= node[x].mul_tag;</span><br><span class="line">            node[rson(x)].add_tag %= p;</span><br><span class="line">            node[rson(x)].num *= node[x].mul_tag;</span><br><span class="line">            node[rson(x)].num %= p;</span><br><span class="line">            node[x].mul_tag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node[x].add_tag)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            node[lson(x)].add_tag += node[x].add_tag;</span><br><span class="line">            node[lson(x)].add_tag %= p;</span><br><span class="line">            node[lson(x)].num += node[x].add_tag * (mid - l + <span class="number">1</span>);</span><br><span class="line">            node[lson(x)].num %= p;</span><br><span class="line"></span><br><span class="line">            node[rson(x)].add_tag += node[x].add_tag;</span><br><span class="line">            node[rson(x)].add_tag %= p;</span><br><span class="line">            node[rson(x)].num += node[x].add_tag * (r - mid);  </span><br><span class="line">            node[rson(x)].num %= p;  </span><br><span class="line">            node[x].add_tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        node[x].mul_tag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            node[x].num = a[r];</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(lson(x) , l , mid);</span><br><span class="line">        build(rson(x) , mid + <span class="number">1</span> , r);</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">range_add</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr , ll v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)&#123;</span><br><span class="line">            node[x].add_tag += v;</span><br><span class="line">            node[x].add_tag %= p;</span><br><span class="line">            node[x].num += v * (r - l + <span class="number">1</span>);</span><br><span class="line">            node[x].num %= p;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(x , l , r);</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">            range_add(lson(x) , l , mid , ql , qr , v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(qr &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">            range_add(rson(x) , mid + <span class="number">1</span> , r , ql , qr , v);</span><br><span class="line">        &#125;</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">range_mul</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> ql , <span class="keyword">int</span> qr , ll v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)&#123;</span><br><span class="line">            node[x].mul_tag *= v;</span><br><span class="line">            node[x].mul_tag %= p;</span><br><span class="line">            node[x].add_tag *= v;</span><br><span class="line">            node[x].add_tag %= p;</span><br><span class="line">            node[x].num *= v;</span><br><span class="line">            node[x].num %= p;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(x , l , r);</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">            range_mul(lson(x) , l , mid , ql , qr , v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(qr &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">            range_mul(rson(x) , mid + <span class="number">1</span> , r , ql , qr , v);</span><br><span class="line">        &#125;</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">range_query</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> ql ,  <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line">            <span class="keyword">return</span> node[x].num % p;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(x , l , r);</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">            ans += range_query(lson(x) , l  , mid , ql , qr);</span><br><span class="line">            ans %= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(qr &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">            ans += range_query(rson(x) , mid + <span class="number">1</span> , r , ql , qr);</span><br><span class="line">            ans %= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Segtree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    ll x , y , k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span> , <span class="number">1</span> , n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; opt;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            range_mul(<span class="number">1</span> , <span class="number">1</span> , n , x , y , k % p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            range_add(<span class="number">1</span> , <span class="number">1</span> , n , x , y , k % p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; range_query(<span class="number">1</span> , <span class="number">1</span> , n , x , y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://oi.men.ci">Menci’s Blog &amp; 课件</a></li></ol><p>鸣谢Menci在线段树学习中给予我的帮助OvO</p><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STL】常用STL（NOIP提高组）</title>
      <link href="2019/01/23/STL/"/>
      <url>2019/01/23/STL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>把STL放在心底，永远都有惊喜<br>                      ——《Tonight Forever》</p></blockquote><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>或许你会问我为什么要再写一篇STL，因为之前的STL转载自<em>Herself32’s Blog</em>，并非作者亲笔所写，所以作者在自己学完STL后自己又写了一篇。</p><p>鸣谢 <a href="http://oi.men.ci">Menci</a> &amp; <a href="https://herself32.github.io">Herself32</a>在STL学习中给我的帮助。</p><hr><h3 id="初始约定"><a href="#初始约定" class="headerlink" title="初始约定"></a>初始约定</h3><p>在STL中，很多时候会出现(begin , end)</p><p>这表示一段数组上的区间：从begin 到 end</p><p>其中，begin为开头，end为结尾。</p><p>就像下图：</p><p><a href="https://imgse.com/i/5jEGTp"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/23/5jEGTp.png" alt="5jEGTp.png"></a></p><p>但值得一提的是，<strong>begin在这个区间内，但end不在</strong>。</p><hr><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>在讲迭代器之前，我们先看看百度百科对于迭代器的解释：</p><blockquote><p>迭代器（iterator）有时又称游标（cursor）是程序设计的软件设计模式，可在容器（container，例如链表或阵列）上遍访的接口，设计人员无需关心容器的内容。<br>                                                                              ——百度百科</p></blockquote><p>emm……</p><p>这是什么鬼玩意……</p><p>不看了……</p><p>其实，迭代器就是一个用来指示容器中元素位置的数据，就像数组的下标，可以指示某一个元素在数组中的位置。</p><p>迭代器分为5种，分别是：</p><blockquote><ul><li>输入迭代器（<em>ps.</em>可以拿来读取）</li><li>输出迭代器（<em>ps.</em>可以拿来写入）</li><li>前向迭代器（<em>ps.</em>可以拿来读取与写入，同时还可以向前移动，但一次只能移动一个位置）</li><li>双向迭代器（<em>ps.</em>可以拿来读取与写入，同时还可以向前后两个方向移动，但一次只能移动一个位置）</li><li>随机访问迭代器（<em>ps.</em>可以拿来读取与写入，同时还可以向前后两个方向移动，一次可移动多个位置）</li></ul></blockquote><p>其中，我们数组的下标就是一个随机访问迭代器，所有的指针也都是随机访问迭代器。</p><hr><h3 id="Algorithm库"><a href="#Algorithm库" class="headerlink" title="Algorithm库"></a>Algorithm库</h3><p>依稀记得</p><p>在$NOIP2018$前一秒</p><p>我还没背下来这个头文件</p><p>但这个头文件里真的有许多好用的模板。</p><p>下面就来看看吧</p><h4 id="MAX-amp-MIN"><a href="#MAX-amp-MIN" class="headerlink" title="MAX &amp; MIN"></a>MAX &amp; MIN</h4><p>求两个数里较大值与较小值的函数</p><p>包含在algorithm库中(ps.有的编译器下iostream库中也可以)</p><p>可以返回两个值的较大值或较小值。</p><p>模板如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">max(a , b);</span><br><span class="line">min(a , b);</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(1)$</p><hr><h4 id="MAX-element-amp-MIN-element"><a href="#MAX-element-amp-MIN-element" class="headerlink" title="MAX_element &amp; MIN_element"></a>MAX_element &amp; MIN_element</h4><p>这两个函数可以求一个区间内的最大值与最小值</p><p>相当于上面两个函数的升级版</p><p>同样，包含在algorithm库中。</p><p>模板如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">max_element(begin , end);</span><br><span class="line">min_element(begin , end);</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(n)$</p><hr><h4 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h4><p>这个函数用于交换两个变量的值</p><p>模板如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">swap(a , b);</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(1)$</p><hr><h4 id="Fill"><a href="#Fill" class="headerlink" title="Fill"></a>Fill</h4><p>这个函数用于向一个区间内填充指定的值</p><p>模板如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">fill(begin , end , value);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，value为填充的值。</p><p>时间复杂度为$O(n)$</p><p><strong>补充：</strong></p><p>或许你觉得memset(数组名 ， 0 ， sizeof(数组名))有同样的效果，</p><p>但是</p><p>它们的本质是不一样的。</p><p>fill函数是把数组中的每一个元素填充为指定的数值，</p><p>而memset是逐字节填充。</p><p>因此</p><p>memset在填充较大的数值时很容易出锅……</p><p>而fill不会。</p><p>（ps.整段翻译成人话就是大部分情况下用fill就好啦 QvQ）</p><hr><h4 id="Random-shuffle"><a href="#Random-shuffle" class="headerlink" title="Random_shuffle"></a>Random_shuffle</h4><p>这个函数可以把一个给定区间的值全部随机排列。</p><p><del>可以拿来写猴排</del></p><p><del>也可以#define sort random_suffle</del></p><p>咳咳</p><p>下面是模板：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">random_shuffle(begin , end);</span><br></pre></td></tr></table></figure><br>时间复杂度为$O(n)$</p><hr><h4 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h4><p>在STL里最常用的函数应该就是它了</p><p>它可以把一段区间内的元素进行升序排序</p><p>如果是不稳定排序，他会用类似于<strong>快速排序</strong>的方法实现</p><p>稳定排序则是使用<strong>归并排序</strong>实现</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">sort(begin , end);</span><br></pre></td></tr></table></figure><p>时间复杂度保证为$O(n log n)$</p><p>比手写排序快多啦QvQ</p><p><strong>补充：</strong></p><p>不知道你看到了吗</p><p>sort是进行升序排序</p><p>那么</p><p>降序排序怎么办呢？</p><p><del>直接反着调用不就行了……</del></p><hr><h4 id="Unique"><a href="#Unique" class="headerlink" title="Unique"></a>Unique</h4><p>这个函数可以把一个升序排序后的区间里重复的元素去除</p><p>使用前一定<strong>别忘了排序</strong></p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">unique(begin , end);</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(n)$</p><hr><h4 id="Next-permutation"><a href="#Next-permutation" class="headerlink" title="Next_permutation"></a>Next_permutation</h4><p>全排列函数</p><p>就是可以输出一个区间范围内所有元素的所有排列方法。</p><p>比如说</p><p>1 ，2 ，3 ，4的全排列如下图</p><p><a href="https://imgchr.com/i/kZFptO"><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/01/24/kZFptO.png" alt="kZFptO.png"></a></p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(next_permutation(a, a + <span class="number">4</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>时间复杂度为$O(n!)$</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> STL </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LYOI】LogeYOI Winter Day1 -T1题解</title>
      <link href="2019/01/23/LogeyOIDay1T1/"/>
      <url>2019/01/23/LogeyOIDay1T1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ios::sync_with_stdio(false); ? ? ?<br>快读板子？？？<br>无效？？？</p><a id="more"></a><h3 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h3><p>大佬 LogeY 被丢到了一棵神奇的树上。为什么神奇呢，因为这棵树的每个节点都只有两个子节点！</p><p>LogeY 太强了，他想做题，但是题在这个树的根节点上，所以他需要一步一步向上走。然而，这棵树上的一些节点上放置有基佬，如果 LogeY 走到有基佬的节点上，LogeY 就会被 Gay。</p><p>LogeY 总共被丢到了树上 <em>N</em> 次，问每次他走到根节点的途中会不会被 Gay？</p><hr><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行两个整数 <em>N</em>、<em>M</em> 表示树的节点数量和有基佬的节点数量。</p><p>之后的 <em>N</em> 行每行一个整数 $a_i$，表示有基佬的点。</p><p>之后一行一个整数 <em>q</em>，表示 LogeY 被丢到了树上 <em>M</em> 次；</p><p>之后的 <em>q</em> 行，每行一个整数 $b_i$</p><p>表示 LogeY 这一次被丢到了 $b_i$号点</p><hr><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出 <em>q</em> 行，每行一个字符串，如果这次 LogeY 走到根节点的过程中至少被 Gay 了一次，则输出 LoGAY!，否则输出 srO lgy Orz。</p><hr><h3 id="Input-amp-Output-‘s-examples"><a href="#Input-amp-Output-‘s-examples" class="headerlink" title="Input &amp; Output ‘s examples"></a>Input &amp; Output ‘s examples</h3><h5 id="Input-‘s-eg"><a href="#Input-‘s-eg" class="headerlink" title="Input ‘s eg"></a>Input ‘s eg</h5><blockquote><p>7 2<br>2<br>3<br>6<br>2<br>3<br>4<br>5<br>6<br>7</p></blockquote><h5 id="Output-‘s-eg"><a href="#Output-‘s-eg" class="headerlink" title="Output ‘s eg"></a>Output ‘s eg</h5><blockquote><p>LoGAY!<br>LoGAY!<br>LoGAY!<br>LoGAY!<br>LoGAY!<br>LoGAY!</p></blockquote><h3 id="数据范围与约定："><a href="#数据范围与约定：" class="headerlink" title="数据范围与约定："></a>数据范围与约定：</h3><p>对于 10% 的数据，$q=0 $<br>对于另外 10% 的数据，$m=0 $<br>对于另外 10% 的数据，$m = n - 1 $<br>对于 30% 的数据，$n \leq 100 $<br>对于 60% 的数据，$n \leq 100000$<br>对于 100%的数据，$1 \leq n \leq 2000000, 0 \leq m \leq n - 1, 0 \leq q \leq n - 1, 2 \leq u_i, v_i \leq n$<br>树上节点的编号，对于 <em>u</em> 号节点，它的两个子节点（如果存在）编号分别为 <em>2u</em> 和 <em>2u+1</em>；<br>保证每个点上最多只有一个 <em>Gay</em>。</p><h3 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h3><p>这题对于可爱的Logey可能真的不太友好……（逃）</p><p>当我第一眼看到这题时，我感叹道<del>Logey在样例中被<em>Gay</em>了6次</del>这不是一道简单的二叉树嘛。</p><p>事实上，它就是一颗简单的二叉树。</p><p>我们可以定义一个bool数组tree[]表示这个结点上有没有<em>Gay</em></p><p>再写一个循环来模拟Logey在树上走的过程，如果logey此刻所在节点上面有<em>Gay</em>，就退出循环并输出。没有则继续。</p><p>然后我就写出了以下代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> name;</span><br><span class="line"><span class="keyword">bool</span> jilao;</span><br><span class="line">&#125;a[<span class="number">2000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">&quot;tree.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">&quot;tree.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">a[<span class="number">1</span>].name = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>].jilao = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">a[i].name = i;</span><br><span class="line">a[i].jilao = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i].name;</span><br><span class="line">a[a[i].name].jilao = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">bool</span> bj = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(a[c].jilao == <span class="literal">true</span> || a[c / <span class="number">2</span>].jilao == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;LoGAY!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">while</span>(c / <span class="number">2</span> &gt; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[c].jilao == <span class="literal">true</span> || a[c / <span class="number">2</span>].jilao == <span class="literal">true</span>)&#123;</span><br><span class="line">bj = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line"> c = c / <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bj == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;LoGAY!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;srO lgy Orz&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>);</span><br><span class="line">fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>嗯，貌似没毛病。</p><p>可是……</p><p><a href="https://imgse.com/i/5jrGrB"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/23/5jrGrB.png" alt="5jrGrB.png"></a></p><p><a href="https://imgse.com/i/5jrbmp"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/23/5jrbmp.jpg" alt="5jrbmp.jpg"></a></p><p>怎么回事？？？</p><p>终于，在和<em>Herself32</em>折腾了将近两个小时后，我发现<strong>TMD我忘了初始化变量了</strong></p><p>于是又有了下面的代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, d;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">bool</span> jilao;</span><br><span class="line">&#125;a[<span class="number">2000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">&quot;tree.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">&quot;tree.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">a[d].jilao = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line"><span class="keyword">bool</span> bj = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(a[c].jilao == <span class="literal">true</span> || a[c / <span class="number">2</span>].jilao == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;LoGAY!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">while</span>(c != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[c].jilao == <span class="literal">true</span> || a[c / <span class="number">2</span>].jilao == <span class="literal">true</span>)&#123;</span><br><span class="line">bj = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line"> c = c / <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bj == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;LoGAY!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;srO lgy Orz&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>);</span><br><span class="line">fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>嗯，这下应该没毛病了。</p><p>可是……</p><p><a href="https://imgse.com/i/5jrZKE"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/23/5jrZKE.png" alt="5jrZKE.png"></a></p><p><a href="https://imgse.com/i/5jrrmS"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/23/5jrrmS.png" alt="5jrrmS.png"></a></p><p><a href="https://imgse.com/i/5jraxz"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/23/5jraxz.png" alt="5jraxz.png"></a></p><p><del>心中一万句MMP</del></p><p>最后把cin &amp; cout 全部改成 scanf &amp; printf就过了。</p><p><del>（ps.在此之前作者加了各种优化，甚至用了快读板子，都没过QAQ）</del></p><hr><h3 id="附件（AC标程，反作弊已开启）"><a href="#附件（AC标程，反作弊已开启）" class="headerlink" title="附件（AC标程，反作弊已开启）"></a>附件（AC标程，反作弊已开启）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q,d,c;</span><br><span class="line"><span class="keyword">bool</span> a[<span class="number">2000001</span>];<span class="comment">//a[]为树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;tree.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;tree.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d)；</span><br><span class="line">a[d] = <span class="literal">true</span>; <span class="comment">//标记有GAY的结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line"><span class="keyword">bool</span> bj = <span class="literal">false</span>；</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c)；</span><br><span class="line"><span class="comment">/*if(a[c].jilao == true || a[c / 2].jilao == true)&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;LoGAY!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">continue;</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br><span class="line">    <span class="keyword">while</span>(c != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[c] == <span class="literal">true</span> || a[c / <span class="number">2</span>] == <span class="literal">true</span>)&#123;</span><br><span class="line">bj = <span class="literal">true</span>; <span class="comment">//如果有，标记为真并退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line"> c = c / <span class="number">2</span>; <span class="comment">//没有就继续向上搜索</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, bj ? <span class="string">&quot;LoGAY!&quot;</span> : <span class="string">&quot;srO lgy Orz&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fclose(stdin);</span></span><br><span class="line"><span class="comment">//fclose(stdout);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> LYOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】优先队列(堆)</title>
      <link href="2019/01/22/Heap/"/>
      <url>2019/01/22/Heap/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>堆？怼？</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大前天（2019/1/19）作者回到机房，发现自己咕咕咕半个月后被学长嘲讽了，于是去找<em>Herself32</em>学堆……</p><hr><h3 id="初始约定"><a href="#初始约定" class="headerlink" title="初始约定"></a>初始约定</h3><p>在下文堆的STL实现中，很多时候会出现(begin , end)</p><p>这表示一段数组上的区间：从begin 到 end</p><p>其中，begin为开头，end为结尾。</p><p>就像下图：</p><p><a href="https://imgse.com/i/5jEGTp"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/23/5jEGTp.png" alt="5jEGTp.png"></a></p><p>但值得一提的是，<strong>begin在这个区间内，但end不在</strong>。</p><hr><h3 id="何为堆？"><a href="#何为堆？" class="headerlink" title="何为堆？"></a>何为堆？</h3><blockquote><p>堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。<br>                                                                                    ——百度百科</p></blockquote><p>……</p><p>度娘越来越坏了，只会装高冷。还是看看通俗易懂的解释吧。</p><p>事实上，堆就是一颗完全二叉树，但它还要满足一个条件：</p><blockquote><ul><li>堆中的每个节点不论怎么调整，都不小于(或不大于)它的父节点。</li></ul></blockquote><p>根据这个条件，我们就可以把堆分成两种：<strong>大根堆</strong>和<strong>小根堆</strong>。</p><p>就像下图，就是两个典型的小根堆和大根堆：</p><p>小根堆：<br><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/22/5jZPT9.jpg" alt="5jZPT9.jpg"></p><p>大根堆：<br><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/22/5jZvSu.jpg" alt="5jZvSu.jpg"></p><p>怎么样，是不是很懵逼？</p><p>那是因为我忘了告诉你小根堆和大根堆的定义了。</p><p>我们将<strong>根节点最大的堆</strong>叫做<strong>大根堆</strong>， <strong>将根节点最小的堆</strong>叫做<strong>小根堆</strong>。</p><p>但要注意：<strong>必须是每一颗子树都要满足条件</strong>，即每一颗子树的每一个节点都要比它的父节点大（或小）。</p><p>这是按根节点的大小来分，如果按操作种类来分，那么常见的堆有二叉堆、斐波那契堆等。</p><hr><h3 id="如何存储一个堆？"><a href="#如何存储一个堆？" class="headerlink" title="如何存储一个堆？"></a>如何存储一个堆？</h3><p>看到这，你可能要问了：“既然这样，怎么存储一个堆呐？”</p><p>别急，慢慢看就知道了。</p><p>我们知道，堆是一种线性的数据结构，有唯一的后继。</p><p>所以</p><p><strong>开一维数组模拟啊</strong></p><p>学过完全二叉树的同学都知道这样一句话：在完全二叉树中，一个节点的编号为x，则它的左儿子编号为2x， 右儿子编号为2x + 1。</p><p>在前面我已经说过，堆也是一颗完全二叉树。</p><p>因此，堆也满足这个性质。</p><p>如果我们定义一个名为<em>Heap[]</em>的数组表示堆，那么</p><blockquote><ul><li><p>$Heap[x]  \leq Heap[2x] \&amp; Heap[2x + 1]  $(小根堆)。 </p></li><li><p>$Heap[x]  \geq Heap[2x] \&amp; Heap[2x + 1]  $(大根堆)。</p></li></ul></blockquote><p>同时，我们还可以看出，堆顶元素一定是最大（或最小）元素。</p><hr><h3 id="堆的操作。"><a href="#堆的操作。" class="headerlink" title="堆的操作。"></a>堆的操作。</h3><p>现在你可能要问：“这么麻烦的堆，有什么用吗？”</p><p><del>当然是拿来怼人啦</del></p><p>咳咳，一个堆支持以下4种操作：</p><blockquote><ul><li><p>插入一个节点</p></li><li><p>删除堆顶元素</p></li><li><p>输出堆顶元素</p></li><li><p>堆排序</p></li></ul></blockquote><p>在讲这4种操作之前，我们先来看看堆的两种基本操作：<em>Shiftup</em> &amp; <em>Shiftdown</em>。<br>（ps.所有的操作都基于这两种基本操作）</p><h4 id="Shiftup（ps-大根堆）"><a href="#Shiftup（ps-大根堆）" class="headerlink" title="Shiftup（ps.大根堆）"></a>Shiftup（ps.大根堆）</h4><p>众所周知，大根堆中的每一个父节点都大于它的任意子节点</p><p>因此，我们在插入一个节点后需要把它与它的父节点比较</p><p>如果它比它的父节点大，则交换，继续比较。</p><p>否则，则退出循环。</p><p><del>刚不过就认怂呗</del></p><p>来看这个图：<br><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/22/5jh3Oa.jpg" alt="5jh3Oa.jpg"></p><p>此时，我们在树的最后插入一个元素36（ps.插入元素时要在树的最后插入）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/22/5jZnJE.jpg" alt="5jZnJE.jpg"></p><p>现在开始Shiftup, 此时36与他的父节点19比较，发现自己比他大，进行交换。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/22/5jZoIQ.jpg" alt="5jZoIQ.jpg"></p><p>交换后的36与它的父节点26比较，发现自己比他大，进行交换。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/22/5jZw52.jpg" alt="5jZw52.jpg"></p><p>最后36与90比较，发现比不过了，于是认怂，break掉循环，结束。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/22/5jh5Uz.jpg" alt="5jh5Uz.jpg"></p><p><strong>伪代码如下</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shiftup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;            <span class="comment">//x为节点下标</span></span><br><span class="line">    <span class="keyword">while</span>（x不是根节点）&#123;</span><br><span class="line">        <span class="keyword">if</span>（Heap[x] 大于它的父节点）&#123;</span><br><span class="line">            将Heap[x]与它的父节点交换;</span><br><span class="line">            x = x / <span class="number">2</span>;          <span class="comment">//父节点的下标为子节点下标除以2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Shiftdown-ps-大根堆"><a href="#Shiftdown-ps-大根堆" class="headerlink" title="Shiftdown (ps.大根堆)"></a>Shiftdown (ps.大根堆)</h4><p>同理，有上浮就会有下沉。可以把<em>Shiftdown</em>看成<em>Shiftup</em>的反过程。</p><p>唯一不同在于，<em>Shiftdown</em>有两个比较对象，分别是他的左儿子和右儿子。</p><p>在交换之前，需要先找到它的左儿子和右儿子中较大的那一个。</p><p>来看这个图：</p><p><a href="https://imgse.com/i/5jPFcp"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/22/5jPFcp.jpg" alt="5jPFcp.jpg"></a></p><p>此时，我们删除堆顶的90，成了下面这个样子：</p><p><a href="https://imgse.com/i/5jPJbA"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/22/5jPJbA.jpg" alt="5jPJbA.jpg"></a></p><p>最后一个元素会上来补位，就成了这样：</p><p><a href="https://imgse.com/i/5jPqzh"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/22/5jPqzh.jpg" alt="5jPqzh.jpg"></a></p><p>现在，<em>Shiftdown</em>开始了。<br>先将36与17比较，发现36更大，于是把36与19交换，成了下图的样子：</p><p><a href="https://imgse.com/i/5jadsy"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/22/5jadsy.jpg" alt="5jadsy.jpg"></a></p><p>再把25与26比较，发现26更大，于是把26与19交换，成了这样：</p><p><a href="https://imgse.com/i/5jabEB"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax2x.com/2019/01/22/5jabEB.png" alt="5jabEB.png"></a></p><p>现在，19已经没有子节点了。于是我们可以break掉循环，结束<em>Shiftdown</em>了</p><p><strong>伪代码如下</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxn,number;</span><br><span class="line"> <span class="keyword">while</span>(Heap[x]有子结点)&#123;</span><br><span class="line">  maxn = max(它的左子结点 ， 它的右子结点);</span><br><span class="line"><span class="keyword">if</span>(maxn == 左子结点)&#123;</span><br><span class="line"> number = 左子结点的下标;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(maxn ==右子节点)&#123;</span><br><span class="line">number = 右子节点的下标; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span>(Heap[x] &lt; a[number])&#123;</span><br><span class="line">            将Heap[x]与相对较小的子结点交换</span><br><span class="line">            x = number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（ps.至于插入和删除一个元素，自己想想也就知道了。在这里不再专门讲述）<del>其实是作者太懒</del></p><hr><h4 id="输出堆顶元素"><a href="#输出堆顶元素" class="headerlink" title="输出堆顶元素"></a>输出堆顶元素</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; Heap[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>不知道为啥的请回看[如何存储一个堆]部分。</p><hr><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>如果是升序排序，就建一个小根堆持续弹出。</p><p>降序就建一个大根堆持续弹出即可。</p><hr><h3 id="堆的STL"><a href="#堆的STL" class="headerlink" title="堆的STL"></a>堆的STL</h3><blockquote><p>本部分仅适合c++选手食用，Pascal &amp; C选手请自觉跳过.(<del>怕你们怀疑自己选错语言</del>)</p></blockquote><p>众所周知，cpp为我们提供了一个很人性化的模板库——STL</p><p>那么……</p><p>堆在STL中有没有可以调用的模板呐？</p><p>答案是肯定的。</p><p>在STL中，堆有<strong>4种操作，分别为make_heap();  pop_heap();  push_heap();  sort_heap(); 它们都在algorithm库中</strong></p><p>下面,我们就来深入研究一下这4种操作</p><h4 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h4><p>光通过字面应该也能理解，这个函数是用来建立一个堆的。</p><p>格式为make_heap(begin , end);</p><p>默认建立的是一个大根堆哦。</p><p>既然如此，如果要建立一个小根堆该怎么办呐？</p><p><strong>写一个比较函数cmp不就行了！</strong></p><p>就像下边</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    make_heap(&amp;a[<span class="number">1</span>], &amp;a[n], cmp);</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个小根堆就这么建成了QVQ</p><p>但一定注意，cmp是放在end后边的。</p><hr><h4 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h4><p>这个函数可以将堆中的堆顶元素弹出。</p><p>就好像前面的Shiftdown一样</p><p>格式为pop_heap(begin , end , cmp); <strong>(大根堆不加cmp)</strong></p><hr><h4 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap"></a>push_heap</h4><p>既然有弹出，那就一定会有加入</p><p>而这个函数就可以在堆中加入一个元素。</p><p>就像前面的Shiftup。</p><p>格式为push_heap(begin , end , cmp); <strong>(大根堆不加cmp)</strong></p><hr><h4 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h4><p>显然，这是一个堆排序函数。</p><p>堆排序在实际排序时应用不多，但一些优化必须使用。</p><p>格式为sort_heap(begin , end , cmp); <strong>(大根堆不加cmp)</strong></p><p>但值得一提的是，<strong>堆排之后，这个堆就不是一个合法的堆了</strong>。</p><hr><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>想必大家都已经学会队列了吧 <del><a href="https://www.baidu.com">没学过的请点击这里</a></del></p><p>现在我们要讲的就是队列的一种特殊形式：优先队列</p><p>那么，什么是优先队列呐?</p><p>学过队列的同学都知道，<strong>队列</strong>就像公平的队伍一样，从后面进，前面出，<strong>出队的顺序与节点的权值无关</strong></p><p>而<strong>优先队列</strong>，就像一个不太公平的队伍。<strong>总是让当前权值最大或最小的节点先出队</strong>。</p><p>所以……</p><p><strong>这不就是一个典型的堆嘛QAQ</strong></p><p>但别忘了，<strong>优先队列</strong>也是队列，所以它的<strong>所有操作都包含在queue库中</strong></p><p>优先队列的定义如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span> &gt; Q;   <span class="comment">//定义一个名为Q的最大优先队列，队列里的数据类型为int型</span></span><br></pre></td></tr></table></figure><p>但是，<strong>优先队列默认为最大优先队列，即大根堆</strong>。如果我们要定义一个最小优先队列，写法就会不同。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span> , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; , greater&lt;<span class="keyword">int</span>&gt; &gt; Q;    <span class="comment">//定义一个名为Q的最小优先队列，数据类型为int</span></span><br></pre></td></tr></table></figure><p>随带提一句，<strong>greater<int>后面一定要有一个空格</strong>，否则的话会被编译器识别为右移运算符“&gt;&gt;”</p><p>现在，我们就来讲讲优先队列的几种操作。</p><hr><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>无疑，这个函数可以把一个元素加入优先队列，和队列中的push用法一样。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span> &gt; Q;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">Q.push(a);</span><br></pre></td></tr></table></figure><hr><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>这个函数可以获取队列中的最大或最小元素，即堆顶。<strong>但它并不会删除堆顶元素</strong>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span> &gt; Q;</span><br><span class="line"><span class="keyword">int</span> a = Q.top();</span><br></pre></td></tr></table></figure><hr><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>这个函数可以弹出堆顶元素，即删除堆顶元素。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span> &gt; Q;</span><br><span class="line">Q.pop();</span><br></pre></td></tr></table></figure><hr><h4 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h4><p>这个函数可以判断堆是否为空，返回值是一个bool型变量。</p><p>如果说队列为空，则返回true，否则返回false</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span> &gt; Q;</span><br><span class="line"><span class="keyword">bool</span> a;</span><br><span class="line">a = Q.empty;</span><br></pre></td></tr></table></figure><hr><h3 id="附件：堆-手写模板"><a href="#附件：堆-手写模板" class="headerlink" title="附件：堆[手写模板]"></a>附件：堆[手写模板]</h3><p><strong>代码描述：</strong> 见<a href="https://www.luogu.org/problemnew/show/P3378">洛谷P3378</a>.</p><p><strong>源代码</strong>（ps.防作弊已开启）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,len = <span class="number">1</span>,a[<span class="number">1000001</span>],ans[<span class="number">1000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[x] &lt; a[x / <span class="number">2</span>])&#123;</span><br><span class="line">            swap(a[x] , a[x / <span class="number">2</span>]);</span><br><span class="line">            x = x / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minn,number;</span><br><span class="line">    <span class="keyword">while</span>(x * <span class="number">2</span> + <span class="number">1</span> &lt;= len)&#123;</span><br><span class="line">        minn = min(a[x * <span class="number">2</span> + <span class="number">1</span>] , a[x * <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(minn == a[x * <span class="number">2</span> + <span class="number">1</span>])&#123;</span><br><span class="line">            number = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(minn == a[x * <span class="number">2</span>])&#123;</span><br><span class="line">            number = x * <span class="number">2</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[x] &gt; a[number])&#123;</span><br><span class="line">            swap(a[x] , a[number]);</span><br><span class="line">            x = number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    a[len] = x;</span><br><span class="line">    len ++;</span><br><span class="line">    shiftup(len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Return</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a[<span class="number">1</span>] = a[len - <span class="number">1</span>];</span><br><span class="line">    a[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    len --;</span><br><span class="line">    shiftdown(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,s;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">2</span>)&#123;</span><br><span class="line">            ans[c] = Return();</span><br><span class="line">            c ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">3</span>)&#123;</span><br><span class="line">            Delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="附件2-堆的STL实现"><a href="#附件2-堆的STL实现" class="headerlink" title="附件2 堆的STL实现"></a>附件2 堆的STL实现</h3><p><strong>代码描述</strong></p><p>这段代码是堆的STL实现的基本格式，注释会对代码进行解释，堆为小根堆。</p><p><strong>源代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//比较函数 </span></span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , a[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n; <span class="comment">//  输入6 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i]; <span class="comment">//输入2 3 5 8 1 9 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">make_heap(&amp;a[<span class="number">1</span>] , &amp;a[n] , cmp);</span><br><span class="line"><span class="comment">//此时，堆内元素为1 2 5 8 3 9 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[n]; <span class="comment">//输入4 </span></span><br><span class="line"></span><br><span class="line">push_heap(&amp;a[<span class="number">1</span>] , &amp;a[n + <span class="number">1</span>] , cmp); </span><br><span class="line"><span class="comment">//此时，堆内元素为1 2 4 8 3 5 9</span></span><br><span class="line"></span><br><span class="line">pop_heap(&amp;a[<span class="number">1</span>] , &amp;a[n + <span class="number">1</span>] , cmp); </span><br><span class="line"><span class="comment">//此时，堆内元素为2 3 4 8 9 5</span></span><br><span class="line"></span><br><span class="line">sort_heap(&amp;a[<span class="number">1</span>] , &amp;a[n + <span class="number">1</span>] , cmp);</span><br><span class="line"><span class="comment">//结果肯定是有序的…… </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="附件3-优先队列的STl实现"><a href="#附件3-优先队列的STl实现" class="headerlink" title="附件3 优先队列的STl实现"></a>附件3 优先队列的STl实现</h3><p>这份代码是优先队列的STL实现，同时也是<a href="https://www.luogu.org/problemnew/show/P1090">洛谷P1090</a>的标程，</p><p>因此，本代码开启防作弊功能。</p><p>但不要担心，优先队列的模板部分是没有错误的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span> , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; , greater&lt;<span class="keyword">int</span>&gt; &gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    work();</span><br><span class="line">    <span class="keyword">int</span> n , a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        Q.push(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Q.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">int</span> y = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        ans += x + y;</span><br><span class="line">        Q.push(x + y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><ul><li><p>2019.2.10 更新了标签，修改了少量错别字</p></li><li><p>2019.2.23 更新了STL部分</p></li><li><p>2019.3.30 更新了priority_queue部分</p></li></ul><p>……</p><hr><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【文章转载】sort&amp;unique入坑笔记</title>
      <link href="2019/01/21/sort-unique/"/>
      <url>2019/01/21/sort-unique/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文转载自<a href="https://herself32.github.io/2018/12/23/sort%E5%92%8Cunique/">Herself32’s Blog</a>。</p><a id="more"></a><blockquote><p>把STL放在心底，永远都有惊喜<br>                        ——《Tonight Forever》</p></blockquote><p>众所周知，排序在程序中会有很多的妙用。</p><p>但无论是冒泡、快排、插入排序、桶排等各种花样，总需要好多次的实践才能熟记于心。</p><p>用没有快捷的方法呢？</p><p>当然，$sort$是STL给出的答案。</p><h3 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h3><h4 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h4><p>首先你需要：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><br>其实命名空间可要可不要，如果去掉的话，在使用时就加一个<code>std::</code>即可啦QAQ。</p><p>cppSTLsort函数有(2~3)个参数。</p><p>为什么是(2~3)个参数呢？</p><p>因为在排序时，我们可以自己选择升序或降序。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>如果对于一个数组进行升序排序，那么<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">120</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">119</span>;i++)<span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">sort(num+<span class="number">1</span>,num+n+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p><strong>重点！</strong>：sort函数使用模板$sort(start-place,end-place)$</p><p>start-place：排序起点。<br>end-place：排序终点。</p><p>那么如果对于一个数组降序排序时，怎么写呢？</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">sort(num+<span class="number">1</span>,num+n+<span class="number">1</span>,cmp);</span><br></pre></td></tr></table></figure><h4 id="和其他STL搭配"><a href="#和其他STL搭配" class="headerlink" title="和其他STL搭配"></a>和其他STL搭配</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">sort(v.begin(),v.end());</span><br></pre></td></tr></table></figure><h3 id="UNIQUE"><a href="#UNIQUE" class="headerlink" title="UNIQUE"></a>UNIQUE</h3><p>unique的功能是对数组伪去重，即把重叠的数字置于数组最后。</p><h4 id="前置-1"><a href="#前置-1" class="headerlink" title="前置"></a>前置</h4><p>你需要：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><br>其实命名空间可要可不要，如果去掉的话，在使用时就加一个<code>std::</code>即可啦QAQ。</p><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">120</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">119</span>;i++)<span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">unique(num+<span class="number">1</span>,num+n+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>若想得到去重后数组元素个数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique(num+<span class="number">1</span>,num+n+<span class="number">1</span>)-num<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.org/problemnew/show/P1059">luogu P1059</a></p><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      <categories>
          
          <category> 转载区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> STL </tag>
            
            <tag> 文章转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2018/12/31/hello-world/"/>
      <url>2018/12/31/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 灌水 &amp; 摸鱼区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 灌水区 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
